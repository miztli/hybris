#include <enunciate-common.c>
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMap_H
#define DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMap_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_annotationHashMap {


  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType *entries;

  /**
   * Size of the entries array.
   */
  int _sizeof_entries;
};

/**
 * Reads a AnnotationHashMap from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The AnnotationHashMap, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *xmlTextReaderReadNs0AnnotationHashMapType(xmlTextReaderPtr reader);

/**
 * Writes a AnnotationHashMap to XML.
 *
 * @param writer The XML writer.
 * @param _annotationHashMap The AnnotationHashMap to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0AnnotationHashMapType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *_annotationHashMap);

/**
 * Frees the elements of a AnnotationHashMap.
 *
 * @param _annotationHashMap The AnnotationHashMap to free.
 */
static void freeNs0AnnotationHashMapType(struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *_annotationHashMap);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMap_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType_H
#define DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType {


  /**
   * (no documentation provided)
   */
  xmlChar *key;

  /**
   * (no documentation provided)
   */
  xmlChar *value;
};

/**
 * Reads a AnnotationHashMapEntryType from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The AnnotationHashMapEntryType, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType *xmlTextReaderReadNs0AnnotationHashMapEntryTypeType(xmlTextReaderPtr reader);

/**
 * Writes a AnnotationHashMapEntryType to XML.
 *
 * @param writer The XML writer.
 * @param _annotationHashMapEntryType The AnnotationHashMapEntryType to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0AnnotationHashMapEntryTypeType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType *_annotationHashMapEntryType);

/**
 * Frees the elements of a AnnotationHashMapEntryType.
 *
 * @param _annotationHashMapEntryType The AnnotationHashMapEntryType to free.
 */
static void freeNs0AnnotationHashMapEntryTypeType(struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType *_annotationHashMapEntryType);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisAddress_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisAddress_H

/**
 *  Representation of an address.
 *  
 */
struct hybris_cis_mock_subscription_web_ns0_cisAddress {


  /**
   * Type of the address.
   */
  enum hybris_cis_mock_subscription_web_ns0_cisAddressType *type;

  /**
   * Title.
   */
  xmlChar *title;

  /**
   * First name.
   */
  xmlChar *firstName;

  /**
   * Last name.
   */
  xmlChar *lastName;

  /**
   * Email.
   */
  xmlChar *email;

  /**
   * First address line.
   */
  xmlChar *addressLine1;

  /**
   * Second address line.
   */
  xmlChar *addressLine2;

  /**
   * Third address line.
   */
  xmlChar *addressLine3;

  /**
   * Fourth address line.
   */
  xmlChar *addressLine4;

  /**
   * Zip/Postal code.
   */
  xmlChar *zipCode;

  /**
   * City.
   */
  xmlChar *city;

  /**
   * Second part of the ISO 3166-2 subdivision code (e.g. state or province code without country).
   */
  xmlChar *state;

  /**
   * 2 letter ISO 3166-1 alpha-2 country code.
   */
  xmlChar *country;

  /**
   * The phone number.
   */
  xmlChar *phone;

  /**
   * The company name.
   */
  xmlChar *company;

  /**
   * Longitude of the address. Negative values are in the Western hemisphere. Positive values are in the Eastern hemisphere.
   */
  xmlChar *longitude;

  /**
   * Latitude of the address. Negative values are in the Southern hemisphere. Positive values are in the Northern hemisphere.
   */
  xmlChar *latitude;

  /**
   * the type of the facility.
   */
  xmlChar *facilityType;

  /**
   * The name of the facility.
   */
  xmlChar *facilityName;

  /**
   * The fax number belonging to this address.
   */
  xmlChar *faxNumber;

  /**
   * Vendor specific values to pass in the request.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorParameters;
};

/**
 * Reads a CisAddress element from XML. The element to be read is "address", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisAddress, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisAddress *xml_read_hybris_cis_mock_subscription_web_ns0_cisAddress(xmlTextReaderPtr reader);

/**
 * Writes a CisAddress to XML under element name "address".
 *
 * @param writer The XML writer.
 * @param _cisAddress The CisAddress to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisAddress(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress);

/**
 * Frees a CisAddress.
 *
 * @param _cisAddress The CisAddress to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisAddress(struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress);

/**
 * Reads a CisAddress element from XML. The element to be read is "address", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisAddress, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisAddress *xmlTextReaderReadNs0AddressElement(xmlTextReaderPtr reader);

/**
 * Writes a CisAddress to XML under element name "address".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisAddress The CisAddress to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0AddressElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress);

/**
 * Writes a CisAddress to XML under element name "address".
 *
 * @param writer The XML writer.
 * @param _cisAddress The CisAddress to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0AddressElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress, int writeNamespaces);

/**
 * Frees the children of a CisAddress.
 *
 * @param _cisAddress The CisAddress whose children are to be free.
 */
static void freeNs0AddressElement(struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress);

/**
 * Reads a CisAddress from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisAddress, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisAddress *xmlTextReaderReadNs0CisAddressType(xmlTextReaderPtr reader);

/**
 * Writes a CisAddress to XML.
 *
 * @param writer The XML writer.
 * @param _cisAddress The CisAddress to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisAddressType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress);

/**
 * Frees the elements of a CisAddress.
 *
 * @param _cisAddress The CisAddress to free.
 */
static void freeNs0CisAddressType(struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisAddress_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisAddressType_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisAddressType_H

/**
 * (no documentation provided)
 */
enum hybris_cis_mock_subscription_web_ns0_cisAddressType {

  /**
   * (no documentation provided)
   */
  HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_SHIP_TO,

  /**
   * (no documentation provided)
   */
  HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_SHIP_FROM,

  /**
   * (no documentation provided)
   */
  HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_BILL_TO,

  /**
   * (no documentation provided)
   */
  HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_ADMIN_ORIGIN
};

/**
 * Reads a CisAddressType from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisAddressType, or NULL if unable to be read.
 */
static enum hybris_cis_mock_subscription_web_ns0_cisAddressType *xmlTextReaderReadNs0CisAddressTypeType(xmlTextReaderPtr reader);

/**
 * Writes a CisAddressType to XML.
 *
 * @param writer The XML writer.
 * @param _cisAddressType The CisAddressType to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisAddressTypeType(xmlTextWriterPtr writer, enum hybris_cis_mock_subscription_web_ns0_cisAddressType *_cisAddressType);

/**
 * Frees a CisAddressType.
 *
 * @param _cisAddressType The CisAddressType to free.
 */
static void freeNs0CisAddressTypeType(enum hybris_cis_mock_subscription_web_ns0_cisAddressType *_cisAddressType);

#endif
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisDecision_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisDecision_H

/**
 * (no documentation provided)
 */
enum hybris_cis_mock_subscription_web_ns0_cisDecision {

  /**
   * (no documentation provided)
   */
  HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_ACCEPT,

  /**
   * (no documentation provided)
   */
  HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_REVIEW,

  /**
   * (no documentation provided)
   */
  HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_REJECT,

  /**
   * (no documentation provided)
   */
  HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_ERROR
};

/**
 * Reads a CisDecision from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisDecision, or NULL if unable to be read.
 */
static enum hybris_cis_mock_subscription_web_ns0_cisDecision *xmlTextReaderReadNs0CisDecisionType(xmlTextReaderPtr reader);

/**
 * Writes a CisDecision to XML.
 *
 * @param writer The XML writer.
 * @param _cisDecision The CisDecision to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisDecisionType(xmlTextWriterPtr writer, enum hybris_cis_mock_subscription_web_ns0_cisDecision *_cisDecision);

/**
 * Frees a CisDecision.
 *
 * @param _cisDecision The CisDecision to free.
 */
static void freeNs0CisDecisionType(enum hybris_cis_mock_subscription_web_ns0_cisDecision *_cisDecision);

#endif
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisLineItem_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisLineItem_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_cisLineItem {


  /**
   * (no documentation provided)
   */
  int *id;

  /**
   * (no documentation provided)
   */
  xmlChar *itemCode;

  /**
   * (no documentation provided)
   */
  int *quantity;

  /**
   * (no documentation provided)
   */
  xmlChar *productDescription;

  /**
   * (no documentation provided)
   */
  xmlChar *unitPrice;

  /**
   * (no documentation provided)
   */
  xmlChar *taxCode;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorParameters;
};

/**
 * Reads a CisLineItem from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisLineItem, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisLineItem *xmlTextReaderReadNs0CisLineItemType(xmlTextReaderPtr reader);

/**
 * Writes a CisLineItem to XML.
 *
 * @param writer The XML writer.
 * @param _cisLineItem The CisLineItem to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisLineItemType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisLineItem *_cisLineItem);

/**
 * Frees the elements of a CisLineItem.
 *
 * @param _cisLineItem The CisLineItem to free.
 */
static void freeNs0CisLineItemType(struct hybris_cis_mock_subscription_web_ns0_cisLineItem *_cisLineItem);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisLineItem_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisResult_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisResult_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_cisResult {


  /**
   * (no documentation provided)
   */
  xmlChar *clientRefId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorReasonCode;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorStatusCode;

  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  xmlChar *href;

  /**
   * (no documentation provided)
   */
  enum hybris_cis_mock_subscription_web_ns0_cisDecision *decision;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorResponses;
};

/**
 * Reads a CisResult from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisResult *xmlTextReaderReadNs0CisResultType(xmlTextReaderPtr reader);

/**
 * Writes a CisResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisResult The CisResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisResult *_cisResult);

/**
 * Frees the elements of a CisResult.
 *
 * @param _cisResult The CisResult to free.
 */
static void freeNs0CisResultType(struct hybris_cis_mock_subscription_web_ns0_cisResult *_cisResult);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisResult_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest_H

/**
 *  A request for changing an existing payment method.
 */
struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * The payment method to change.
   */
  xmlChar *merchantPaymentMethodId;

  /**
   * The action to perform.
   */
  xmlChar *action;

  /**
   * New value to be provided.
   */
  xmlChar *newValue;

  /**
   * Indicates if the changes should also be applied to subscriptions that use the payment method.
   */
  int propagate;
};

/**
 * Reads a CisChangePaymentMethodRequest element from XML. The element to be read is "subscriptionChangePaymentMethodRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisChangePaymentMethodRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisChangePaymentMethodRequest to XML under element name "subscriptionChangePaymentMethodRequest".
 *
 * @param writer The XML writer.
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest);

/**
 * Frees a CisChangePaymentMethodRequest.
 *
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest(struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest);

/**
 * Reads a CisChangePaymentMethodRequest element from XML. The element to be read is "subscriptionChangePaymentMethodRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisChangePaymentMethodRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *xmlTextReaderReadNs0SubscriptionChangePaymentMethodRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisChangePaymentMethodRequest to XML under element name "subscriptionChangePaymentMethodRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionChangePaymentMethodRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest);

/**
 * Writes a CisChangePaymentMethodRequest to XML under element name "subscriptionChangePaymentMethodRequest".
 *
 * @param writer The XML writer.
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionChangePaymentMethodRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest, int writeNamespaces);

/**
 * Frees the children of a CisChangePaymentMethodRequest.
 *
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest whose children are to be free.
 */
static void freeNs0SubscriptionChangePaymentMethodRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest);

/**
 * Reads a CisChangePaymentMethodRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisChangePaymentMethodRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *xmlTextReaderReadNs0CisChangePaymentMethodRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisChangePaymentMethodRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisChangePaymentMethodRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest);

/**
 * Frees the elements of a CisChangePaymentMethodRequest.
 *
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to free.
 */
static void freeNs0CisChangePaymentMethodRequestType(struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisChargeEntry_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisChargeEntry_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry {


  /**
   * (no documentation provided)
   */
  xmlChar *oneTimeChargeTime;

  /**
   * (no documentation provided)
   */
  xmlChar *chargePrice;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorParameters;

  /**
   * (no documentation provided)
   */
  int *numberOfCycles;
};

/**
 * Reads a CisChargeEntry from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisChargeEntry, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry *xmlTextReaderReadNs0CisChargeEntryType(xmlTextReaderPtr reader);

/**
 * Writes a CisChargeEntry to XML.
 *
 * @param writer The XML writer.
 * @param _cisChargeEntry The CisChargeEntry to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisChargeEntryType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry *_cisChargeEntry);

/**
 * Frees the elements of a CisChargeEntry.
 *
 * @param _cisChargeEntry The CisChargeEntry to free.
 */
static void freeNs0CisChargeEntryType(struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry *_cisChargeEntry);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisChargeEntry_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest_H

/**
 *  
 *  Customer usage request that holds customer usage information.
 *  
 */
struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest {


  /**
   * from date for the customer usage.
   */
  struct tm *fromDate;

  /**
   * to date for the customer usage.
   */
  struct tm *toDate;

  /**
   * customer id for the current usage.
   */
  xmlChar *customerId;

  /**
   * the subscription id.
   */
  xmlChar *subscriptionId;

  /**
   * usage charge name for the customer usage.
   */
  xmlChar *usageChargeName;

  /**
   * units consumed.
   */
  xmlChar *unitsConsumed;
};

/**
 * Reads a CisCustomerUsageRequest element from XML. The element to be read is "customerUsageRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisCustomerUsageRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisCustomerUsageRequest to XML under element name "customerUsageRequest".
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest);

/**
 * Frees a CisCustomerUsageRequest.
 *
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest);

/**
 * Reads a CisCustomerUsageRequest element from XML. The element to be read is "customerUsageRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisCustomerUsageRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *xmlTextReaderReadNs0CustomerUsageRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisCustomerUsageRequest to XML under element name "customerUsageRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CustomerUsageRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest);

/**
 * Writes a CisCustomerUsageRequest to XML under element name "customerUsageRequest".
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CustomerUsageRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest, int writeNamespaces);

/**
 * Frees the children of a CisCustomerUsageRequest.
 *
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest whose children are to be free.
 */
static void freeNs0CustomerUsageRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest);

/**
 * Reads a CisCustomerUsageRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisCustomerUsageRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *xmlTextReaderReadNs0CisCustomerUsageRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisCustomerUsageRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisCustomerUsageRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest);

/**
 * Frees the elements of a CisCustomerUsageRequest.
 *
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to free.
 */
static void freeNs0CisCustomerUsageRequestType(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult_H

/**
 *  The result of a pass customer usage call.
 */
struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult {


  /**
   * (no documentation provided)
   */
  xmlChar *clientRefId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorReasonCode;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorStatusCode;

  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  xmlChar *href;

  /**
   * (no documentation provided)
   */
  enum hybris_cis_mock_subscription_web_ns0_cisDecision *decision;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorResponses;
};

/**
 * Reads a CisCustomerUsageResult element from XML. The element to be read is "customerUsage", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisCustomerUsageResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult(xmlTextReaderPtr reader);

/**
 * Writes a CisCustomerUsageResult to XML under element name "customerUsage".
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult);

/**
 * Frees a CisCustomerUsageResult.
 *
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult);

/**
 * Reads a CisCustomerUsageResult element from XML. The element to be read is "customerUsage", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisCustomerUsageResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *xmlTextReaderReadNs0CustomerUsageElement(xmlTextReaderPtr reader);

/**
 * Writes a CisCustomerUsageResult to XML under element name "customerUsage".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CustomerUsageElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult);

/**
 * Writes a CisCustomerUsageResult to XML under element name "customerUsage".
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CustomerUsageElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult, int writeNamespaces);

/**
 * Frees the children of a CisCustomerUsageResult.
 *
 * @param _cisCustomerUsageResult The CisCustomerUsageResult whose children are to be free.
 */
static void freeNs0CustomerUsageElement(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult);

/**
 * Reads a CisCustomerUsageResult from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisCustomerUsageResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *xmlTextReaderReadNs0CisCustomerUsageResultType(xmlTextReaderPtr reader);

/**
 * Writes a CisCustomerUsageResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisCustomerUsageResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult);

/**
 * Frees the elements of a CisCustomerUsageResult.
 *
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to free.
 */
static void freeNs0CisCustomerUsageResultType(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult_H

/**
 *  Presents result of billing activity detail request.
 */
struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult {


  /**
   * (no documentation provided)
   */
  xmlChar *clientRefId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorReasonCode;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorStatusCode;

  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  xmlChar *href;

  /**
   * (no documentation provided)
   */
  enum hybris_cis_mock_subscription_web_ns0_cisDecision *decision;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorResponses;

  /**
   * Byte stream for file downloading.
   */
  unsigned char *bytes;

  /**
   * Size of the bytes data.
   */
  int _sizeof_bytes;

  /**
   * Describes content type.
   */
  xmlChar *mimeType;

  /**
   * The file name.
   */
  xmlChar *fileName;
};

/**
 * Reads a CisFileStreamResult element from XML. The element to be read is "fileStream", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisFileStreamResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult(xmlTextReaderPtr reader);

/**
 * Writes a CisFileStreamResult to XML under element name "fileStream".
 *
 * @param writer The XML writer.
 * @param _cisFileStreamResult The CisFileStreamResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult);

/**
 * Frees a CisFileStreamResult.
 *
 * @param _cisFileStreamResult The CisFileStreamResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult(struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult);

/**
 * Reads a CisFileStreamResult element from XML. The element to be read is "fileStream", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisFileStreamResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *xmlTextReaderReadNs0FileStreamElement(xmlTextReaderPtr reader);

/**
 * Writes a CisFileStreamResult to XML under element name "fileStream".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisFileStreamResult The CisFileStreamResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0FileStreamElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult);

/**
 * Writes a CisFileStreamResult to XML under element name "fileStream".
 *
 * @param writer The XML writer.
 * @param _cisFileStreamResult The CisFileStreamResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0FileStreamElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult, int writeNamespaces);

/**
 * Frees the children of a CisFileStreamResult.
 *
 * @param _cisFileStreamResult The CisFileStreamResult whose children are to be free.
 */
static void freeNs0FileStreamElement(struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult);

/**
 * Reads a CisFileStreamResult from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisFileStreamResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *xmlTextReaderReadNs0CisFileStreamResultType(xmlTextReaderPtr reader);

/**
 * Writes a CisFileStreamResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisFileStreamResult The CisFileStreamResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisFileStreamResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult);

/**
 * Frees the elements of a CisFileStreamResult.
 *
 * @param _cisFileStreamResult The CisFileStreamResult to free.
 */
static void freeNs0CisFileStreamResultType(struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethod_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethod_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod {


  /**
   * (no documentation provided)
   */
  xmlChar *ccNumber;

  /**
   * (no documentation provided)
   */
  int enabled;

  /**
   * (no documentation provided)
   */
  int expirationMonth;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_cisAddress *billingAddress;

  /**
   * (no documentation provided)
   */
  int expirationYear;

  /**
   * (no documentation provided)
   */
  xmlChar *merchantPaymentMethodId;

  /**
   * (no documentation provided)
   */
  xmlChar *cardHolder;

  /**
   * (no documentation provided)
   */
  xmlChar *cardType;
};

/**
 * Reads a CisPaymentMethod from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethod, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *xmlTextReaderReadNs0CisPaymentMethodType(xmlTextReaderPtr reader);

/**
 * Writes a CisPaymentMethod to XML.
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethod The CisPaymentMethod to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisPaymentMethodType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *_cisPaymentMethod);

/**
 * Frees the elements of a CisPaymentMethod.
 *
 * @param _cisPaymentMethod The CisPaymentMethod to free.
 */
static void freeNs0CisPaymentMethodType(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *_cisPaymentMethod);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethod_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult_H

/**
 *  Result type for payment method related requests.
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult {


  /**
   * (no documentation provided)
   */
  xmlChar *clientRefId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorReasonCode;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorStatusCode;

  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  xmlChar *href;

  /**
   * (no documentation provided)
   */
  enum hybris_cis_mock_subscription_web_ns0_cisDecision *decision;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorResponses;

  /**
   * The payment method.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *paymentMethod;
};

/**
 * Reads a CisPaymentMethodResult element from XML. The element to be read is "paymentMethodResult", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethodResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult(xmlTextReaderPtr reader);

/**
 * Writes a CisPaymentMethodResult to XML under element name "paymentMethodResult".
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult);

/**
 * Frees a CisPaymentMethodResult.
 *
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult);

/**
 * Reads a CisPaymentMethodResult element from XML. The element to be read is "paymentMethodResult", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethodResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *xmlTextReaderReadNs0PaymentMethodResultElement(xmlTextReaderPtr reader);

/**
 * Writes a CisPaymentMethodResult to XML under element name "paymentMethodResult".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0PaymentMethodResultElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult);

/**
 * Writes a CisPaymentMethodResult to XML under element name "paymentMethodResult".
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0PaymentMethodResultElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult, int writeNamespaces);

/**
 * Frees the children of a CisPaymentMethodResult.
 *
 * @param _cisPaymentMethodResult The CisPaymentMethodResult whose children are to be free.
 */
static void freeNs0PaymentMethodResultElement(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult);

/**
 * Reads a CisPaymentMethodResult from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethodResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *xmlTextReaderReadNs0CisPaymentMethodResultType(xmlTextReaderPtr reader);

/**
 * Writes a CisPaymentMethodResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisPaymentMethodResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult);

/**
 * Frees the elements of a CisPaymentMethodResult.
 *
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to free.
 */
static void freeNs0CisPaymentMethodResultType(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest_H

/**
 *  Request for updating an existing payment method.
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * The payment method to change.
   */
  xmlChar *merchantPaymentMethodId;

  /**
   * Enable or disable the payment method.
   */
  int *enabled;

  /**
   * Updated billing address.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisAddress *billingAddress;

  /**
   * Indicates whether the updates should also be applied to subscriptions that use the payment method.
   */
  int *propagate;
};

/**
 * Reads a CisPaymentMethodUpdateRequest element from XML. The element to be read is "paymentMethodUpdateRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethodUpdateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisPaymentMethodUpdateRequest to XML under element name "paymentMethodUpdateRequest".
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest);

/**
 * Frees a CisPaymentMethodUpdateRequest.
 *
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest);

/**
 * Reads a CisPaymentMethodUpdateRequest element from XML. The element to be read is "paymentMethodUpdateRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethodUpdateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *xmlTextReaderReadNs0PaymentMethodUpdateRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisPaymentMethodUpdateRequest to XML under element name "paymentMethodUpdateRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0PaymentMethodUpdateRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest);

/**
 * Writes a CisPaymentMethodUpdateRequest to XML under element name "paymentMethodUpdateRequest".
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0PaymentMethodUpdateRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest, int writeNamespaces);

/**
 * Frees the children of a CisPaymentMethodUpdateRequest.
 *
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest whose children are to be free.
 */
static void freeNs0PaymentMethodUpdateRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest);

/**
 * Reads a CisPaymentMethodUpdateRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethodUpdateRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *xmlTextReaderReadNs0CisPaymentMethodUpdateRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisPaymentMethodUpdateRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisPaymentMethodUpdateRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest);

/**
 * Frees the elements of a CisPaymentMethodUpdateRequest.
 *
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to free.
 */
static void freeNs0CisPaymentMethodUpdateRequestType(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList_H

/**
 *  Retrieves a billing activity list for subscription.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList {


  /**
   * (no documentation provided)
   */
  xmlChar *clientRefId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorReasonCode;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorStatusCode;

  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  xmlChar *href;

  /**
   * (no documentation provided)
   */
  enum hybris_cis_mock_subscription_web_ns0_cisDecision *decision;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorResponses;

  /**
   * Merchant ID of a subscription.
   */
  xmlChar *merchantSubscriptionId;

  /**
   * List billings.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *billings;

  /**
   * Size of the billings array.
   */
  int _sizeof_billings;
};

/**
 * Reads a CisSubscriptionBillingActivityList element from XML. The element to be read is "billingActivityList", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionBillingActivityList, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionBillingActivityList to XML under element name "billingActivityList".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList);

/**
 * Frees a CisSubscriptionBillingActivityList.
 *
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList);

/**
 * Reads a CisSubscriptionBillingActivityList element from XML. The element to be read is "billingActivityList", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionBillingActivityList, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *xmlTextReaderReadNs0BillingActivityListElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionBillingActivityList to XML under element name "billingActivityList".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0BillingActivityListElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList);

/**
 * Writes a CisSubscriptionBillingActivityList to XML under element name "billingActivityList".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0BillingActivityListElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionBillingActivityList.
 *
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList whose children are to be free.
 */
static void freeNs0BillingActivityListElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList);

/**
 * Reads a CisSubscriptionBillingActivityList from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionBillingActivityList, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *xmlTextReaderReadNs0CisSubscriptionBillingActivityListType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionBillingActivityList to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionBillingActivityListType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList);

/**
 * Frees the elements of a CisSubscriptionBillingActivityList.
 *
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to free.
 */
static void freeNs0CisSubscriptionBillingActivityListType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo_H

/**
 *  Sub-Element defining a billing for subscription.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo {


  /**
   * (no documentation provided)
   */
  xmlChar *billingId;

  /**
   * (no documentation provided)
   */
  xmlChar *billingPeriod;

  /**
   * (no documentation provided)
   */
  xmlChar *billingDate;

  /**
   * (no documentation provided)
   */
  xmlChar *amount;

  /**
   * (no documentation provided)
   */
  xmlChar *status;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *customFields;
};

/**
 * Reads a CisSubscriptionBillingInfo element from XML. The element to be read is "billing", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionBillingInfo, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionBillingInfo to XML under element name "billing".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo);

/**
 * Frees a CisSubscriptionBillingInfo.
 *
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo);

/**
 * Reads a CisSubscriptionBillingInfo element from XML. The element to be read is "billing", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionBillingInfo, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *xmlTextReaderReadNs0BillingElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionBillingInfo to XML under element name "billing".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0BillingElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo);

/**
 * Writes a CisSubscriptionBillingInfo to XML under element name "billing".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0BillingElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionBillingInfo.
 *
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo whose children are to be free.
 */
static void freeNs0BillingElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo);

/**
 * Reads a CisSubscriptionBillingInfo from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionBillingInfo, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *xmlTextReaderReadNs0CisSubscriptionBillingInfoType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionBillingInfo to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionBillingInfoType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo);

/**
 * Frees the elements of a CisSubscriptionBillingInfo.
 *
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to free.
 */
static void freeNs0CisSubscriptionBillingInfoType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest_H

/**
 *  A request to cancel an existing subscription.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * Identifying attribute of the subscription.
   */
  xmlChar *merchantSubscriptionId;

  /**
   * The cancellation mode.
   */
  xmlChar *cancelationMode;

  /**
   * If subscription should be canceled immediately.
   */
  int force;
};

/**
 * Reads a CisSubscriptionCancelSubscriptionRequest element from XML. The element to be read is "subscriptionCancelSubscriptionRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionCancelSubscriptionRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionCancelSubscriptionRequest to XML under element name "subscriptionCancelSubscriptionRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest);

/**
 * Frees a CisSubscriptionCancelSubscriptionRequest.
 *
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest);

/**
 * Reads a CisSubscriptionCancelSubscriptionRequest element from XML. The element to be read is "subscriptionCancelSubscriptionRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionCancelSubscriptionRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *xmlTextReaderReadNs0SubscriptionCancelSubscriptionRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionCancelSubscriptionRequest to XML under element name "subscriptionCancelSubscriptionRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionCancelSubscriptionRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest);

/**
 * Writes a CisSubscriptionCancelSubscriptionRequest to XML under element name "subscriptionCancelSubscriptionRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionCancelSubscriptionRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionCancelSubscriptionRequest.
 *
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest whose children are to be free.
 */
static void freeNs0SubscriptionCancelSubscriptionRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest);

/**
 * Reads a CisSubscriptionCancelSubscriptionRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionCancelSubscriptionRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *xmlTextReaderReadNs0CisSubscriptionCancelSubscriptionRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionCancelSubscriptionRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionCancelSubscriptionRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest);

/**
 * Frees the elements of a CisSubscriptionCancelSubscriptionRequest.
 *
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to free.
 */
static void freeNs0CisSubscriptionCancelSubscriptionRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest_H

/**
 *  Generic request type for subscription state changes.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * (no documentation provided)
   */
  xmlChar *effectiveFrom;

  /**
   * (no documentation provided)
   */
  xmlChar *merchantSubscriptionId;

  /**
   * (no documentation provided)
   */
  xmlChar *newState;
};

/**
 * Reads a CisSubscriptionChangeStateRequest element from XML. The element to be read is "subscriptionChangeStateRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionChangeStateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionChangeStateRequest to XML under element name "subscriptionChangeStateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest);

/**
 * Frees a CisSubscriptionChangeStateRequest.
 *
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest);

/**
 * Reads a CisSubscriptionChangeStateRequest element from XML. The element to be read is "subscriptionChangeStateRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionChangeStateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *xmlTextReaderReadNs0SubscriptionChangeStateRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionChangeStateRequest to XML under element name "subscriptionChangeStateRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionChangeStateRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest);

/**
 * Writes a CisSubscriptionChangeStateRequest to XML under element name "subscriptionChangeStateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionChangeStateRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionChangeStateRequest.
 *
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest whose children are to be free.
 */
static void freeNs0SubscriptionChangeStateRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest);

/**
 * Reads a CisSubscriptionChangeStateRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionChangeStateRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *xmlTextReaderReadNs0CisSubscriptionChangeStateRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionChangeStateRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionChangeStateRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest);

/**
 * Frees the elements of a CisSubscriptionChangeStateRequest.
 *
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to free.
 */
static void freeNs0CisSubscriptionChangeStateRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest_H

/**
 *  Request for subscription creation.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * Identifying order that subscription related to.
   */
  xmlChar *orderId;

  /**
   * 3 letter ISO 4217 currency code.
   */
  xmlChar *currency;

  /**
   * (no documentation provided)
   */
  struct tm *orderDate;

  /**
   * Identifying attribute of the buyer.
   */
  xmlChar *merchantAccountId;

  /**
   * ID of the payment method.
   */
  xmlChar *merchantPaymentMethodId;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem *subscriptionItem;
};

/**
 * Reads a CisSubscriptionCreateRequest element from XML. The element to be read is "subscriptionCreateRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionCreateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionCreateRequest to XML under element name "subscriptionCreateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest);

/**
 * Frees a CisSubscriptionCreateRequest.
 *
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest);

/**
 * Reads a CisSubscriptionCreateRequest element from XML. The element to be read is "subscriptionCreateRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionCreateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *xmlTextReaderReadNs0SubscriptionCreateRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionCreateRequest to XML under element name "subscriptionCreateRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionCreateRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest);

/**
 * Writes a CisSubscriptionCreateRequest to XML under element name "subscriptionCreateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionCreateRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionCreateRequest.
 *
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest whose children are to be free.
 */
static void freeNs0SubscriptionCreateRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest);

/**
 * Reads a CisSubscriptionCreateRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionCreateRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *xmlTextReaderReadNs0CisSubscriptionCreateRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionCreateRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionCreateRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest);

/**
 * Frees the elements of a CisSubscriptionCreateRequest.
 *
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to free.
 */
static void freeNs0CisSubscriptionCreateRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData_H

/**
 *  Retrieves subscription data from a Subscription Billing Provider.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData {


  /**
   * (no documentation provided)
   */
  xmlChar *clientRefId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorReasonCode;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorStatusCode;

  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  xmlChar *href;

  /**
   * (no documentation provided)
   */
  enum hybris_cis_mock_subscription_web_ns0_cisDecision *decision;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorResponses;

  /**
   * merchant ID of a customer account.
   */
  xmlChar *merchantAccountId;

  /**
   * 3 letter ISO 4217 currency code. Default currency for this profile.
   */
  xmlChar *currency;

  /**
   * Merchant ID of a subscription.
   */
  xmlChar *subscriptionId;

  /**
   * Merchant name of a subscription product.
   */
  xmlChar *subscriptionName;

  /**
   * Merchant description of a subscription product.
   */
  xmlChar *subscriptionDescription;

  /**
   * Merchant ID of a subscription product.
   */
  xmlChar *subscriptionProductId;

  /**
   * Merchant order number containing this subscription product.
   */
  xmlChar *subscriptionOrderId;

  /**
   * Merchant order entry number containing this subscription product.
   */
  xmlChar *subscriptionOrderEntryId;

  /**
   * Billing system id.
   */
  xmlChar *billingSystemId;

  /**
   * Start date of a subscription.
   */
  struct tm *subscriptionStartDate;

  /**
   * End date of a subscription.
   */
  struct tm *subscriptionEndDate;

  /**
   * Status of a subscription.
   */
  xmlChar *subscriptionStatus;

  /**
   * Determines if a subscription is cancellable.
   */
  int *cancellationPossible;

  /**
   * Billing frequency.
   */
  xmlChar *billingFrequency;

  /**
   * Contract duration.
   */
  xmlChar *contractDuration;

  /**
   * When was the subscription order placed originally.
   */
  struct tm *orderDate;

  /**
   * When was the subscription order cancelled.
   */
  struct tm *cancelDate;

  /**
   * Comments about the creation.
   */
  xmlChar *comments;

  /**
   * Copy of the payment method of the corresponding account used by this subscription.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *paymentMethod;

  /**
   * AutoRenewal flag of a subscription.
   */
  int *autoRenewal;
};

/**
 * Reads a CisSubscriptionData element from XML. The element to be read is "subscriptionData", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionData, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionData to XML under element name "subscriptionData".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionData The CisSubscriptionData to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData);

/**
 * Frees a CisSubscriptionData.
 *
 * @param _cisSubscriptionData The CisSubscriptionData to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData);

/**
 * Reads a CisSubscriptionData element from XML. The element to be read is "subscriptionData", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionData, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *xmlTextReaderReadNs0SubscriptionDataElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionData to XML under element name "subscriptionData".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionData The CisSubscriptionData to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionDataElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData);

/**
 * Writes a CisSubscriptionData to XML under element name "subscriptionData".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionData The CisSubscriptionData to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionDataElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionData.
 *
 * @param _cisSubscriptionData The CisSubscriptionData whose children are to be free.
 */
static void freeNs0SubscriptionDataElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData);

/**
 * Reads a CisSubscriptionData from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionData, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *xmlTextReaderReadNs0CisSubscriptionDataType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionData to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionData The CisSubscriptionData to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionDataType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData);

/**
 * Frees the elements of a CisSubscriptionData.
 *
 * @param _cisSubscriptionData The CisSubscriptionData to free.
 */
static void freeNs0CisSubscriptionDataType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem {


  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  xmlChar *code;

  /**
   * (no documentation provided)
   */
  xmlChar *name;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorParameters;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService *subscriptionTerm;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan *subscriptionPlan;
};

/**
 * Reads a CisSubscriptionItem from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionItem, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem *xmlTextReaderReadNs0CisSubscriptionItemType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionItem to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionItem The CisSubscriptionItem to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionItemType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem *_cisSubscriptionItem);

/**
 * Frees the elements of a CisSubscriptionItem.
 *
 * @param _cisSubscriptionItem The CisSubscriptionItem to free.
 */
static void freeNs0CisSubscriptionItemType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem *_cisSubscriptionItem);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder_H

/**
 *  A subscription order containing a list of subscription items.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder {


  /**
   * Unique id (e.g order/shipment/return number).
   */
  xmlChar *id;

  /**
   * Date used for records (e.g. order/shipping/return date).
   */
  struct tm *date;

  /**
   * 3 letter ISO 4217 currency code.
   */
  xmlChar *currency;

  /**
   * List of addresses.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisAddress *addresses;

  /**
   * Size of the addresses array.
   */
  int _sizeof_addresses;

  /**
   * List of line items. intended for "Buy now" items in cart
   */
  struct hybris_cis_mock_subscription_web_ns0_cisLineItem *lineItems;

  /**
   * Size of the lineItems array.
   */
  int _sizeof_lineItems;

  /**
   * Vendor specific values to pass in the request.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorParameters;

  /**
   * unique identifier for a specific account.
   */
  xmlChar *merchantAccountId;

  /**
   * List of subscription items.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem *items;

  /**
   * Size of the items array.
   */
  int _sizeof_items;
};

/**
 * Reads a CisSubscriptionOrder element from XML. The element to be read is "subscriptionorder", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionOrder, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionOrder to XML under element name "subscriptionorder".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder);

/**
 * Frees a CisSubscriptionOrder.
 *
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder);

/**
 * Reads a CisSubscriptionOrder element from XML. The element to be read is "subscriptionorder", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionOrder, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *xmlTextReaderReadNs0SubscriptionorderElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionOrder to XML under element name "subscriptionorder".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionorderElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder);

/**
 * Writes a CisSubscriptionOrder to XML under element name "subscriptionorder".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionorderElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionOrder.
 *
 * @param _cisSubscriptionOrder The CisSubscriptionOrder whose children are to be free.
 */
static void freeNs0SubscriptionorderElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder);

/**
 * Reads a CisSubscriptionOrder from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionOrder, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *xmlTextReaderReadNs0CisSubscriptionOrderType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionOrder to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionOrderType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder);

/**
 * Frees the elements of a CisSubscriptionOrder.
 *
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to free.
 */
static void freeNs0CisSubscriptionOrderType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest_H

/**
 *  A subscription order request.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * Identifying attribute of the buyer.
   */
  xmlChar *merchantAccountId;

  /**
   * Identifying attribute of the payment method (if available).
   */
  xmlChar *merchantPaymentMethodId;

  /**
   * The subscription order.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *subscriptionOrder;

  /**
   * 3 letter ISO 4217 currency code.
   */
  xmlChar *currency;
};

/**
 * Reads a CisSubscriptionOrderPostRequest element from XML. The element to be read is "subscriptionOrderPostRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionOrderPostRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionOrderPostRequest to XML under element name "subscriptionOrderPostRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest);

/**
 * Frees a CisSubscriptionOrderPostRequest.
 *
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest);

/**
 * Reads a CisSubscriptionOrderPostRequest element from XML. The element to be read is "subscriptionOrderPostRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionOrderPostRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *xmlTextReaderReadNs0SubscriptionOrderPostRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionOrderPostRequest to XML under element name "subscriptionOrderPostRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionOrderPostRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest);

/**
 * Writes a CisSubscriptionOrderPostRequest to XML under element name "subscriptionOrderPostRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionOrderPostRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionOrderPostRequest.
 *
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest whose children are to be free.
 */
static void freeNs0SubscriptionOrderPostRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest);

/**
 * Reads a CisSubscriptionOrderPostRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionOrderPostRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *xmlTextReaderReadNs0CisSubscriptionOrderPostRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionOrderPostRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionOrderPostRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest);

/**
 * Frees the elements of a CisSubscriptionOrderPostRequest.
 *
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to free.
 */
static void freeNs0CisSubscriptionOrderPostRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest_H

/**
 *  A payment request to for example authorize or capture an amount.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * The amount of the transaction.
   */
  xmlChar *amount;

  /**
   * 3 letter ISO 4217 currency code.
   */
  xmlChar *currency;

  /**
   * ID of a payment profile.
   */
  xmlChar *profileId;

  /**
   * ID of the payment method.
   */
  xmlChar *paymentMethodId;

  /**
   * Merchant ID of the transaction.
   */
  xmlChar *merchantTransactionId;

  /**
   * Descriptive text for transaction.
   */
  xmlChar *merchantTransactionDescription;

  /**
   * List of line items.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisLineItem *lineItems;

  /**
   * Size of the lineItems array.
   */
  int _sizeof_lineItems;

  /**
   * Transaction mode (AUTH, CAPTURE or AUTHCAPTURE).
   */
  xmlChar *transactionMode;
};

/**
 * Reads a CisSubscriptionPayNowRequest element from XML. The element to be read is "subscriptionProcessPayNowRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionPayNowRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionPayNowRequest to XML under element name "subscriptionProcessPayNowRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest);

/**
 * Frees a CisSubscriptionPayNowRequest.
 *
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest);

/**
 * Reads a CisSubscriptionPayNowRequest element from XML. The element to be read is "subscriptionProcessPayNowRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionPayNowRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *xmlTextReaderReadNs0SubscriptionProcessPayNowRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionPayNowRequest to XML under element name "subscriptionProcessPayNowRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionProcessPayNowRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest);

/**
 * Writes a CisSubscriptionPayNowRequest to XML under element name "subscriptionProcessPayNowRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionProcessPayNowRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionPayNowRequest.
 *
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest whose children are to be free.
 */
static void freeNs0SubscriptionProcessPayNowRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest);

/**
 * Reads a CisSubscriptionPayNowRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionPayNowRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *xmlTextReaderReadNs0CisSubscriptionPayNowRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionPayNowRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionPayNowRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest);

/**
 * Frees the elements of a CisSubscriptionPayNowRequest.
 *
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to free.
 */
static void freeNs0CisSubscriptionPayNowRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan {


  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorParameters;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge *usageCharges;

  /**
   * Size of the usageCharges array.
   */
  int _sizeof_usageCharges;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry *charges;

  /**
   * Size of the charges array.
   */
  int _sizeof_charges;

  /**
   * (no documentation provided)
   */
  xmlChar *name;
};

/**
 * Reads a CisSubscriptionPlan from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionPlan, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan *xmlTextReaderReadNs0CisSubscriptionPlanType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionPlan to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionPlan The CisSubscriptionPlan to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionPlanType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan *_cisSubscriptionPlan);

/**
 * Frees the elements of a CisSubscriptionPlan.
 *
 * @param _cisSubscriptionPlan The CisSubscriptionPlan to free.
 */
static void freeNs0CisSubscriptionPlanType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan *_cisSubscriptionPlan);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest_H

/**
 *  Contains profile information.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * ID of a customer/account profile.
   */
  xmlChar *profileId;

  /**
   * Profile name.
   */
  xmlChar *customerName;

  /**
   * Company.
   */
  xmlChar *company;

  /**
   * 3 letter ISO 4217 currency code.
   */
  xmlChar *currency;

  /**
   * Email preference, either "plaintext", "html" or "multipart".
   */
  xmlChar *emailPreference;

  /**
   * Language preference, ISO 639-1 two-letter language code, e.g. de,en,.. .
   */
  xmlChar *languagePreference;

  /**
   * ID of a payment profile.
   */
  xmlChar *emailAddress;

  /**
   * The shipping address.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisAddress *shippingAddress;
};

/**
 * Reads a CisSubscriptionProfileRequest element from XML. The element to be read is "subscriptionProfileRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionProfileRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionProfileRequest to XML under element name "subscriptionProfileRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest);

/**
 * Frees a CisSubscriptionProfileRequest.
 *
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest);

/**
 * Reads a CisSubscriptionProfileRequest element from XML. The element to be read is "subscriptionProfileRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionProfileRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *xmlTextReaderReadNs0SubscriptionProfileRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionProfileRequest to XML under element name "subscriptionProfileRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionProfileRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest);

/**
 * Writes a CisSubscriptionProfileRequest to XML under element name "subscriptionProfileRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionProfileRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionProfileRequest.
 *
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest whose children are to be free.
 */
static void freeNs0SubscriptionProfileRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest);

/**
 * Reads a CisSubscriptionProfileRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionProfileRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *xmlTextReaderReadNs0CisSubscriptionProfileRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionProfileRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionProfileRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest);

/**
 * Frees the elements of a CisSubscriptionProfileRequest.
 *
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to free.
 */
static void freeNs0CisSubscriptionProfileRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult_H

/**
 *  Retrieves customer profile info from a Subscription Billing Provider.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult {


  /**
   * (no documentation provided)
   */
  xmlChar *clientRefId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorReasonCode;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorStatusCode;

  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  xmlChar *href;

  /**
   * (no documentation provided)
   */
  enum hybris_cis_mock_subscription_web_ns0_cisDecision *decision;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorResponses;

  /**
   * The amount / subscription price .
   */
  xmlChar *amount;

  /**
   * (no documentation provided)
   */
  xmlChar *sessionTransactionToken;

  /**
   * The transaction verification key.
   */
  xmlChar *merchantProductId;

  /**
   * ID of a payment profile.
   */
  xmlChar *profileId;

  /**
   * 3 letter ISO 4217 currency code. Default currency for this profile.
   */
  xmlChar *currency;

  /**
   * Result of either a profile check or of a set up fee capture used to validate the credit card.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *validationResult;

  /**
   * List of payment methods.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *paymentMethods;

  /**
   * Size of the paymentMethods array.
   */
  int _sizeof_paymentMethods;

  /**
   * Placeholder to contain list of subscriptions.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *subscriptions;

  /**
   * Size of the subscriptions array.
   */
  int _sizeof_subscriptions;

  /**
   * Customer information.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisAddress *customerAddress;

  /**
   * Comments about the creation.
   */
  xmlChar *comments;
};

/**
 * Reads a CisSubscriptionProfileResult element from XML. The element to be read is "subscriptionProfileResult", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionProfileResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionProfileResult to XML under element name "subscriptionProfileResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult);

/**
 * Frees a CisSubscriptionProfileResult.
 *
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult);

/**
 * Reads a CisSubscriptionProfileResult element from XML. The element to be read is "subscriptionProfileResult", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionProfileResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *xmlTextReaderReadNs0SubscriptionProfileResultElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionProfileResult to XML under element name "subscriptionProfileResult".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionProfileResultElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult);

/**
 * Writes a CisSubscriptionProfileResult to XML under element name "subscriptionProfileResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionProfileResultElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionProfileResult.
 *
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult whose children are to be free.
 */
static void freeNs0SubscriptionProfileResultElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult);

/**
 * Reads a CisSubscriptionProfileResult from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionProfileResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *xmlTextReaderReadNs0CisSubscriptionProfileResultType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionProfileResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionProfileResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult);

/**
 * Frees the elements of a CisSubscriptionProfileResult.
 *
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to free.
 */
static void freeNs0CisSubscriptionProfileResultType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest_H

/**
 *  A request to replace the payment method for an existing subscription with another existing payment method.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * identifying attribute of the subscription.
   */
  xmlChar *merchantSubscriptionId;

  /**
   * identifying attribute of the payment method.
   */
  xmlChar *merchantPaymentMethodId;
};

/**
 * Reads a CisSubscriptionReplacePaymentMethodRequest element from XML. The element to be read is "subscriptionReplacePaymentMethodRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionReplacePaymentMethodRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionReplacePaymentMethodRequest to XML under element name "subscriptionReplacePaymentMethodRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest);

/**
 * Frees a CisSubscriptionReplacePaymentMethodRequest.
 *
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest);

/**
 * Reads a CisSubscriptionReplacePaymentMethodRequest element from XML. The element to be read is "subscriptionReplacePaymentMethodRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionReplacePaymentMethodRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *xmlTextReaderReadNs0SubscriptionReplacePaymentMethodRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionReplacePaymentMethodRequest to XML under element name "subscriptionReplacePaymentMethodRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionReplacePaymentMethodRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest);

/**
 * Writes a CisSubscriptionReplacePaymentMethodRequest to XML under element name "subscriptionReplacePaymentMethodRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionReplacePaymentMethodRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionReplacePaymentMethodRequest.
 *
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest whose children are to be free.
 */
static void freeNs0SubscriptionReplacePaymentMethodRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest);

/**
 * Reads a CisSubscriptionReplacePaymentMethodRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionReplacePaymentMethodRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *xmlTextReaderReadNs0CisSubscriptionReplacePaymentMethodRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionReplacePaymentMethodRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionReplacePaymentMethodRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest);

/**
 * Frees the elements of a CisSubscriptionReplacePaymentMethodRequest.
 *
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to free.
 */
static void freeNs0CisSubscriptionReplacePaymentMethodRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest_H

/**
 *  A payment request to for example authorize or capture an amount.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;
};

/**
 * Reads a CisSubscriptionRequest element from XML. The element to be read is "subscriptionRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionRequest to XML under element name "subscriptionRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest);

/**
 * Frees a CisSubscriptionRequest.
 *
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest);

/**
 * Reads a CisSubscriptionRequest element from XML. The element to be read is "subscriptionRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *xmlTextReaderReadNs0SubscriptionRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionRequest to XML under element name "subscriptionRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest);

/**
 * Writes a CisSubscriptionRequest to XML under element name "subscriptionRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionRequest.
 *
 * @param _cisSubscriptionRequest The CisSubscriptionRequest whose children are to be free.
 */
static void freeNs0SubscriptionRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest);

/**
 * Reads a CisSubscriptionRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *xmlTextReaderReadNs0CisSubscriptionRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest);

/**
 * Frees the elements of a CisSubscriptionRequest.
 *
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to free.
 */
static void freeNs0CisSubscriptionRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest_H

/**
 *  A request to finalize a transactional WebSession based on an issued token.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * the request id of the authorization to capture on.
   */
  xmlChar *authorizationRequestId;

  /**
   * the authorization request token used.
   */
  xmlChar *authorizationRequestToken;
};

/**
 * Reads a CisSubscriptionSessionFinalizeRequest element from XML. The element to be read is "subscriptionSessionFinalization", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionSessionFinalizeRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionSessionFinalizeRequest to XML under element name "subscriptionSessionFinalization".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest);

/**
 * Frees a CisSubscriptionSessionFinalizeRequest.
 *
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest);

/**
 * Reads a CisSubscriptionSessionFinalizeRequest element from XML. The element to be read is "subscriptionSessionFinalization", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionSessionFinalizeRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *xmlTextReaderReadNs0SubscriptionSessionFinalizationElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionSessionFinalizeRequest to XML under element name "subscriptionSessionFinalization".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionSessionFinalizationElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest);

/**
 * Writes a CisSubscriptionSessionFinalizeRequest to XML under element name "subscriptionSessionFinalization".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionSessionFinalizationElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionSessionFinalizeRequest.
 *
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest whose children are to be free.
 */
static void freeNs0SubscriptionSessionFinalizationElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest);

/**
 * Reads a CisSubscriptionSessionFinalizeRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionSessionFinalizeRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *xmlTextReaderReadNs0CisSubscriptionSessionFinalizeRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionSessionFinalizeRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionSessionFinalizeRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest);

/**
 * Frees the elements of a CisSubscriptionSessionFinalizeRequest.
 *
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to free.
 */
static void freeNs0CisSubscriptionSessionFinalizeRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest_H

/**
 *  A payment request to initiate payment session.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * If the service approves the transaction, the customer will be redirected to this URL.
   */
  xmlChar *returnUrl;

  /**
   * If the service cancels the transaction or discovers an error, the customer will be redirected to this URL.
   */
  xmlChar *cancelReturnUrl;

  /**
   * The ipAddress of the client.
   */
  xmlChar *ipAddress;

  /**
   * Identifying attribute of the buyer.
   */
  xmlChar *merchantAccountId;
};

/**
 * Reads a CisSubscriptionSessionInitRequest element from XML. The element to be read is "subscriptionSessionInitRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionSessionInitRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionSessionInitRequest to XML under element name "subscriptionSessionInitRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest);

/**
 * Frees a CisSubscriptionSessionInitRequest.
 *
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest);

/**
 * Reads a CisSubscriptionSessionInitRequest element from XML. The element to be read is "subscriptionSessionInitRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionSessionInitRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *xmlTextReaderReadNs0SubscriptionSessionInitRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionSessionInitRequest to XML under element name "subscriptionSessionInitRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionSessionInitRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest);

/**
 * Writes a CisSubscriptionSessionInitRequest to XML under element name "subscriptionSessionInitRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionSessionInitRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionSessionInitRequest.
 *
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest whose children are to be free.
 */
static void freeNs0SubscriptionSessionInitRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest);

/**
 * Reads a CisSubscriptionSessionInitRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionSessionInitRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *xmlTextReaderReadNs0CisSubscriptionSessionInitRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionSessionInitRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionSessionInitRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest);

/**
 * Frees the elements of a CisSubscriptionSessionInitRequest.
 *
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to free.
 */
static void freeNs0CisSubscriptionSessionInitRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult_H

/**
 *  The result of a payment transaction such as authorizing or capturing.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult {


  /**
   * (no documentation provided)
   */
  xmlChar *clientRefId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorReasonCode;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorStatusCode;

  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  xmlChar *href;

  /**
   * (no documentation provided)
   */
  enum hybris_cis_mock_subscription_web_ns0_cisDecision *decision;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorResponses;

  /**
   * The amount / subscription price .
   */
  xmlChar *amount;

  /**
   * (no documentation provided)
   */
  xmlChar *sessionTransactionToken;

  /**
   * The transaction verification key.
   */
  xmlChar *merchantProductId;
};

/**
 * Reads a CisSubscriptionTransactionResult element from XML. The element to be read is "subscriptionTransactionResult", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionTransactionResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionTransactionResult to XML under element name "subscriptionTransactionResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult);

/**
 * Frees a CisSubscriptionTransactionResult.
 *
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult);

/**
 * Reads a CisSubscriptionTransactionResult element from XML. The element to be read is "subscriptionTransactionResult", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionTransactionResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *xmlTextReaderReadNs0SubscriptionTransactionResultElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionTransactionResult to XML under element name "subscriptionTransactionResult".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionTransactionResultElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult);

/**
 * Writes a CisSubscriptionTransactionResult to XML under element name "subscriptionTransactionResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionTransactionResultElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionTransactionResult.
 *
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult whose children are to be free.
 */
static void freeNs0SubscriptionTransactionResultElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult);

/**
 * Reads a CisSubscriptionTransactionResult from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionTransactionResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *xmlTextReaderReadNs0CisSubscriptionTransactionResultType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionTransactionResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionTransactionResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult);

/**
 * Frees the elements of a CisSubscriptionTransactionResult.
 *
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to free.
 */
static void freeNs0CisSubscriptionTransactionResultType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest_H

/**
 *  Generic request type for subscription updates.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * (no documentation provided)
   */
  xmlChar *effectiveFrom;

  /**
   * (no documentation provided)
   */
  xmlChar *merchantSubscriptionId;

  /**
   * The merchantPaymentMethodId.
   */
  xmlChar *merchantPaymentMethodId;

  /**
   * (no documentation provided)
   */
  int *autoRenewal;

  /**
   * (no documentation provided)
   */
  int *contractDurationExtension;
};

/**
 * Reads a CisSubscriptionUpdateRequest element from XML. The element to be read is "subscriptionUpdateRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpdateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionUpdateRequest to XML under element name "subscriptionUpdateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest);

/**
 * Frees a CisSubscriptionUpdateRequest.
 *
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest);

/**
 * Reads a CisSubscriptionUpdateRequest element from XML. The element to be read is "subscriptionUpdateRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpdateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *xmlTextReaderReadNs0SubscriptionUpdateRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionUpdateRequest to XML under element name "subscriptionUpdateRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionUpdateRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest);

/**
 * Writes a CisSubscriptionUpdateRequest to XML under element name "subscriptionUpdateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionUpdateRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionUpdateRequest.
 *
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest whose children are to be free.
 */
static void freeNs0SubscriptionUpdateRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest);

/**
 * Reads a CisSubscriptionUpdateRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpdateRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *xmlTextReaderReadNs0CisSubscriptionUpdateRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionUpdateRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionUpdateRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest);

/**
 * Frees the elements of a CisSubscriptionUpdateRequest.
 *
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to free.
 */
static void freeNs0CisSubscriptionUpdateRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest_H

/**
 *  Generic request type for subscription upgrades.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest {


  /**
   * Vendor specific parameters which aren't represented in the generic interface.
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *parameters;

  /**
   * Identifying order that subscription related to.
   */
  xmlChar *orderId;

  /**
   * 3 letter ISO 4217 currency code.
   */
  xmlChar *currency;

  /**
   * (no documentation provided)
   */
  struct tm *orderDate;

  /**
   * Identifying attribute of the buyer.
   */
  xmlChar *merchantAccountId;

  /**
   * ID of the payment method.
   */
  xmlChar *merchantPaymentMethodId;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem *subscriptionItem;

  /**
   * (no documentation provided)
   */
  xmlChar *merchantSourceSubscriptionId;

  /**
   * (no documentation provided)
   */
  xmlChar *settlement;

  /**
   * Indicates when the upgrade will be effective.
   */
  xmlChar *effectiveFrom;

  /**
   * Indicates whether it's preview upgrade call or real upgrade.
   */
  int preview;
};

/**
 * Reads a CisSubscriptionUpgradeRequest element from XML. The element to be read is "subscriptionUpgradeRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpgradeRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionUpgradeRequest to XML under element name "subscriptionUpgradeRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest);

/**
 * Frees a CisSubscriptionUpgradeRequest.
 *
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest);

/**
 * Reads a CisSubscriptionUpgradeRequest element from XML. The element to be read is "subscriptionUpgradeRequest", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpgradeRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *xmlTextReaderReadNs0SubscriptionUpgradeRequestElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionUpgradeRequest to XML under element name "subscriptionUpgradeRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionUpgradeRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest);

/**
 * Writes a CisSubscriptionUpgradeRequest to XML under element name "subscriptionUpgradeRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionUpgradeRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionUpgradeRequest.
 *
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest whose children are to be free.
 */
static void freeNs0SubscriptionUpgradeRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest);

/**
 * Reads a CisSubscriptionUpgradeRequest from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpgradeRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *xmlTextReaderReadNs0CisSubscriptionUpgradeRequestType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionUpgradeRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionUpgradeRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest);

/**
 * Frees the elements of a CisSubscriptionUpgradeRequest.
 *
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to free.
 */
static void freeNs0CisSubscriptionUpgradeRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult_H

/**
 *  The result of a subscription upgrade call.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult {


  /**
   * (no documentation provided)
   */
  xmlChar *clientRefId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorId;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorReasonCode;

  /**
   * (no documentation provided)
   */
  xmlChar *vendorStatusCode;

  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  xmlChar *href;

  /**
   * (no documentation provided)
   */
  enum hybris_cis_mock_subscription_web_ns0_cisDecision *decision;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorResponses;

  /**
   * merchant ID of a customer account.
   */
  xmlChar *merchantAccountId;

  /**
   * 3 letter ISO 4217 currency code. Default currency for this profile.
   */
  xmlChar *currency;

  /**
   * Merchant ID of a subscription.
   */
  xmlChar *subscriptionId;

  /**
   * Merchant name of a subscription product.
   */
  xmlChar *subscriptionName;

  /**
   * Merchant description of a subscription product.
   */
  xmlChar *subscriptionDescription;

  /**
   * Merchant ID of a subscription product.
   */
  xmlChar *subscriptionProductId;

  /**
   * Merchant order number containing this subscription product.
   */
  xmlChar *subscriptionOrderId;

  /**
   * Merchant order entry number containing this subscription product.
   */
  xmlChar *subscriptionOrderEntryId;

  /**
   * Billing system id.
   */
  xmlChar *billingSystemId;

  /**
   * Start date of a subscription.
   */
  struct tm *subscriptionStartDate;

  /**
   * End date of a subscription.
   */
  struct tm *subscriptionEndDate;

  /**
   * Status of a subscription.
   */
  xmlChar *subscriptionStatus;

  /**
   * Determines if a subscription is cancellable.
   */
  int *cancellationPossible;

  /**
   * Billing frequency.
   */
  xmlChar *billingFrequency;

  /**
   * Contract duration.
   */
  xmlChar *contractDuration;

  /**
   * When was the subscription order placed originally.
   */
  struct tm *orderDate;

  /**
   * When was the subscription order cancelled.
   */
  struct tm *cancelDate;

  /**
   * Comments about the creation.
   */
  xmlChar *comments;

  /**
   * Copy of the payment method of the corresponding account used by this subscription.
   */
  struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *paymentMethod;

  /**
   * AutoRenewal flag of a subscription.
   */
  int *autoRenewal;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *futureBillings;

  /**
   * Size of the futureBillings array.
   */
  int _sizeof_futureBillings;
};

/**
 * Reads a CisSubscriptionUpgradeResult element from XML. The element to be read is "subscriptionUpgradeResult", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpgradeResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionUpgradeResult to XML under element name "subscriptionUpgradeResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult);

/**
 * Frees a CisSubscriptionUpgradeResult.
 *
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult);

/**
 * Reads a CisSubscriptionUpgradeResult element from XML. The element to be read is "subscriptionUpgradeResult", and
 * it is assumed that the reader is already pointing to the element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpgradeResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *xmlTextReaderReadNs0SubscriptionUpgradeResultElement(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionUpgradeResult to XML under element name "subscriptionUpgradeResult".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionUpgradeResultElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult);

/**
 * Writes a CisSubscriptionUpgradeResult to XML under element name "subscriptionUpgradeResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0SubscriptionUpgradeResultElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult, int writeNamespaces);

/**
 * Frees the children of a CisSubscriptionUpgradeResult.
 *
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult whose children are to be free.
 */
static void freeNs0SubscriptionUpgradeResultElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult);

/**
 * Reads a CisSubscriptionUpgradeResult from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpgradeResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *xmlTextReaderReadNs0CisSubscriptionUpgradeResultType(xmlTextReaderPtr reader);

/**
 * Writes a CisSubscriptionUpgradeResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisSubscriptionUpgradeResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult);

/**
 * Frees the elements of a CisSubscriptionUpgradeResult.
 *
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to free.
 */
static void freeNs0CisSubscriptionUpgradeResultType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisTermsOfService_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisTermsOfService_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService {


  /**
   * (no documentation provided)
   */
  xmlChar *id;

  /**
   * (no documentation provided)
   */
  int billingCycleDay;

  /**
   * (no documentation provided)
   */
  xmlChar *billingPlanName;

  /**
   * (no documentation provided)
   */
  xmlChar *name;

  /**
   * (no documentation provided)
   */
  xmlChar *billingPlanId;

  /**
   * (no documentation provided)
   */
  xmlChar *billingFrequency;

  /**
   * (no documentation provided)
   */
  xmlChar *frequency;

  /**
   * (no documentation provided)
   */
  int number;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *vendorParameters;

  /**
   * (no documentation provided)
   */
  int *cancellable;

  /**
   * (no documentation provided)
   */
  int *autoRenewal;
};

/**
 * Reads a CisTermsOfService from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisTermsOfService, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService *xmlTextReaderReadNs0CisTermsOfServiceType(xmlTextReaderPtr reader);

/**
 * Writes a CisTermsOfService to XML.
 *
 * @param writer The XML writer.
 * @param _cisTermsOfService The CisTermsOfService to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisTermsOfServiceType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService *_cisTermsOfService);

/**
 * Frees the elements of a CisTermsOfService.
 *
 * @param _cisTermsOfService The CisTermsOfService to free.
 */
static void freeNs0CisTermsOfServiceType(struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService *_cisTermsOfService);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisTermsOfService_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisUsageCharge_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisUsageCharge_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge {


  /**
   * (no documentation provided)
   */
  xmlChar *name;

  /**
   * (no documentation provided)
   */
  xmlChar *type;

  /**
   * (no documentation provided)
   */
  xmlChar *unitId;

  /**
   * (no documentation provided)
   */
  struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier *tiers;

  /**
   * Size of the tiers array.
   */
  int _sizeof_tiers;
};

/**
 * Reads a CisUsageCharge from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisUsageCharge, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge *xmlTextReaderReadNs0CisUsageChargeType(xmlTextReaderPtr reader);

/**
 * Writes a CisUsageCharge to XML.
 *
 * @param writer The XML writer.
 * @param _cisUsageCharge The CisUsageCharge to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisUsageChargeType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge *_cisUsageCharge);

/**
 * Frees the elements of a CisUsageCharge.
 *
 * @param _cisUsageCharge The CisUsageCharge to free.
 */
static void freeNs0CisUsageChargeType(struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge *_cisUsageCharge);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisUsageCharge_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier_H
#define DEF_hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier_H

/**
 * (no documentation provided)
 */
struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier {


  /**
   * (no documentation provided)
   */
  int *numberOfUnits;

  /**
   * (no documentation provided)
   */
  xmlChar *chargePrice;
};

/**
 * Reads a CisUsageChargeTier from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisUsageChargeTier, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier *xmlTextReaderReadNs0CisUsageChargeTierType(xmlTextReaderPtr reader);

/**
 * Writes a CisUsageChargeTier to XML.
 *
 * @param writer The XML writer.
 * @param _cisUsageChargeTier The CisUsageChargeTier to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisUsageChargeTierType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier *_cisUsageChargeTier);

/**
 * Frees the elements of a CisUsageChargeTier.
 *
 * @param _cisUsageChargeTier The CisUsageChargeTier to free.
 */
static void freeNs0CisUsageChargeTierType(struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier *_cisUsageChargeTier);

#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier_H */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMap_M
#define DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMap_M

/**
 * Reads a AnnotationHashMap from XML. The reader is assumed to be at the start element.
 *
 * @return the AnnotationHashMap, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *xmlTextReaderReadNs0AnnotationHashMapType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *_annotationHashMap = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_annotationHashMap));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0AnnotationHashMapType(_annotationHashMap);
        free(_annotationHashMap);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "parameter", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}parameter of type {}annotationHashMapEntryType.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapEntryTypeType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}parameter of type {}annotationHashMapEntryType.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0AnnotationHashMapType(_annotationHashMap);
          free(_annotationHashMap);
          return NULL;
        }

        _annotationHashMap->entries = realloc(_annotationHashMap->entries, (_annotationHashMap->_sizeof_entries + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType));
        memcpy(&(_annotationHashMap->entries[_annotationHashMap->_sizeof_entries++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}annotationHashMap.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}annotationHashMap. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _annotationHashMap;
}

/**
 * Writes a AnnotationHashMap to XML.
 *
 * @param writer The XML writer.
 * @param _annotationHashMap The AnnotationHashMap to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0AnnotationHashMapType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *_annotationHashMap) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  for (i = 0; i < _annotationHashMap->_sizeof_entries; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "parameter", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}parameter. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMapEntryType for element {}parameter...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapEntryTypeType(writer, &(_annotationHashMap->entries[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMapEntryType for element {}parameter. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}parameter. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a AnnotationHashMap.
 *
 * @param _annotationHashMap The AnnotationHashMap to free.
 */
static void freeNs0AnnotationHashMapType(struct hybris_cis_mock_subscription_web_ns0_annotationHashMap *_annotationHashMap) {
  int i;
  if (_annotationHashMap->entries != NULL) {
    for (i = 0; i < _annotationHashMap->_sizeof_entries; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor entries[%i] of type hybris_cis_mock_subscription_web_ns0_annotationHashMap...\n", i);
#endif
      freeNs0AnnotationHashMapEntryTypeType(&(_annotationHashMap->entries[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor entries of type hybris_cis_mock_subscription_web_ns0_annotationHashMap...\n");
#endif
    free(_annotationHashMap->entries);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMap_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType_M
#define DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType_M

/**
 * Reads a AnnotationHashMapEntryType from XML. The reader is assumed to be at the start element.
 *
 * @return the AnnotationHashMapEntryType, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType *xmlTextReaderReadNs0AnnotationHashMapEntryTypeType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType *_annotationHashMapEntryType = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "key", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}key...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}key of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0AnnotationHashMapEntryTypeType(_annotationHashMapEntryType);
          free(_annotationHashMapEntryType);
          return NULL;
        }
        _annotationHashMapEntryType->key = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "value", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}value...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}value of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0AnnotationHashMapEntryTypeType(_annotationHashMapEntryType);
          free(_annotationHashMapEntryType);
          return NULL;
        }
        _annotationHashMapEntryType->value = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0AnnotationHashMapEntryTypeType(_annotationHashMapEntryType);
      free(_annotationHashMapEntryType);
      return NULL;
    }
  }



  return _annotationHashMapEntryType;
}

/**
 * Writes a AnnotationHashMapEntryType to XML.
 *
 * @param writer The XML writer.
 * @param _annotationHashMapEntryType The AnnotationHashMapEntryType to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0AnnotationHashMapEntryTypeType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType *_annotationHashMapEntryType) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_annotationHashMapEntryType->key != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "key", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}key. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}key...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_annotationHashMapEntryType->key));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}key. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}key. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_annotationHashMapEntryType->value != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "value", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}value. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}value...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_annotationHashMapEntryType->value));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}value. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}value. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a AnnotationHashMapEntryType.
 *
 * @param _annotationHashMapEntryType The AnnotationHashMapEntryType to free.
 */
static void freeNs0AnnotationHashMapEntryTypeType(struct hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType *_annotationHashMapEntryType) {
  int i;
  if (_annotationHashMapEntryType->key != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor key of type hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType...\n");
#endif
    freeXsStringType(_annotationHashMapEntryType->key);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor key of type hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType...\n");
#endif
    free(_annotationHashMapEntryType->key);
  }
  if (_annotationHashMapEntryType->value != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor value of type hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType...\n");
#endif
    freeXsStringType(_annotationHashMapEntryType->value);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor value of type hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType...\n");
#endif
    free(_annotationHashMapEntryType->value);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_annotationHashMapEntryType_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisAddress_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisAddress_M

/**
 * Reads a CisAddress element from XML. The element to be read is "address", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisAddress, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisAddress *xml_read_hybris_cis_mock_subscription_web_ns0_cisAddress(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0AddressElement(reader);
}

/**
 * Writes a CisAddress to XML under element name "address".
 *
 * @param writer The XML writer.
 * @param _cisAddress The CisAddress to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisAddress(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress) {
  return xmlTextWriterWriteNs0AddressElementNS(writer, _cisAddress, 1);
}

/**
 * Frees a CisAddress.
 *
 * @param _cisAddress The CisAddress to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisAddress(struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress) {
  freeNs0CisAddressType(_cisAddress);
  free(_cisAddress);
}

/**
 * Reads a CisAddress element from XML. The element to be read is "address", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisAddress, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisAddress *xmlTextReaderReadNs0AddressElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "address", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}address.\n");
#endif
    _cisAddress = xmlTextReaderReadNs0CisAddressType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisAddress == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}address failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}address failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisAddress;
}

/**
 * Writes a CisAddress to XML under element name "address".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisAddress The CisAddress to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0AddressElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress) {
  return xmlTextWriterWriteNs0AddressElementNS(writer, _cisAddress, 0);
}

/**
 * Writes a CisAddress to XML under element name "address".
 *
 * @param writer The XML writer.
 * @param _cisAddress The CisAddress to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0AddressElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "address", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}address. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisAddress for root element {}address...\n");
#endif
  status = xmlTextWriterWriteNs0CisAddressType(writer, _cisAddress);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}address. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}address. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisAddress.
 *
 * @param _cisAddress The CisAddress whose children are to be free.
 */
static void freeNs0AddressElement(struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress) {
  freeNs0CisAddressType(_cisAddress);
}

/**
 * Reads a CisAddress from XML. The reader is assumed to be at the start element.
 *
 * @return the CisAddress, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisAddress *xmlTextReaderReadNs0CisAddressType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisAddress));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisAddressType(_cisAddress);
        free(_cisAddress);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "type", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}type of type {}cisAddressType.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisAddressTypeType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}type of type {}cisAddressType.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->type = ((enum hybris_cis_mock_subscription_web_ns0_cisAddressType*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "title", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}title of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}title of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->title = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "firstName", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}firstName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}firstName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->firstName = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "lastName", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}lastName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}lastName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->lastName = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "email", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}email of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}email of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->email = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "addressLine1", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}addressLine1 of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}addressLine1 of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->addressLine1 = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "addressLine2", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}addressLine2 of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}addressLine2 of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->addressLine2 = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "addressLine3", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}addressLine3 of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}addressLine3 of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->addressLine3 = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "addressLine4", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}addressLine4 of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}addressLine4 of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->addressLine4 = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "zipCode", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}zipCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}zipCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->zipCode = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "city", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}city of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}city of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->city = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "state", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}state of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}state of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->state = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "country", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}country of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}country of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->country = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "phone", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}phone of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}phone of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->phone = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "company", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}company of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}company of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->company = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "longitude", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}longitude of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}longitude of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->longitude = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "latitude", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}latitude of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}latitude of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->latitude = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "facilityType", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}facilityType of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}facilityType of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->facilityType = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "facilityName", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}facilityName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}facilityName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->facilityName = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "faxNumber", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}faxNumber of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}faxNumber of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->faxNumber = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisAddressType(_cisAddress);
          free(_cisAddress);
          return NULL;
        }

        _cisAddress->vendorParameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisAddress.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisAddress. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisAddress;
}

/**
 * Writes a CisAddress to XML.
 *
 * @param writer The XML writer.
 * @param _cisAddress The CisAddress to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisAddressType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisAddress->type != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "type", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}type. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisAddressType for element {}type...\n");
#endif
    status = xmlTextWriterWriteNs0CisAddressTypeType(writer, (_cisAddress->type));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisAddressType for element {}type. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}type. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->title != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "title", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}title. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}title...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->title));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}title. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}title. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->firstName != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "firstName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}firstName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}firstName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->firstName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}firstName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}firstName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->lastName != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "lastName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}lastName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}lastName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->lastName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}lastName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}lastName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->email != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "email", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}email. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}email...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->email));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}email. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}email. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->addressLine1 != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "addressLine1", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}addressLine1. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}addressLine1...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->addressLine1));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}addressLine1. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}addressLine1. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->addressLine2 != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "addressLine2", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}addressLine2. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}addressLine2...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->addressLine2));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}addressLine2. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}addressLine2. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->addressLine3 != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "addressLine3", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}addressLine3. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}addressLine3...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->addressLine3));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}addressLine3. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}addressLine3. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->addressLine4 != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "addressLine4", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}addressLine4. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}addressLine4...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->addressLine4));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}addressLine4. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}addressLine4. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->zipCode != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "zipCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}zipCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}zipCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->zipCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}zipCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}zipCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->city != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "city", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}city. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}city...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->city));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}city. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}city. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->state != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "state", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}state. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}state...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->state));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}state. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}state. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->country != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "country", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}country. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}country...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->country));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}country. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}country. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->phone != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "phone", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}phone. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}phone...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->phone));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}phone. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}phone. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->company != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "company", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}company. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}company...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->company));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}company. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}company. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->longitude != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "longitude", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}longitude. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}longitude...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->longitude));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}longitude. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}longitude. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->latitude != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "latitude", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}latitude. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}latitude...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->latitude));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}latitude. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}latitude. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->facilityType != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "facilityType", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}facilityType. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}facilityType...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->facilityType));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}facilityType. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}facilityType. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->facilityName != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "facilityName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}facilityName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}facilityName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->facilityName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}facilityName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}facilityName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->faxNumber != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "faxNumber", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}faxNumber. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}faxNumber...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisAddress->faxNumber));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}faxNumber. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}faxNumber. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisAddress->vendorParameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisAddress->vendorParameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisAddress.
 *
 * @param _cisAddress The CisAddress to free.
 */
static void freeNs0CisAddressType(struct hybris_cis_mock_subscription_web_ns0_cisAddress *_cisAddress) {
  int i;
  if (_cisAddress->type != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor type of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeNs0CisAddressTypeType(_cisAddress->type);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor type of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->type);
  }
  if (_cisAddress->title != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor title of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->title);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor title of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->title);
  }
  if (_cisAddress->firstName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor firstName of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->firstName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor firstName of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->firstName);
  }
  if (_cisAddress->lastName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor lastName of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->lastName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor lastName of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->lastName);
  }
  if (_cisAddress->email != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor email of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->email);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor email of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->email);
  }
  if (_cisAddress->addressLine1 != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor addressLine1 of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->addressLine1);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor addressLine1 of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->addressLine1);
  }
  if (_cisAddress->addressLine2 != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor addressLine2 of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->addressLine2);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor addressLine2 of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->addressLine2);
  }
  if (_cisAddress->addressLine3 != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor addressLine3 of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->addressLine3);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor addressLine3 of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->addressLine3);
  }
  if (_cisAddress->addressLine4 != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor addressLine4 of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->addressLine4);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor addressLine4 of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->addressLine4);
  }
  if (_cisAddress->zipCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor zipCode of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->zipCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor zipCode of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->zipCode);
  }
  if (_cisAddress->city != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor city of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->city);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor city of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->city);
  }
  if (_cisAddress->state != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor state of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->state);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor state of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->state);
  }
  if (_cisAddress->country != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor country of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->country);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor country of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->country);
  }
  if (_cisAddress->phone != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor phone of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->phone);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor phone of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->phone);
  }
  if (_cisAddress->company != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor company of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->company);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor company of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->company);
  }
  if (_cisAddress->longitude != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor longitude of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->longitude);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor longitude of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->longitude);
  }
  if (_cisAddress->latitude != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor latitude of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->latitude);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor latitude of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->latitude);
  }
  if (_cisAddress->facilityType != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor facilityType of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->facilityType);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor facilityType of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->facilityType);
  }
  if (_cisAddress->facilityName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor facilityName of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->facilityName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor facilityName of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->facilityName);
  }
  if (_cisAddress->faxNumber != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor faxNumber of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeXsStringType(_cisAddress->faxNumber);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor faxNumber of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->faxNumber);
  }
  if (_cisAddress->vendorParameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    freeNs0AnnotationHashMapType(_cisAddress->vendorParameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisAddress...\n");
#endif
    free(_cisAddress->vendorParameters);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisAddress_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisAddressType_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisAddressType_M

/**
 * Reads a CisAddressType from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisAddressType, or NULL if unable to be read.
 */
static enum hybris_cis_mock_subscription_web_ns0_cisAddressType *xmlTextReaderReadNs0CisAddressTypeType(xmlTextReaderPtr reader) {
  xmlChar *enumValue = xmlTextReaderReadEntireNodeValue(reader);
  enum hybris_cis_mock_subscription_web_ns0_cisAddressType *value = calloc(1, sizeof(enum hybris_cis_mock_subscription_web_ns0_cisAddressType));
  if (enumValue != NULL) {
    if (xmlStrcmp(enumValue, BAD_CAST "SHIP_TO") == 0) {
      *value = HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_SHIP_TO;
      free(enumValue);
      return value;
    }
    if (xmlStrcmp(enumValue, BAD_CAST "SHIP_FROM") == 0) {
      *value = HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_SHIP_FROM;
      free(enumValue);
      return value;
    }
    if (xmlStrcmp(enumValue, BAD_CAST "BILL_TO") == 0) {
      *value = HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_BILL_TO;
      free(enumValue);
      return value;
    }
    if (xmlStrcmp(enumValue, BAD_CAST "ADMIN_ORIGIN") == 0) {
      *value = HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_ADMIN_ORIGIN;
      free(enumValue);
      return value;
    }
#if DEBUG_ENUNCIATE
    printf("Attempt to read enum value failed: %s doesn't match an enum value.\n", enumValue);
#endif
  }
#if DEBUG_ENUNCIATE
  else {
    printf("Attempt to read enum value failed: NULL value.\n");
  }
#endif

  return NULL;
}

/**
 * Writes a CisAddressType to XML.
 *
 * @param writer The XML writer.
 * @param _cisAddressType The CisAddressType to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisAddressTypeType(xmlTextWriterPtr writer, enum hybris_cis_mock_subscription_web_ns0_cisAddressType *_cisAddressType) {
  switch (*_cisAddressType) {
    case HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_SHIP_TO:
      return xmlTextWriterWriteString(writer, BAD_CAST "SHIP_TO");
    case HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_SHIP_FROM:
      return xmlTextWriterWriteString(writer, BAD_CAST "SHIP_FROM");
    case HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_BILL_TO:
      return xmlTextWriterWriteString(writer, BAD_CAST "BILL_TO");
    case HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISADDRESSTYPE_ADMIN_ORIGIN:
      return xmlTextWriterWriteString(writer, BAD_CAST "ADMIN_ORIGIN");
  }

#if DEBUG_ENUNCIATE
  printf("Unable to write enum value (no valid value found).\n");
#endif
  return -1;
}

/**
 * Frees a CisAddressType.
 *
 * @param _cisAddressType The CisAddressType to free.
 */
static void freeNs0CisAddressTypeType(enum hybris_cis_mock_subscription_web_ns0_cisAddressType *_cisAddressType) {
  //no-op
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisAddressType_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisDecision_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisDecision_M

/**
 * Reads a CisDecision from XML. The reader is assumed to be at the start element.
 *
 * @param reader The XML reader.
 * @return The CisDecision, or NULL if unable to be read.
 */
static enum hybris_cis_mock_subscription_web_ns0_cisDecision *xmlTextReaderReadNs0CisDecisionType(xmlTextReaderPtr reader) {
  xmlChar *enumValue = xmlTextReaderReadEntireNodeValue(reader);
  enum hybris_cis_mock_subscription_web_ns0_cisDecision *value = calloc(1, sizeof(enum hybris_cis_mock_subscription_web_ns0_cisDecision));
  if (enumValue != NULL) {
    if (xmlStrcmp(enumValue, BAD_CAST "ACCEPT") == 0) {
      *value = HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_ACCEPT;
      free(enumValue);
      return value;
    }
    if (xmlStrcmp(enumValue, BAD_CAST "REVIEW") == 0) {
      *value = HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_REVIEW;
      free(enumValue);
      return value;
    }
    if (xmlStrcmp(enumValue, BAD_CAST "REJECT") == 0) {
      *value = HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_REJECT;
      free(enumValue);
      return value;
    }
    if (xmlStrcmp(enumValue, BAD_CAST "ERROR") == 0) {
      *value = HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_ERROR;
      free(enumValue);
      return value;
    }
#if DEBUG_ENUNCIATE
    printf("Attempt to read enum value failed: %s doesn't match an enum value.\n", enumValue);
#endif
  }
#if DEBUG_ENUNCIATE
  else {
    printf("Attempt to read enum value failed: NULL value.\n");
  }
#endif

  return NULL;
}

/**
 * Writes a CisDecision to XML.
 *
 * @param writer The XML writer.
 * @param _cisDecision The CisDecision to write.
 * @return The bytes written (may be 0 in case of buffering) or -1 in case of error.
 */
static int xmlTextWriterWriteNs0CisDecisionType(xmlTextWriterPtr writer, enum hybris_cis_mock_subscription_web_ns0_cisDecision *_cisDecision) {
  switch (*_cisDecision) {
    case HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_ACCEPT:
      return xmlTextWriterWriteString(writer, BAD_CAST "ACCEPT");
    case HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_REVIEW:
      return xmlTextWriterWriteString(writer, BAD_CAST "REVIEW");
    case HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_REJECT:
      return xmlTextWriterWriteString(writer, BAD_CAST "REJECT");
    case HYBRIS_CIS_MOCK_SUBSCRIPTION_WEB_NS0_CISDECISION_ERROR:
      return xmlTextWriterWriteString(writer, BAD_CAST "ERROR");
  }

#if DEBUG_ENUNCIATE
  printf("Unable to write enum value (no valid value found).\n");
#endif
  return -1;
}

/**
 * Frees a CisDecision.
 *
 * @param _cisDecision The CisDecision to free.
 */
static void freeNs0CisDecisionType(enum hybris_cis_mock_subscription_web_ns0_cisDecision *_cisDecision) {
  //no-op
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisDecision_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisLineItem_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisLineItem_M

/**
 * Reads a CisLineItem from XML. The reader is assumed to be at the start element.
 *
 * @return the CisLineItem, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisLineItem *xmlTextReaderReadNs0CisLineItemType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisLineItem *_cisLineItem = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisLineItem));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}int from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          freeNs0CisLineItemType(_cisLineItem);
          free(_cisLineItem);
          return NULL;
        }
        _cisLineItem->id = ((int*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisLineItemType(_cisLineItem);
      free(_cisLineItem);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisLineItemType(_cisLineItem);
        free(_cisLineItem);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "itemCode", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}itemCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}itemCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisLineItemType(_cisLineItem);
          free(_cisLineItem);
          return NULL;
        }

        _cisLineItem->itemCode = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "quantity", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}quantity of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}quantity of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisLineItemType(_cisLineItem);
          free(_cisLineItem);
          return NULL;
        }

        _cisLineItem->quantity = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "productDescription", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}productDescription of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}productDescription of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisLineItemType(_cisLineItem);
          free(_cisLineItem);
          return NULL;
        }

        _cisLineItem->productDescription = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "unitPrice", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}unitPrice of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDecimalType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}unitPrice of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisLineItemType(_cisLineItem);
          free(_cisLineItem);
          return NULL;
        }

        _cisLineItem->unitPrice = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "taxCode", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}taxCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}taxCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisLineItemType(_cisLineItem);
          free(_cisLineItem);
          return NULL;
        }

        _cisLineItem->taxCode = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisLineItemType(_cisLineItem);
          free(_cisLineItem);
          return NULL;
        }

        _cisLineItem->vendorParameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisLineItem.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisLineItem. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisLineItem;
}

/**
 * Writes a CisLineItem to XML.
 *
 * @param writer The XML writer.
 * @param _cisLineItem The CisLineItem to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisLineItemType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisLineItem *_cisLineItem) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisLineItem->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsIntType(writer, (_cisLineItem->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisLineItem->itemCode != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "itemCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}itemCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}itemCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisLineItem->itemCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}itemCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}itemCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisLineItem->quantity != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "quantity", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}quantity. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}quantity...\n");
#endif
    status = xmlTextWriterWriteXsIntType(writer, (_cisLineItem->quantity));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}quantity. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}quantity. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisLineItem->productDescription != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "productDescription", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}productDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}productDescription...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisLineItem->productDescription));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}productDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}productDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisLineItem->unitPrice != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "unitPrice", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}unitPrice. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}decimal for element {}unitPrice...\n");
#endif
    status = xmlTextWriterWriteXsDecimalType(writer, (_cisLineItem->unitPrice));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}decimal for element {}unitPrice. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}unitPrice. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisLineItem->taxCode != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "taxCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}taxCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}taxCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisLineItem->taxCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}taxCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}taxCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisLineItem->vendorParameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisLineItem->vendorParameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisLineItem.
 *
 * @param _cisLineItem The CisLineItem to free.
 */
static void freeNs0CisLineItemType(struct hybris_cis_mock_subscription_web_ns0_cisLineItem *_cisLineItem) {
  int i;
  if (_cisLineItem->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    freeXsIntType(_cisLineItem->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    free(_cisLineItem->id);
  }
  if (_cisLineItem->itemCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor itemCode of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    freeXsStringType(_cisLineItem->itemCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor itemCode of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    free(_cisLineItem->itemCode);
  }
  if (_cisLineItem->quantity != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor quantity of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    freeXsIntType(_cisLineItem->quantity);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor quantity of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    free(_cisLineItem->quantity);
  }
  if (_cisLineItem->productDescription != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor productDescription of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    freeXsStringType(_cisLineItem->productDescription);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor productDescription of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    free(_cisLineItem->productDescription);
  }
  if (_cisLineItem->unitPrice != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor unitPrice of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    freeXsDecimalType(_cisLineItem->unitPrice);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor unitPrice of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    free(_cisLineItem->unitPrice);
  }
  if (_cisLineItem->taxCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor taxCode of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    freeXsStringType(_cisLineItem->taxCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor taxCode of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    free(_cisLineItem->taxCode);
  }
  if (_cisLineItem->vendorParameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    freeNs0AnnotationHashMapType(_cisLineItem->vendorParameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisLineItem...\n");
#endif
    free(_cisLineItem->vendorParameters);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisLineItem_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisResult_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisResult_M

/**
 * Reads a CisResult from XML. The reader is assumed to be at the start element.
 *
 * @return the CisResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisResult *xmlTextReaderReadNs0CisResultType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisResult *_cisResult = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisResult));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "clientRefId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}clientRefId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}clientRefId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisResultType(_cisResult);
          free(_cisResult);
          return NULL;
        }
        _cisResult->clientRefId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisResultType(_cisResult);
          free(_cisResult);
          return NULL;
        }
        _cisResult->vendorId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorReasonCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorReasonCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorReasonCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisResultType(_cisResult);
          free(_cisResult);
          return NULL;
        }
        _cisResult->vendorReasonCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorStatusCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorStatusCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorStatusCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisResultType(_cisResult);
          free(_cisResult);
          return NULL;
        }
        _cisResult->vendorStatusCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisResultType(_cisResult);
          free(_cisResult);
          return NULL;
        }
        _cisResult->id = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "href", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}href...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}href of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisResultType(_cisResult);
          free(_cisResult);
          return NULL;
        }
        _cisResult->href = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisResultType(_cisResult);
      free(_cisResult);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisResultType(_cisResult);
        free(_cisResult);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "decision", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}decision of type {}cisDecision.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisDecisionType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}decision of type {}cisDecision.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisResultType(_cisResult);
          free(_cisResult);
          return NULL;
        }

        _cisResult->decision = ((enum hybris_cis_mock_subscription_web_ns0_cisDecision*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorResponses", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisResultType(_cisResult);
          free(_cisResult);
          return NULL;
        }

        _cisResult->vendorResponses = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisResult.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisResult. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisResult;
}

/**
 * Writes a CisResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisResult The CisResult to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisResult *_cisResult) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisResult->clientRefId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "clientRefId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}clientRefId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisResult->clientRefId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisResult->vendorId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisResult->vendorId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisResult->vendorReasonCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorReasonCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorReasonCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisResult->vendorReasonCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisResult->vendorStatusCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorStatusCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorStatusCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisResult->vendorStatusCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisResult->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisResult->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisResult->href != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "href", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}href. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}href...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisResult->href));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisResult->decision != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "decision", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisDecision for element {}decision...\n");
#endif
    status = xmlTextWriterWriteNs0CisDecisionType(writer, (_cisResult->decision));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisDecision for element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisResult->vendorResponses != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorResponses", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorResponses...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisResult->vendorResponses));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisResult.
 *
 * @param _cisResult The CisResult to free.
 */
static void freeNs0CisResultType(struct hybris_cis_mock_subscription_web_ns0_cisResult *_cisResult) {
  int i;
  if (_cisResult->clientRefId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    freeXsStringType(_cisResult->clientRefId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    free(_cisResult->clientRefId);
  }
  if (_cisResult->vendorId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    freeXsStringType(_cisResult->vendorId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    free(_cisResult->vendorId);
  }
  if (_cisResult->vendorReasonCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    freeXsStringType(_cisResult->vendorReasonCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    free(_cisResult->vendorReasonCode);
  }
  if (_cisResult->vendorStatusCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    freeXsStringType(_cisResult->vendorStatusCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    free(_cisResult->vendorStatusCode);
  }
  if (_cisResult->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    freeXsStringType(_cisResult->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    free(_cisResult->id);
  }
  if (_cisResult->href != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor href of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    freeXsStringType(_cisResult->href);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor href of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    free(_cisResult->href);
  }
  if (_cisResult->decision != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor decision of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    freeNs0CisDecisionType(_cisResult->decision);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor decision of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    free(_cisResult->decision);
  }
  if (_cisResult->vendorResponses != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    freeNs0AnnotationHashMapType(_cisResult->vendorResponses);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisResult...\n");
#endif
    free(_cisResult->vendorResponses);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisResult_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest_M

/**
 * Reads a CisChangePaymentMethodRequest element from XML. The element to be read is "subscriptionChangePaymentMethodRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisChangePaymentMethodRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionChangePaymentMethodRequestElement(reader);
}

/**
 * Writes a CisChangePaymentMethodRequest to XML under element name "subscriptionChangePaymentMethodRequest".
 *
 * @param writer The XML writer.
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest) {
  return xmlTextWriterWriteNs0SubscriptionChangePaymentMethodRequestElementNS(writer, _cisChangePaymentMethodRequest, 1);
}

/**
 * Frees a CisChangePaymentMethodRequest.
 *
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest(struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest) {
  freeNs0CisChangePaymentMethodRequestType(_cisChangePaymentMethodRequest);
  free(_cisChangePaymentMethodRequest);
}

/**
 * Reads a CisChangePaymentMethodRequest element from XML. The element to be read is "subscriptionChangePaymentMethodRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisChangePaymentMethodRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *xmlTextReaderReadNs0SubscriptionChangePaymentMethodRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionChangePaymentMethodRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionChangePaymentMethodRequest.\n");
#endif
    _cisChangePaymentMethodRequest = xmlTextReaderReadNs0CisChangePaymentMethodRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisChangePaymentMethodRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionChangePaymentMethodRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionChangePaymentMethodRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisChangePaymentMethodRequest;
}

/**
 * Writes a CisChangePaymentMethodRequest to XML under element name "subscriptionChangePaymentMethodRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionChangePaymentMethodRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest) {
  return xmlTextWriterWriteNs0SubscriptionChangePaymentMethodRequestElementNS(writer, _cisChangePaymentMethodRequest, 0);
}

/**
 * Writes a CisChangePaymentMethodRequest to XML under element name "subscriptionChangePaymentMethodRequest".
 *
 * @param writer The XML writer.
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionChangePaymentMethodRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionChangePaymentMethodRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionChangePaymentMethodRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisChangePaymentMethodRequest for root element {}subscriptionChangePaymentMethodRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisChangePaymentMethodRequestType(writer, _cisChangePaymentMethodRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionChangePaymentMethodRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionChangePaymentMethodRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisChangePaymentMethodRequest.
 *
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest whose children are to be free.
 */
static void freeNs0SubscriptionChangePaymentMethodRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest) {
  freeNs0CisChangePaymentMethodRequestType(_cisChangePaymentMethodRequest);
}

/**
 * Reads a CisChangePaymentMethodRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisChangePaymentMethodRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *xmlTextReaderReadNs0CisChangePaymentMethodRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisChangePaymentMethodRequestType(_cisChangePaymentMethodRequest);
        free(_cisChangePaymentMethodRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisChangePaymentMethodRequestType(_cisChangePaymentMethodRequest);
          free(_cisChangePaymentMethodRequest);
          return NULL;
        }

        _cisChangePaymentMethodRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantPaymentMethodId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisChangePaymentMethodRequestType(_cisChangePaymentMethodRequest);
          free(_cisChangePaymentMethodRequest);
          return NULL;
        }

        _cisChangePaymentMethodRequest->merchantPaymentMethodId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "action", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}action of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}action of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisChangePaymentMethodRequestType(_cisChangePaymentMethodRequest);
          free(_cisChangePaymentMethodRequest);
          return NULL;
        }

        _cisChangePaymentMethodRequest->action = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "newValue", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}newValue of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}newValue of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisChangePaymentMethodRequestType(_cisChangePaymentMethodRequest);
          free(_cisChangePaymentMethodRequest);
          return NULL;
        }

        _cisChangePaymentMethodRequest->newValue = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "propagate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}propagate of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}propagate of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisChangePaymentMethodRequestType(_cisChangePaymentMethodRequest);
          free(_cisChangePaymentMethodRequest);
          return NULL;
        }

        _cisChangePaymentMethodRequest->propagate = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisChangePaymentMethodRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisChangePaymentMethodRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisChangePaymentMethodRequest;
}

/**
 * Writes a CisChangePaymentMethodRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisChangePaymentMethodRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisChangePaymentMethodRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisChangePaymentMethodRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisChangePaymentMethodRequest->merchantPaymentMethodId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantPaymentMethodId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisChangePaymentMethodRequest->merchantPaymentMethodId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisChangePaymentMethodRequest->action != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "action", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}action. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}action...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisChangePaymentMethodRequest->action));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}action. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}action. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisChangePaymentMethodRequest->newValue != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "newValue", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}newValue. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}newValue...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisChangePaymentMethodRequest->newValue));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}newValue. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}newValue. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "propagate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}propagate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}propagate...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_cisChangePaymentMethodRequest->propagate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}propagate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}propagate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisChangePaymentMethodRequest.
 *
 * @param _cisChangePaymentMethodRequest The CisChangePaymentMethodRequest to free.
 */
static void freeNs0CisChangePaymentMethodRequestType(struct hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest *_cisChangePaymentMethodRequest) {
  int i;
  if (_cisChangePaymentMethodRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisChangePaymentMethodRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest...\n");
#endif
    free(_cisChangePaymentMethodRequest->parameters);
  }
  if (_cisChangePaymentMethodRequest->merchantPaymentMethodId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest...\n");
#endif
    freeXsStringType(_cisChangePaymentMethodRequest->merchantPaymentMethodId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest...\n");
#endif
    free(_cisChangePaymentMethodRequest->merchantPaymentMethodId);
  }
  if (_cisChangePaymentMethodRequest->action != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor action of type hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest...\n");
#endif
    freeXsStringType(_cisChangePaymentMethodRequest->action);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor action of type hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest...\n");
#endif
    free(_cisChangePaymentMethodRequest->action);
  }
  if (_cisChangePaymentMethodRequest->newValue != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor newValue of type hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest...\n");
#endif
    freeXsStringType(_cisChangePaymentMethodRequest->newValue);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor newValue of type hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest...\n");
#endif
    free(_cisChangePaymentMethodRequest->newValue);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisChangePaymentMethodRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisChargeEntry_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisChargeEntry_M

/**
 * Reads a CisChargeEntry from XML. The reader is assumed to be at the start element.
 *
 * @return the CisChargeEntry, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry *xmlTextReaderReadNs0CisChargeEntryType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry *_cisChargeEntry = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisChargeEntryType(_cisChargeEntry);
        free(_cisChargeEntry);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "oneTimeChargeTime", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}oneTimeChargeTime of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}oneTimeChargeTime of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisChargeEntryType(_cisChargeEntry);
          free(_cisChargeEntry);
          return NULL;
        }

        _cisChargeEntry->oneTimeChargeTime = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "chargePrice", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}chargePrice of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDecimalType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}chargePrice of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisChargeEntryType(_cisChargeEntry);
          free(_cisChargeEntry);
          return NULL;
        }

        _cisChargeEntry->chargePrice = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisChargeEntryType(_cisChargeEntry);
          free(_cisChargeEntry);
          return NULL;
        }

        _cisChargeEntry->vendorParameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "numberOfCycles", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}numberOfCycles of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}numberOfCycles of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisChargeEntryType(_cisChargeEntry);
          free(_cisChargeEntry);
          return NULL;
        }

        _cisChargeEntry->numberOfCycles = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisChargeEntry.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisChargeEntry. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisChargeEntry;
}

/**
 * Writes a CisChargeEntry to XML.
 *
 * @param writer The XML writer.
 * @param _cisChargeEntry The CisChargeEntry to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisChargeEntryType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry *_cisChargeEntry) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisChargeEntry->oneTimeChargeTime != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "oneTimeChargeTime", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}oneTimeChargeTime. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}oneTimeChargeTime...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisChargeEntry->oneTimeChargeTime));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}oneTimeChargeTime. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}oneTimeChargeTime. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisChargeEntry->chargePrice != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "chargePrice", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}chargePrice. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}decimal for element {}chargePrice...\n");
#endif
    status = xmlTextWriterWriteXsDecimalType(writer, (_cisChargeEntry->chargePrice));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}decimal for element {}chargePrice. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}chargePrice. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisChargeEntry->vendorParameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisChargeEntry->vendorParameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisChargeEntry->numberOfCycles != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "numberOfCycles", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}numberOfCycles. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}numberOfCycles...\n");
#endif
    status = xmlTextWriterWriteXsIntType(writer, (_cisChargeEntry->numberOfCycles));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}numberOfCycles. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}numberOfCycles. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisChargeEntry.
 *
 * @param _cisChargeEntry The CisChargeEntry to free.
 */
static void freeNs0CisChargeEntryType(struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry *_cisChargeEntry) {
  int i;
  if (_cisChargeEntry->oneTimeChargeTime != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor oneTimeChargeTime of type hybris_cis_mock_subscription_web_ns0_cisChargeEntry...\n");
#endif
    freeXsStringType(_cisChargeEntry->oneTimeChargeTime);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor oneTimeChargeTime of type hybris_cis_mock_subscription_web_ns0_cisChargeEntry...\n");
#endif
    free(_cisChargeEntry->oneTimeChargeTime);
  }
  if (_cisChargeEntry->chargePrice != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor chargePrice of type hybris_cis_mock_subscription_web_ns0_cisChargeEntry...\n");
#endif
    freeXsDecimalType(_cisChargeEntry->chargePrice);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor chargePrice of type hybris_cis_mock_subscription_web_ns0_cisChargeEntry...\n");
#endif
    free(_cisChargeEntry->chargePrice);
  }
  if (_cisChargeEntry->vendorParameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisChargeEntry...\n");
#endif
    freeNs0AnnotationHashMapType(_cisChargeEntry->vendorParameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisChargeEntry...\n");
#endif
    free(_cisChargeEntry->vendorParameters);
  }
  if (_cisChargeEntry->numberOfCycles != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor numberOfCycles of type hybris_cis_mock_subscription_web_ns0_cisChargeEntry...\n");
#endif
    freeXsIntType(_cisChargeEntry->numberOfCycles);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor numberOfCycles of type hybris_cis_mock_subscription_web_ns0_cisChargeEntry...\n");
#endif
    free(_cisChargeEntry->numberOfCycles);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisChargeEntry_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest_M

/**
 * Reads a CisCustomerUsageRequest element from XML. The element to be read is "customerUsageRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisCustomerUsageRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0CustomerUsageRequestElement(reader);
}

/**
 * Writes a CisCustomerUsageRequest to XML under element name "customerUsageRequest".
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest) {
  return xmlTextWriterWriteNs0CustomerUsageRequestElementNS(writer, _cisCustomerUsageRequest, 1);
}

/**
 * Frees a CisCustomerUsageRequest.
 *
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest) {
  freeNs0CisCustomerUsageRequestType(_cisCustomerUsageRequest);
  free(_cisCustomerUsageRequest);
}

/**
 * Reads a CisCustomerUsageRequest element from XML. The element to be read is "customerUsageRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisCustomerUsageRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *xmlTextReaderReadNs0CustomerUsageRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "customerUsageRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}customerUsageRequest.\n");
#endif
    _cisCustomerUsageRequest = xmlTextReaderReadNs0CisCustomerUsageRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisCustomerUsageRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}customerUsageRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}customerUsageRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisCustomerUsageRequest;
}

/**
 * Writes a CisCustomerUsageRequest to XML under element name "customerUsageRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0CustomerUsageRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest) {
  return xmlTextWriterWriteNs0CustomerUsageRequestElementNS(writer, _cisCustomerUsageRequest, 0);
}

/**
 * Writes a CisCustomerUsageRequest to XML under element name "customerUsageRequest".
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0CustomerUsageRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "customerUsageRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}customerUsageRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisCustomerUsageRequest for root element {}customerUsageRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisCustomerUsageRequestType(writer, _cisCustomerUsageRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}customerUsageRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}customerUsageRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisCustomerUsageRequest.
 *
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest whose children are to be free.
 */
static void freeNs0CustomerUsageRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest) {
  freeNs0CisCustomerUsageRequestType(_cisCustomerUsageRequest);
}

/**
 * Reads a CisCustomerUsageRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisCustomerUsageRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *xmlTextReaderReadNs0CisCustomerUsageRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisCustomerUsageRequestType(_cisCustomerUsageRequest);
        free(_cisCustomerUsageRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "fromDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}fromDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateTimeType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}fromDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisCustomerUsageRequestType(_cisCustomerUsageRequest);
          free(_cisCustomerUsageRequest);
          return NULL;
        }

        _cisCustomerUsageRequest->fromDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "toDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}toDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateTimeType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}toDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisCustomerUsageRequestType(_cisCustomerUsageRequest);
          free(_cisCustomerUsageRequest);
          return NULL;
        }

        _cisCustomerUsageRequest->toDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "customerId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}customerId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}customerId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisCustomerUsageRequestType(_cisCustomerUsageRequest);
          free(_cisCustomerUsageRequest);
          return NULL;
        }

        _cisCustomerUsageRequest->customerId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisCustomerUsageRequestType(_cisCustomerUsageRequest);
          free(_cisCustomerUsageRequest);
          return NULL;
        }

        _cisCustomerUsageRequest->subscriptionId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "usageChargeName", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}usageChargeName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}usageChargeName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisCustomerUsageRequestType(_cisCustomerUsageRequest);
          free(_cisCustomerUsageRequest);
          return NULL;
        }

        _cisCustomerUsageRequest->usageChargeName = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "unitsConsumed", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}unitsConsumed of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDecimalType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}unitsConsumed of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisCustomerUsageRequestType(_cisCustomerUsageRequest);
          free(_cisCustomerUsageRequest);
          return NULL;
        }

        _cisCustomerUsageRequest->unitsConsumed = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisCustomerUsageRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisCustomerUsageRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisCustomerUsageRequest;
}

/**
 * Writes a CisCustomerUsageRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisCustomerUsageRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisCustomerUsageRequest->fromDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "fromDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}fromDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}dateTime for element {}fromDate...\n");
#endif
    status = xmlTextWriterWriteXsDateTimeType(writer, (_cisCustomerUsageRequest->fromDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}dateTime for element {}fromDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}fromDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisCustomerUsageRequest->toDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "toDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}toDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}dateTime for element {}toDate...\n");
#endif
    status = xmlTextWriterWriteXsDateTimeType(writer, (_cisCustomerUsageRequest->toDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}dateTime for element {}toDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}toDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisCustomerUsageRequest->customerId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "customerId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}customerId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}customerId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisCustomerUsageRequest->customerId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}customerId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}customerId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisCustomerUsageRequest->subscriptionId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisCustomerUsageRequest->subscriptionId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisCustomerUsageRequest->usageChargeName != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "usageChargeName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}usageChargeName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}usageChargeName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisCustomerUsageRequest->usageChargeName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}usageChargeName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}usageChargeName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisCustomerUsageRequest->unitsConsumed != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "unitsConsumed", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}unitsConsumed. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}decimal for element {}unitsConsumed...\n");
#endif
    status = xmlTextWriterWriteXsDecimalType(writer, (_cisCustomerUsageRequest->unitsConsumed));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}decimal for element {}unitsConsumed. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}unitsConsumed. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisCustomerUsageRequest.
 *
 * @param _cisCustomerUsageRequest The CisCustomerUsageRequest to free.
 */
static void freeNs0CisCustomerUsageRequestType(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest *_cisCustomerUsageRequest) {
  int i;
  if (_cisCustomerUsageRequest->fromDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor fromDate of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    freeXsDateTimeType(_cisCustomerUsageRequest->fromDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor fromDate of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    free(_cisCustomerUsageRequest->fromDate);
  }
  if (_cisCustomerUsageRequest->toDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor toDate of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    freeXsDateTimeType(_cisCustomerUsageRequest->toDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor toDate of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    free(_cisCustomerUsageRequest->toDate);
  }
  if (_cisCustomerUsageRequest->customerId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor customerId of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    freeXsStringType(_cisCustomerUsageRequest->customerId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor customerId of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    free(_cisCustomerUsageRequest->customerId);
  }
  if (_cisCustomerUsageRequest->subscriptionId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionId of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    freeXsStringType(_cisCustomerUsageRequest->subscriptionId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionId of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    free(_cisCustomerUsageRequest->subscriptionId);
  }
  if (_cisCustomerUsageRequest->usageChargeName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor usageChargeName of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    freeXsStringType(_cisCustomerUsageRequest->usageChargeName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor usageChargeName of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    free(_cisCustomerUsageRequest->usageChargeName);
  }
  if (_cisCustomerUsageRequest->unitsConsumed != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor unitsConsumed of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    freeXsDecimalType(_cisCustomerUsageRequest->unitsConsumed);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor unitsConsumed of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest...\n");
#endif
    free(_cisCustomerUsageRequest->unitsConsumed);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult_M

/**
 * Reads a CisCustomerUsageResult element from XML. The element to be read is "customerUsage", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisCustomerUsageResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0CustomerUsageElement(reader);
}

/**
 * Writes a CisCustomerUsageResult to XML under element name "customerUsage".
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult) {
  return xmlTextWriterWriteNs0CustomerUsageElementNS(writer, _cisCustomerUsageResult, 1);
}

/**
 * Frees a CisCustomerUsageResult.
 *
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult) {
  freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
  free(_cisCustomerUsageResult);
}

/**
 * Reads a CisCustomerUsageResult element from XML. The element to be read is "customerUsage", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisCustomerUsageResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *xmlTextReaderReadNs0CustomerUsageElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "customerUsage", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}customerUsage.\n");
#endif
    _cisCustomerUsageResult = xmlTextReaderReadNs0CisCustomerUsageResultType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisCustomerUsageResult == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}customerUsage failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}customerUsage failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisCustomerUsageResult;
}

/**
 * Writes a CisCustomerUsageResult to XML under element name "customerUsage".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0CustomerUsageElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult) {
  return xmlTextWriterWriteNs0CustomerUsageElementNS(writer, _cisCustomerUsageResult, 0);
}

/**
 * Writes a CisCustomerUsageResult to XML under element name "customerUsage".
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0CustomerUsageElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "customerUsage", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}customerUsage. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisCustomerUsageResult for root element {}customerUsage...\n");
#endif
  status = xmlTextWriterWriteNs0CisCustomerUsageResultType(writer, _cisCustomerUsageResult);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}customerUsage. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}customerUsage. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisCustomerUsageResult.
 *
 * @param _cisCustomerUsageResult The CisCustomerUsageResult whose children are to be free.
 */
static void freeNs0CustomerUsageElement(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult) {
  freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
}

/**
 * Reads a CisCustomerUsageResult from XML. The reader is assumed to be at the start element.
 *
 * @return the CisCustomerUsageResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *xmlTextReaderReadNs0CisCustomerUsageResultType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "clientRefId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}clientRefId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}clientRefId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
          free(_cisCustomerUsageResult);
          return NULL;
        }
        _cisCustomerUsageResult->clientRefId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
          free(_cisCustomerUsageResult);
          return NULL;
        }
        _cisCustomerUsageResult->vendorId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorReasonCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorReasonCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorReasonCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
          free(_cisCustomerUsageResult);
          return NULL;
        }
        _cisCustomerUsageResult->vendorReasonCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorStatusCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorStatusCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorStatusCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
          free(_cisCustomerUsageResult);
          return NULL;
        }
        _cisCustomerUsageResult->vendorStatusCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
          free(_cisCustomerUsageResult);
          return NULL;
        }
        _cisCustomerUsageResult->id = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "href", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}href...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}href of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
          free(_cisCustomerUsageResult);
          return NULL;
        }
        _cisCustomerUsageResult->href = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
      free(_cisCustomerUsageResult);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
        free(_cisCustomerUsageResult);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "decision", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}decision of type {}cisDecision.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisDecisionType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}decision of type {}cisDecision.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
          free(_cisCustomerUsageResult);
          return NULL;
        }

        _cisCustomerUsageResult->decision = ((enum hybris_cis_mock_subscription_web_ns0_cisDecision*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorResponses", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisCustomerUsageResultType(_cisCustomerUsageResult);
          free(_cisCustomerUsageResult);
          return NULL;
        }

        _cisCustomerUsageResult->vendorResponses = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisCustomerUsageResult.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisCustomerUsageResult. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisCustomerUsageResult;
}

/**
 * Writes a CisCustomerUsageResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisCustomerUsageResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisCustomerUsageResult->clientRefId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "clientRefId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}clientRefId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisCustomerUsageResult->clientRefId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisCustomerUsageResult->vendorId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisCustomerUsageResult->vendorId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisCustomerUsageResult->vendorReasonCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorReasonCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorReasonCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisCustomerUsageResult->vendorReasonCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisCustomerUsageResult->vendorStatusCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorStatusCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorStatusCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisCustomerUsageResult->vendorStatusCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisCustomerUsageResult->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisCustomerUsageResult->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisCustomerUsageResult->href != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "href", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}href. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}href...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisCustomerUsageResult->href));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisCustomerUsageResult->decision != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "decision", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisDecision for element {}decision...\n");
#endif
    status = xmlTextWriterWriteNs0CisDecisionType(writer, (_cisCustomerUsageResult->decision));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisDecision for element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisCustomerUsageResult->vendorResponses != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorResponses", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorResponses...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisCustomerUsageResult->vendorResponses));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisCustomerUsageResult.
 *
 * @param _cisCustomerUsageResult The CisCustomerUsageResult to free.
 */
static void freeNs0CisCustomerUsageResultType(struct hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult *_cisCustomerUsageResult) {
  int i;
  if (_cisCustomerUsageResult->clientRefId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    freeXsStringType(_cisCustomerUsageResult->clientRefId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    free(_cisCustomerUsageResult->clientRefId);
  }
  if (_cisCustomerUsageResult->vendorId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    freeXsStringType(_cisCustomerUsageResult->vendorId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    free(_cisCustomerUsageResult->vendorId);
  }
  if (_cisCustomerUsageResult->vendorReasonCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    freeXsStringType(_cisCustomerUsageResult->vendorReasonCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    free(_cisCustomerUsageResult->vendorReasonCode);
  }
  if (_cisCustomerUsageResult->vendorStatusCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    freeXsStringType(_cisCustomerUsageResult->vendorStatusCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    free(_cisCustomerUsageResult->vendorStatusCode);
  }
  if (_cisCustomerUsageResult->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    freeXsStringType(_cisCustomerUsageResult->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    free(_cisCustomerUsageResult->id);
  }
  if (_cisCustomerUsageResult->href != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor href of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    freeXsStringType(_cisCustomerUsageResult->href);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor href of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    free(_cisCustomerUsageResult->href);
  }
  if (_cisCustomerUsageResult->decision != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor decision of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    freeNs0CisDecisionType(_cisCustomerUsageResult->decision);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor decision of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    free(_cisCustomerUsageResult->decision);
  }
  if (_cisCustomerUsageResult->vendorResponses != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    freeNs0AnnotationHashMapType(_cisCustomerUsageResult->vendorResponses);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult...\n");
#endif
    free(_cisCustomerUsageResult->vendorResponses);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisCustomerUsageResult_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult_M

/**
 * Reads a CisFileStreamResult element from XML. The element to be read is "fileStream", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisFileStreamResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0FileStreamElement(reader);
}

/**
 * Writes a CisFileStreamResult to XML under element name "fileStream".
 *
 * @param writer The XML writer.
 * @param _cisFileStreamResult The CisFileStreamResult to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult) {
  return xmlTextWriterWriteNs0FileStreamElementNS(writer, _cisFileStreamResult, 1);
}

/**
 * Frees a CisFileStreamResult.
 *
 * @param _cisFileStreamResult The CisFileStreamResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult(struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult) {
  freeNs0CisFileStreamResultType(_cisFileStreamResult);
  free(_cisFileStreamResult);
}

/**
 * Reads a CisFileStreamResult element from XML. The element to be read is "fileStream", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisFileStreamResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *xmlTextReaderReadNs0FileStreamElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "fileStream", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}fileStream.\n");
#endif
    _cisFileStreamResult = xmlTextReaderReadNs0CisFileStreamResultType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisFileStreamResult == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}fileStream failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}fileStream failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisFileStreamResult;
}

/**
 * Writes a CisFileStreamResult to XML under element name "fileStream".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisFileStreamResult The CisFileStreamResult to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0FileStreamElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult) {
  return xmlTextWriterWriteNs0FileStreamElementNS(writer, _cisFileStreamResult, 0);
}

/**
 * Writes a CisFileStreamResult to XML under element name "fileStream".
 *
 * @param writer The XML writer.
 * @param _cisFileStreamResult The CisFileStreamResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0FileStreamElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "fileStream", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}fileStream. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisFileStreamResult for root element {}fileStream...\n");
#endif
  status = xmlTextWriterWriteNs0CisFileStreamResultType(writer, _cisFileStreamResult);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}fileStream. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}fileStream. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisFileStreamResult.
 *
 * @param _cisFileStreamResult The CisFileStreamResult whose children are to be free.
 */
static void freeNs0FileStreamElement(struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult) {
  freeNs0CisFileStreamResultType(_cisFileStreamResult);
}

/**
 * Reads a CisFileStreamResult from XML. The reader is assumed to be at the start element.
 *
 * @return the CisFileStreamResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *xmlTextReaderReadNs0CisFileStreamResultType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "clientRefId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}clientRefId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}clientRefId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisFileStreamResultType(_cisFileStreamResult);
          free(_cisFileStreamResult);
          return NULL;
        }
        _cisFileStreamResult->clientRefId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisFileStreamResultType(_cisFileStreamResult);
          free(_cisFileStreamResult);
          return NULL;
        }
        _cisFileStreamResult->vendorId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorReasonCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorReasonCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorReasonCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisFileStreamResultType(_cisFileStreamResult);
          free(_cisFileStreamResult);
          return NULL;
        }
        _cisFileStreamResult->vendorReasonCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorStatusCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorStatusCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorStatusCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisFileStreamResultType(_cisFileStreamResult);
          free(_cisFileStreamResult);
          return NULL;
        }
        _cisFileStreamResult->vendorStatusCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisFileStreamResultType(_cisFileStreamResult);
          free(_cisFileStreamResult);
          return NULL;
        }
        _cisFileStreamResult->id = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "href", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}href...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}href of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisFileStreamResultType(_cisFileStreamResult);
          free(_cisFileStreamResult);
          return NULL;
        }
        _cisFileStreamResult->href = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisFileStreamResultType(_cisFileStreamResult);
      free(_cisFileStreamResult);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisFileStreamResultType(_cisFileStreamResult);
        free(_cisFileStreamResult);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "decision", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}decision of type {}cisDecision.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisDecisionType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}decision of type {}cisDecision.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisFileStreamResultType(_cisFileStreamResult);
          free(_cisFileStreamResult);
          return NULL;
        }

        _cisFileStreamResult->decision = ((enum hybris_cis_mock_subscription_web_ns0_cisDecision*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorResponses", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisFileStreamResultType(_cisFileStreamResult);
          free(_cisFileStreamResult);
          return NULL;
        }

        _cisFileStreamResult->vendorResponses = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "bytes", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read binary data of choice {}bytes.\n");
#endif
        _child_accessor = xmlTextReaderReadEntireNodeValue(reader);
        _cisFileStreamResult->bytes = _decode_base64((xmlChar *) _child_accessor, &(_cisFileStreamResult->_sizeof_bytes));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "mimeType", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}mimeType of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}mimeType of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisFileStreamResultType(_cisFileStreamResult);
          free(_cisFileStreamResult);
          return NULL;
        }

        _cisFileStreamResult->mimeType = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "fileName", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}fileName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}fileName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisFileStreamResultType(_cisFileStreamResult);
          free(_cisFileStreamResult);
          return NULL;
        }

        _cisFileStreamResult->fileName = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisFileStreamResult.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisFileStreamResult. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisFileStreamResult;
}

/**
 * Writes a CisFileStreamResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisFileStreamResult The CisFileStreamResult to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisFileStreamResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisFileStreamResult->clientRefId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "clientRefId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}clientRefId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisFileStreamResult->clientRefId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisFileStreamResult->vendorId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisFileStreamResult->vendorId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisFileStreamResult->vendorReasonCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorReasonCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorReasonCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisFileStreamResult->vendorReasonCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisFileStreamResult->vendorStatusCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorStatusCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorStatusCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisFileStreamResult->vendorStatusCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisFileStreamResult->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisFileStreamResult->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisFileStreamResult->href != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "href", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}href. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}href...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisFileStreamResult->href));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisFileStreamResult->decision != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "decision", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisDecision for element {}decision...\n");
#endif
    status = xmlTextWriterWriteNs0CisDecisionType(writer, (_cisFileStreamResult->decision));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisDecision for element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisFileStreamResult->vendorResponses != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorResponses", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorResponses...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisFileStreamResult->vendorResponses));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisFileStreamResult->bytes != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "bytes", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}bytes. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing binary data for element {}bytes...\n");
#endif
    binaryData = _encode_base64(_cisFileStreamResult->bytes, _cisFileStreamResult->_sizeof_bytes);
    status = xmlTextWriterWriteString(writer, binaryData);
    free(binaryData);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write binary data for element {}bytes. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}bytes. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisFileStreamResult->mimeType != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "mimeType", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}mimeType. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}mimeType...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisFileStreamResult->mimeType));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}mimeType. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}mimeType. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisFileStreamResult->fileName != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "fileName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}fileName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}fileName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisFileStreamResult->fileName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}fileName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}fileName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisFileStreamResult.
 *
 * @param _cisFileStreamResult The CisFileStreamResult to free.
 */
static void freeNs0CisFileStreamResultType(struct hybris_cis_mock_subscription_web_ns0_cisFileStreamResult *_cisFileStreamResult) {
  int i;
  if (_cisFileStreamResult->clientRefId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    freeXsStringType(_cisFileStreamResult->clientRefId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->clientRefId);
  }
  if (_cisFileStreamResult->vendorId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    freeXsStringType(_cisFileStreamResult->vendorId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->vendorId);
  }
  if (_cisFileStreamResult->vendorReasonCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    freeXsStringType(_cisFileStreamResult->vendorReasonCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->vendorReasonCode);
  }
  if (_cisFileStreamResult->vendorStatusCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    freeXsStringType(_cisFileStreamResult->vendorStatusCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->vendorStatusCode);
  }
  if (_cisFileStreamResult->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    freeXsStringType(_cisFileStreamResult->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->id);
  }
  if (_cisFileStreamResult->href != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor href of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    freeXsStringType(_cisFileStreamResult->href);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor href of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->href);
  }
  if (_cisFileStreamResult->decision != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor decision of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    freeNs0CisDecisionType(_cisFileStreamResult->decision);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor decision of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->decision);
  }
  if (_cisFileStreamResult->vendorResponses != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    freeNs0AnnotationHashMapType(_cisFileStreamResult->vendorResponses);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->vendorResponses);
  }
  if (_cisFileStreamResult->bytes != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor bytes of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->bytes);
  }
  if (_cisFileStreamResult->mimeType != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor mimeType of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    freeXsStringType(_cisFileStreamResult->mimeType);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor mimeType of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->mimeType);
  }
  if (_cisFileStreamResult->fileName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor fileName of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    freeXsStringType(_cisFileStreamResult->fileName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor fileName of type hybris_cis_mock_subscription_web_ns0_cisFileStreamResult...\n");
#endif
    free(_cisFileStreamResult->fileName);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisFileStreamResult_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethod_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethod_M

/**
 * Reads a CisPaymentMethod from XML. The reader is assumed to be at the start element.
 *
 * @return the CisPaymentMethod, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *xmlTextReaderReadNs0CisPaymentMethodType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *_cisPaymentMethod = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisPaymentMethodType(_cisPaymentMethod);
        free(_cisPaymentMethod);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "ccNumber", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}ccNumber of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}ccNumber of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodType(_cisPaymentMethod);
          free(_cisPaymentMethod);
          return NULL;
        }

        _cisPaymentMethod->ccNumber = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "enabled", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}enabled of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}enabled of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodType(_cisPaymentMethod);
          free(_cisPaymentMethod);
          return NULL;
        }

        _cisPaymentMethod->enabled = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "expirationMonth", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}expirationMonth of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}expirationMonth of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodType(_cisPaymentMethod);
          free(_cisPaymentMethod);
          return NULL;
        }

        _cisPaymentMethod->expirationMonth = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingAddress", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingAddress of type {}cisAddress.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisAddressType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingAddress of type {}cisAddress.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodType(_cisPaymentMethod);
          free(_cisPaymentMethod);
          return NULL;
        }

        _cisPaymentMethod->billingAddress = ((struct hybris_cis_mock_subscription_web_ns0_cisAddress*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "expirationYear", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}expirationYear of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}expirationYear of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodType(_cisPaymentMethod);
          free(_cisPaymentMethod);
          return NULL;
        }

        _cisPaymentMethod->expirationYear = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantPaymentMethodId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodType(_cisPaymentMethod);
          free(_cisPaymentMethod);
          return NULL;
        }

        _cisPaymentMethod->merchantPaymentMethodId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "cardHolder", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}cardHolder of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}cardHolder of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodType(_cisPaymentMethod);
          free(_cisPaymentMethod);
          return NULL;
        }

        _cisPaymentMethod->cardHolder = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "cardType", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}cardType of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}cardType of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodType(_cisPaymentMethod);
          free(_cisPaymentMethod);
          return NULL;
        }

        _cisPaymentMethod->cardType = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisPaymentMethod.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisPaymentMethod. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisPaymentMethod;
}

/**
 * Writes a CisPaymentMethod to XML.
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethod The CisPaymentMethod to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisPaymentMethodType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *_cisPaymentMethod) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisPaymentMethod->ccNumber != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "ccNumber", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}ccNumber. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}ccNumber...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethod->ccNumber));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}ccNumber. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}ccNumber. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "enabled", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}enabled. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}enabled...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_cisPaymentMethod->enabled));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}enabled. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}enabled. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "expirationMonth", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}expirationMonth. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}expirationMonth...\n");
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_cisPaymentMethod->expirationMonth));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}expirationMonth. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}expirationMonth. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethod->billingAddress != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingAddress", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisAddress for element {}billingAddress...\n");
#endif
    status = xmlTextWriterWriteNs0CisAddressType(writer, (_cisPaymentMethod->billingAddress));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisAddress for element {}billingAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "expirationYear", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}expirationYear. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}expirationYear...\n");
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_cisPaymentMethod->expirationYear));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}expirationYear. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}expirationYear. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethod->merchantPaymentMethodId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantPaymentMethodId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethod->merchantPaymentMethodId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethod->cardHolder != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "cardHolder", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}cardHolder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}cardHolder...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethod->cardHolder));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}cardHolder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}cardHolder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethod->cardType != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "cardType", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}cardType. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}cardType...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethod->cardType));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}cardType. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}cardType. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisPaymentMethod.
 *
 * @param _cisPaymentMethod The CisPaymentMethod to free.
 */
static void freeNs0CisPaymentMethodType(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod *_cisPaymentMethod) {
  int i;
  if (_cisPaymentMethod->ccNumber != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor ccNumber of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethod...\n");
#endif
    freeXsStringType(_cisPaymentMethod->ccNumber);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor ccNumber of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethod...\n");
#endif
    free(_cisPaymentMethod->ccNumber);
  }
  if (_cisPaymentMethod->billingAddress != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingAddress of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethod...\n");
#endif
    freeNs0CisAddressType(_cisPaymentMethod->billingAddress);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingAddress of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethod...\n");
#endif
    free(_cisPaymentMethod->billingAddress);
  }
  if (_cisPaymentMethod->merchantPaymentMethodId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethod...\n");
#endif
    freeXsStringType(_cisPaymentMethod->merchantPaymentMethodId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethod...\n");
#endif
    free(_cisPaymentMethod->merchantPaymentMethodId);
  }
  if (_cisPaymentMethod->cardHolder != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor cardHolder of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethod...\n");
#endif
    freeXsStringType(_cisPaymentMethod->cardHolder);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor cardHolder of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethod...\n");
#endif
    free(_cisPaymentMethod->cardHolder);
  }
  if (_cisPaymentMethod->cardType != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor cardType of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethod...\n");
#endif
    freeXsStringType(_cisPaymentMethod->cardType);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor cardType of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethod...\n");
#endif
    free(_cisPaymentMethod->cardType);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethod_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult_M

/**
 * Reads a CisPaymentMethodResult element from XML. The element to be read is "paymentMethodResult", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethodResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0PaymentMethodResultElement(reader);
}

/**
 * Writes a CisPaymentMethodResult to XML under element name "paymentMethodResult".
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult) {
  return xmlTextWriterWriteNs0PaymentMethodResultElementNS(writer, _cisPaymentMethodResult, 1);
}

/**
 * Frees a CisPaymentMethodResult.
 *
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult) {
  freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
  free(_cisPaymentMethodResult);
}

/**
 * Reads a CisPaymentMethodResult element from XML. The element to be read is "paymentMethodResult", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethodResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *xmlTextReaderReadNs0PaymentMethodResultElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "paymentMethodResult", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}paymentMethodResult.\n");
#endif
    _cisPaymentMethodResult = xmlTextReaderReadNs0CisPaymentMethodResultType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisPaymentMethodResult == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}paymentMethodResult failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}paymentMethodResult failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisPaymentMethodResult;
}

/**
 * Writes a CisPaymentMethodResult to XML under element name "paymentMethodResult".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0PaymentMethodResultElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult) {
  return xmlTextWriterWriteNs0PaymentMethodResultElementNS(writer, _cisPaymentMethodResult, 0);
}

/**
 * Writes a CisPaymentMethodResult to XML under element name "paymentMethodResult".
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0PaymentMethodResultElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "paymentMethodResult", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}paymentMethodResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisPaymentMethodResult for root element {}paymentMethodResult...\n");
#endif
  status = xmlTextWriterWriteNs0CisPaymentMethodResultType(writer, _cisPaymentMethodResult);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}paymentMethodResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}paymentMethodResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisPaymentMethodResult.
 *
 * @param _cisPaymentMethodResult The CisPaymentMethodResult whose children are to be free.
 */
static void freeNs0PaymentMethodResultElement(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult) {
  freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
}

/**
 * Reads a CisPaymentMethodResult from XML. The reader is assumed to be at the start element.
 *
 * @return the CisPaymentMethodResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *xmlTextReaderReadNs0CisPaymentMethodResultType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "clientRefId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}clientRefId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}clientRefId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
          free(_cisPaymentMethodResult);
          return NULL;
        }
        _cisPaymentMethodResult->clientRefId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
          free(_cisPaymentMethodResult);
          return NULL;
        }
        _cisPaymentMethodResult->vendorId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorReasonCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorReasonCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorReasonCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
          free(_cisPaymentMethodResult);
          return NULL;
        }
        _cisPaymentMethodResult->vendorReasonCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorStatusCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorStatusCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorStatusCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
          free(_cisPaymentMethodResult);
          return NULL;
        }
        _cisPaymentMethodResult->vendorStatusCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
          free(_cisPaymentMethodResult);
          return NULL;
        }
        _cisPaymentMethodResult->id = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "href", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}href...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}href of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
          free(_cisPaymentMethodResult);
          return NULL;
        }
        _cisPaymentMethodResult->href = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
      free(_cisPaymentMethodResult);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
        free(_cisPaymentMethodResult);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "decision", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}decision of type {}cisDecision.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisDecisionType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}decision of type {}cisDecision.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
          free(_cisPaymentMethodResult);
          return NULL;
        }

        _cisPaymentMethodResult->decision = ((enum hybris_cis_mock_subscription_web_ns0_cisDecision*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorResponses", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
          free(_cisPaymentMethodResult);
          return NULL;
        }

        _cisPaymentMethodResult->vendorResponses = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "paymentMethod", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}paymentMethod of type {}cisPaymentMethod.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisPaymentMethodType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}paymentMethod of type {}cisPaymentMethod.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodResultType(_cisPaymentMethodResult);
          free(_cisPaymentMethodResult);
          return NULL;
        }

        _cisPaymentMethodResult->paymentMethod = ((struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisPaymentMethodResult.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisPaymentMethodResult. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisPaymentMethodResult;
}

/**
 * Writes a CisPaymentMethodResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisPaymentMethodResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisPaymentMethodResult->clientRefId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "clientRefId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}clientRefId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethodResult->clientRefId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisPaymentMethodResult->vendorId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethodResult->vendorId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisPaymentMethodResult->vendorReasonCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorReasonCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorReasonCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethodResult->vendorReasonCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisPaymentMethodResult->vendorStatusCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorStatusCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorStatusCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethodResult->vendorStatusCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisPaymentMethodResult->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethodResult->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisPaymentMethodResult->href != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "href", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}href. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}href...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethodResult->href));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethodResult->decision != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "decision", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisDecision for element {}decision...\n");
#endif
    status = xmlTextWriterWriteNs0CisDecisionType(writer, (_cisPaymentMethodResult->decision));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisDecision for element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethodResult->vendorResponses != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorResponses", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorResponses...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisPaymentMethodResult->vendorResponses));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethodResult->paymentMethod != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "paymentMethod", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisPaymentMethod for element {}paymentMethod...\n");
#endif
    status = xmlTextWriterWriteNs0CisPaymentMethodType(writer, (_cisPaymentMethodResult->paymentMethod));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisPaymentMethod for element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisPaymentMethodResult.
 *
 * @param _cisPaymentMethodResult The CisPaymentMethodResult to free.
 */
static void freeNs0CisPaymentMethodResultType(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult *_cisPaymentMethodResult) {
  int i;
  if (_cisPaymentMethodResult->clientRefId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    freeXsStringType(_cisPaymentMethodResult->clientRefId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    free(_cisPaymentMethodResult->clientRefId);
  }
  if (_cisPaymentMethodResult->vendorId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    freeXsStringType(_cisPaymentMethodResult->vendorId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    free(_cisPaymentMethodResult->vendorId);
  }
  if (_cisPaymentMethodResult->vendorReasonCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    freeXsStringType(_cisPaymentMethodResult->vendorReasonCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    free(_cisPaymentMethodResult->vendorReasonCode);
  }
  if (_cisPaymentMethodResult->vendorStatusCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    freeXsStringType(_cisPaymentMethodResult->vendorStatusCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    free(_cisPaymentMethodResult->vendorStatusCode);
  }
  if (_cisPaymentMethodResult->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    freeXsStringType(_cisPaymentMethodResult->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    free(_cisPaymentMethodResult->id);
  }
  if (_cisPaymentMethodResult->href != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor href of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    freeXsStringType(_cisPaymentMethodResult->href);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor href of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    free(_cisPaymentMethodResult->href);
  }
  if (_cisPaymentMethodResult->decision != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor decision of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    freeNs0CisDecisionType(_cisPaymentMethodResult->decision);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor decision of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    free(_cisPaymentMethodResult->decision);
  }
  if (_cisPaymentMethodResult->vendorResponses != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    freeNs0AnnotationHashMapType(_cisPaymentMethodResult->vendorResponses);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    free(_cisPaymentMethodResult->vendorResponses);
  }
  if (_cisPaymentMethodResult->paymentMethod != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor paymentMethod of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    freeNs0CisPaymentMethodType(_cisPaymentMethodResult->paymentMethod);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor paymentMethod of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult...\n");
#endif
    free(_cisPaymentMethodResult->paymentMethod);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodResult_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest_M

/**
 * Reads a CisPaymentMethodUpdateRequest element from XML. The element to be read is "paymentMethodUpdateRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethodUpdateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0PaymentMethodUpdateRequestElement(reader);
}

/**
 * Writes a CisPaymentMethodUpdateRequest to XML under element name "paymentMethodUpdateRequest".
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest) {
  return xmlTextWriterWriteNs0PaymentMethodUpdateRequestElementNS(writer, _cisPaymentMethodUpdateRequest, 1);
}

/**
 * Frees a CisPaymentMethodUpdateRequest.
 *
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest) {
  freeNs0CisPaymentMethodUpdateRequestType(_cisPaymentMethodUpdateRequest);
  free(_cisPaymentMethodUpdateRequest);
}

/**
 * Reads a CisPaymentMethodUpdateRequest element from XML. The element to be read is "paymentMethodUpdateRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisPaymentMethodUpdateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *xmlTextReaderReadNs0PaymentMethodUpdateRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "paymentMethodUpdateRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}paymentMethodUpdateRequest.\n");
#endif
    _cisPaymentMethodUpdateRequest = xmlTextReaderReadNs0CisPaymentMethodUpdateRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisPaymentMethodUpdateRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}paymentMethodUpdateRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}paymentMethodUpdateRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisPaymentMethodUpdateRequest;
}

/**
 * Writes a CisPaymentMethodUpdateRequest to XML under element name "paymentMethodUpdateRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0PaymentMethodUpdateRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest) {
  return xmlTextWriterWriteNs0PaymentMethodUpdateRequestElementNS(writer, _cisPaymentMethodUpdateRequest, 0);
}

/**
 * Writes a CisPaymentMethodUpdateRequest to XML under element name "paymentMethodUpdateRequest".
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0PaymentMethodUpdateRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "paymentMethodUpdateRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}paymentMethodUpdateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisPaymentMethodUpdateRequest for root element {}paymentMethodUpdateRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisPaymentMethodUpdateRequestType(writer, _cisPaymentMethodUpdateRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}paymentMethodUpdateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}paymentMethodUpdateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisPaymentMethodUpdateRequest.
 *
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest whose children are to be free.
 */
static void freeNs0PaymentMethodUpdateRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest) {
  freeNs0CisPaymentMethodUpdateRequestType(_cisPaymentMethodUpdateRequest);
}

/**
 * Reads a CisPaymentMethodUpdateRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisPaymentMethodUpdateRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *xmlTextReaderReadNs0CisPaymentMethodUpdateRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisPaymentMethodUpdateRequestType(_cisPaymentMethodUpdateRequest);
        free(_cisPaymentMethodUpdateRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodUpdateRequestType(_cisPaymentMethodUpdateRequest);
          free(_cisPaymentMethodUpdateRequest);
          return NULL;
        }

        _cisPaymentMethodUpdateRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantPaymentMethodId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodUpdateRequestType(_cisPaymentMethodUpdateRequest);
          free(_cisPaymentMethodUpdateRequest);
          return NULL;
        }

        _cisPaymentMethodUpdateRequest->merchantPaymentMethodId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "enabled", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}enabled of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}enabled of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodUpdateRequestType(_cisPaymentMethodUpdateRequest);
          free(_cisPaymentMethodUpdateRequest);
          return NULL;
        }

        _cisPaymentMethodUpdateRequest->enabled = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingAddress", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingAddress of type {}cisAddress.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisAddressType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingAddress of type {}cisAddress.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodUpdateRequestType(_cisPaymentMethodUpdateRequest);
          free(_cisPaymentMethodUpdateRequest);
          return NULL;
        }

        _cisPaymentMethodUpdateRequest->billingAddress = ((struct hybris_cis_mock_subscription_web_ns0_cisAddress*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "propagate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}propagate of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}propagate of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisPaymentMethodUpdateRequestType(_cisPaymentMethodUpdateRequest);
          free(_cisPaymentMethodUpdateRequest);
          return NULL;
        }

        _cisPaymentMethodUpdateRequest->propagate = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisPaymentMethodUpdateRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisPaymentMethodUpdateRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisPaymentMethodUpdateRequest;
}

/**
 * Writes a CisPaymentMethodUpdateRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisPaymentMethodUpdateRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisPaymentMethodUpdateRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisPaymentMethodUpdateRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethodUpdateRequest->merchantPaymentMethodId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantPaymentMethodId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisPaymentMethodUpdateRequest->merchantPaymentMethodId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethodUpdateRequest->enabled != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "enabled", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}enabled. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}enabled...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, (_cisPaymentMethodUpdateRequest->enabled));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}enabled. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}enabled. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethodUpdateRequest->billingAddress != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingAddress", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisAddress for element {}billingAddress...\n");
#endif
    status = xmlTextWriterWriteNs0CisAddressType(writer, (_cisPaymentMethodUpdateRequest->billingAddress));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisAddress for element {}billingAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisPaymentMethodUpdateRequest->propagate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "propagate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}propagate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}propagate...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, (_cisPaymentMethodUpdateRequest->propagate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}propagate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}propagate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisPaymentMethodUpdateRequest.
 *
 * @param _cisPaymentMethodUpdateRequest The CisPaymentMethodUpdateRequest to free.
 */
static void freeNs0CisPaymentMethodUpdateRequestType(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest *_cisPaymentMethodUpdateRequest) {
  int i;
  if (_cisPaymentMethodUpdateRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisPaymentMethodUpdateRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest...\n");
#endif
    free(_cisPaymentMethodUpdateRequest->parameters);
  }
  if (_cisPaymentMethodUpdateRequest->merchantPaymentMethodId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest...\n");
#endif
    freeXsStringType(_cisPaymentMethodUpdateRequest->merchantPaymentMethodId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest...\n");
#endif
    free(_cisPaymentMethodUpdateRequest->merchantPaymentMethodId);
  }
  if (_cisPaymentMethodUpdateRequest->enabled != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor enabled of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest...\n");
#endif
    freeXsBooleanType(_cisPaymentMethodUpdateRequest->enabled);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor enabled of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest...\n");
#endif
    free(_cisPaymentMethodUpdateRequest->enabled);
  }
  if (_cisPaymentMethodUpdateRequest->billingAddress != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingAddress of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest...\n");
#endif
    freeNs0CisAddressType(_cisPaymentMethodUpdateRequest->billingAddress);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingAddress of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest...\n");
#endif
    free(_cisPaymentMethodUpdateRequest->billingAddress);
  }
  if (_cisPaymentMethodUpdateRequest->propagate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor propagate of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest...\n");
#endif
    freeXsBooleanType(_cisPaymentMethodUpdateRequest->propagate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor propagate of type hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest...\n");
#endif
    free(_cisPaymentMethodUpdateRequest->propagate);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisPaymentMethodUpdateRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList_M

/**
 * Reads a CisSubscriptionBillingActivityList element from XML. The element to be read is "billingActivityList", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionBillingActivityList, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0BillingActivityListElement(reader);
}

/**
 * Writes a CisSubscriptionBillingActivityList to XML under element name "billingActivityList".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList) {
  return xmlTextWriterWriteNs0BillingActivityListElementNS(writer, _cisSubscriptionBillingActivityList, 1);
}

/**
 * Frees a CisSubscriptionBillingActivityList.
 *
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList) {
  freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
  free(_cisSubscriptionBillingActivityList);
}

/**
 * Reads a CisSubscriptionBillingActivityList element from XML. The element to be read is "billingActivityList", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionBillingActivityList, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *xmlTextReaderReadNs0BillingActivityListElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "billingActivityList", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}billingActivityList.\n");
#endif
    _cisSubscriptionBillingActivityList = xmlTextReaderReadNs0CisSubscriptionBillingActivityListType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionBillingActivityList == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}billingActivityList failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}billingActivityList failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionBillingActivityList;
}

/**
 * Writes a CisSubscriptionBillingActivityList to XML under element name "billingActivityList".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0BillingActivityListElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList) {
  return xmlTextWriterWriteNs0BillingActivityListElementNS(writer, _cisSubscriptionBillingActivityList, 0);
}

/**
 * Writes a CisSubscriptionBillingActivityList to XML under element name "billingActivityList".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0BillingActivityListElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingActivityList", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}billingActivityList. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionBillingActivityList for root element {}billingActivityList...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionBillingActivityListType(writer, _cisSubscriptionBillingActivityList);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}billingActivityList. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}billingActivityList. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionBillingActivityList.
 *
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList whose children are to be free.
 */
static void freeNs0BillingActivityListElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList) {
  freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
}

/**
 * Reads a CisSubscriptionBillingActivityList from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionBillingActivityList, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *xmlTextReaderReadNs0CisSubscriptionBillingActivityListType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "clientRefId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}clientRefId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}clientRefId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }
        _cisSubscriptionBillingActivityList->clientRefId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }
        _cisSubscriptionBillingActivityList->vendorId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorReasonCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorReasonCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorReasonCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }
        _cisSubscriptionBillingActivityList->vendorReasonCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorStatusCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorStatusCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorStatusCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }
        _cisSubscriptionBillingActivityList->vendorStatusCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }
        _cisSubscriptionBillingActivityList->id = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "href", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}href...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}href of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }
        _cisSubscriptionBillingActivityList->href = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
      free(_cisSubscriptionBillingActivityList);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
        free(_cisSubscriptionBillingActivityList);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "decision", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}decision of type {}cisDecision.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisDecisionType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}decision of type {}cisDecision.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }

        _cisSubscriptionBillingActivityList->decision = ((enum hybris_cis_mock_subscription_web_ns0_cisDecision*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorResponses", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }

        _cisSubscriptionBillingActivityList->vendorResponses = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantSubscriptionId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }

        _cisSubscriptionBillingActivityList->merchantSubscriptionId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billings", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

        if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
          printf("Unwrapping wrapper element {}billings...\n");
#endif
          //start wrapper element "{}billings"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
          while (xmlTextReaderDepth(reader) > (depth + 1)) {
            if (status < 1) {
              //panic: XML read error.
#if DEBUG_ENUNCIATE
              printf("Failure to advance to next child element.\n");
#endif
              freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
              free(_cisSubscriptionBillingActivityList);
              return NULL;
            }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billing", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billing of type {}cisSubscriptionBillingInfo.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisSubscriptionBillingInfoType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billing of type {}cisSubscriptionBillingInfo.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }

        _cisSubscriptionBillingActivityList->billings = realloc(_cisSubscriptionBillingActivityList->billings, (_cisSubscriptionBillingActivityList->_sizeof_billings + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo));
        memcpy(&(_cisSubscriptionBillingActivityList->billings[_cisSubscriptionBillingActivityList->_sizeof_billings++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
          } // end "while in wrapper element" loop
        } //end "if empty element" clause

        if (status < 1) {
          //panic: XML read error.
#if DEBUG_ENUNCIATE
          printf("Failed to advance to end wrapper element {}billings.\n");
#endif
          freeNs0CisSubscriptionBillingActivityListType(_cisSubscriptionBillingActivityList);
          free(_cisSubscriptionBillingActivityList);
          return NULL;
        }
        else {
          //end wrapper element "{}billings"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
        }
      } // end "if wrapper element" clause
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionBillingActivityList.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionBillingActivityList. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionBillingActivityList;
}

/**
 * Writes a CisSubscriptionBillingActivityList to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionBillingActivityListType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisSubscriptionBillingActivityList->clientRefId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "clientRefId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}clientRefId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingActivityList->clientRefId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionBillingActivityList->vendorId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingActivityList->vendorId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionBillingActivityList->vendorReasonCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorReasonCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorReasonCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingActivityList->vendorReasonCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionBillingActivityList->vendorStatusCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorStatusCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorStatusCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingActivityList->vendorStatusCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionBillingActivityList->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingActivityList->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionBillingActivityList->href != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "href", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}href. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}href...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingActivityList->href));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionBillingActivityList->decision != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "decision", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisDecision for element {}decision...\n");
#endif
    status = xmlTextWriterWriteNs0CisDecisionType(writer, (_cisSubscriptionBillingActivityList->decision));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisDecision for element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionBillingActivityList->vendorResponses != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorResponses", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorResponses...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionBillingActivityList->vendorResponses));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionBillingActivityList->merchantSubscriptionId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantSubscriptionId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantSubscriptionId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingActivityList->merchantSubscriptionId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionBillingActivityList->billings != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billings", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billings. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisSubscriptionBillingActivityList->_sizeof_billings; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billing", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billing. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisSubscriptionBillingInfo for element {}billing...\n");
#endif
    status = xmlTextWriterWriteNs0CisSubscriptionBillingInfoType(writer, &(_cisSubscriptionBillingActivityList->billings[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisSubscriptionBillingInfo for element {}billing. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billing. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionBillingActivityList->billings != NULL) {
    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billings. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionBillingActivityList.
 *
 * @param _cisSubscriptionBillingActivityList The CisSubscriptionBillingActivityList to free.
 */
static void freeNs0CisSubscriptionBillingActivityListType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList *_cisSubscriptionBillingActivityList) {
  int i;
  if (_cisSubscriptionBillingActivityList->clientRefId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingActivityList->clientRefId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    free(_cisSubscriptionBillingActivityList->clientRefId);
  }
  if (_cisSubscriptionBillingActivityList->vendorId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingActivityList->vendorId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    free(_cisSubscriptionBillingActivityList->vendorId);
  }
  if (_cisSubscriptionBillingActivityList->vendorReasonCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingActivityList->vendorReasonCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    free(_cisSubscriptionBillingActivityList->vendorReasonCode);
  }
  if (_cisSubscriptionBillingActivityList->vendorStatusCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingActivityList->vendorStatusCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    free(_cisSubscriptionBillingActivityList->vendorStatusCode);
  }
  if (_cisSubscriptionBillingActivityList->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingActivityList->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    free(_cisSubscriptionBillingActivityList->id);
  }
  if (_cisSubscriptionBillingActivityList->href != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor href of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingActivityList->href);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor href of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    free(_cisSubscriptionBillingActivityList->href);
  }
  if (_cisSubscriptionBillingActivityList->decision != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor decision of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    freeNs0CisDecisionType(_cisSubscriptionBillingActivityList->decision);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor decision of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    free(_cisSubscriptionBillingActivityList->decision);
  }
  if (_cisSubscriptionBillingActivityList->vendorResponses != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionBillingActivityList->vendorResponses);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    free(_cisSubscriptionBillingActivityList->vendorResponses);
  }
  if (_cisSubscriptionBillingActivityList->merchantSubscriptionId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingActivityList->merchantSubscriptionId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    free(_cisSubscriptionBillingActivityList->merchantSubscriptionId);
  }
  if (_cisSubscriptionBillingActivityList->billings != NULL) {
    for (i = 0; i < _cisSubscriptionBillingActivityList->_sizeof_billings; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor billings[%i] of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n", i);
#endif
      freeNs0CisSubscriptionBillingInfoType(&(_cisSubscriptionBillingActivityList->billings[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billings of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList...\n");
#endif
    free(_cisSubscriptionBillingActivityList->billings);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingActivityList_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo_M

/**
 * Reads a CisSubscriptionBillingInfo element from XML. The element to be read is "billing", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionBillingInfo, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0BillingElement(reader);
}

/**
 * Writes a CisSubscriptionBillingInfo to XML under element name "billing".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo) {
  return xmlTextWriterWriteNs0BillingElementNS(writer, _cisSubscriptionBillingInfo, 1);
}

/**
 * Frees a CisSubscriptionBillingInfo.
 *
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo) {
  freeNs0CisSubscriptionBillingInfoType(_cisSubscriptionBillingInfo);
  free(_cisSubscriptionBillingInfo);
}

/**
 * Reads a CisSubscriptionBillingInfo element from XML. The element to be read is "billing", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionBillingInfo, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *xmlTextReaderReadNs0BillingElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "billing", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}billing.\n");
#endif
    _cisSubscriptionBillingInfo = xmlTextReaderReadNs0CisSubscriptionBillingInfoType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionBillingInfo == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}billing failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}billing failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionBillingInfo;
}

/**
 * Writes a CisSubscriptionBillingInfo to XML under element name "billing".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0BillingElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo) {
  return xmlTextWriterWriteNs0BillingElementNS(writer, _cisSubscriptionBillingInfo, 0);
}

/**
 * Writes a CisSubscriptionBillingInfo to XML under element name "billing".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0BillingElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billing", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}billing. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionBillingInfo for root element {}billing...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionBillingInfoType(writer, _cisSubscriptionBillingInfo);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}billing. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}billing. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionBillingInfo.
 *
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo whose children are to be free.
 */
static void freeNs0BillingElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo) {
  freeNs0CisSubscriptionBillingInfoType(_cisSubscriptionBillingInfo);
}

/**
 * Reads a CisSubscriptionBillingInfo from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionBillingInfo, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *xmlTextReaderReadNs0CisSubscriptionBillingInfoType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionBillingInfoType(_cisSubscriptionBillingInfo);
        free(_cisSubscriptionBillingInfo);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionBillingInfoType(_cisSubscriptionBillingInfo);
          free(_cisSubscriptionBillingInfo);
          return NULL;
        }

        _cisSubscriptionBillingInfo->billingId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingPeriod", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingPeriod of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingPeriod of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionBillingInfoType(_cisSubscriptionBillingInfo);
          free(_cisSubscriptionBillingInfo);
          return NULL;
        }

        _cisSubscriptionBillingInfo->billingPeriod = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingDate of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingDate of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionBillingInfoType(_cisSubscriptionBillingInfo);
          free(_cisSubscriptionBillingInfo);
          return NULL;
        }

        _cisSubscriptionBillingInfo->billingDate = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "amount", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}amount of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}amount of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionBillingInfoType(_cisSubscriptionBillingInfo);
          free(_cisSubscriptionBillingInfo);
          return NULL;
        }

        _cisSubscriptionBillingInfo->amount = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "status", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}status of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}status of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionBillingInfoType(_cisSubscriptionBillingInfo);
          free(_cisSubscriptionBillingInfo);
          return NULL;
        }

        _cisSubscriptionBillingInfo->status = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "customFields", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}customFields of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}customFields of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionBillingInfoType(_cisSubscriptionBillingInfo);
          free(_cisSubscriptionBillingInfo);
          return NULL;
        }

        _cisSubscriptionBillingInfo->customFields = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionBillingInfo.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionBillingInfo. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionBillingInfo;
}

/**
 * Writes a CisSubscriptionBillingInfo to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionBillingInfoType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionBillingInfo->billingId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}billingId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingInfo->billingId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}billingId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionBillingInfo->billingPeriod != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingPeriod", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingPeriod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}billingPeriod...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingInfo->billingPeriod));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}billingPeriod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingPeriod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionBillingInfo->billingDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}billingDate...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingInfo->billingDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}billingDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionBillingInfo->amount != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "amount", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}amount...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingInfo->amount));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionBillingInfo->status != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "status", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}status. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}status...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionBillingInfo->status));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}status. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}status. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionBillingInfo->customFields != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "customFields", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}customFields. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}customFields...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionBillingInfo->customFields));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}customFields. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}customFields. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionBillingInfo.
 *
 * @param _cisSubscriptionBillingInfo The CisSubscriptionBillingInfo to free.
 */
static void freeNs0CisSubscriptionBillingInfoType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo *_cisSubscriptionBillingInfo) {
  int i;
  if (_cisSubscriptionBillingInfo->billingId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingInfo->billingId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    free(_cisSubscriptionBillingInfo->billingId);
  }
  if (_cisSubscriptionBillingInfo->billingPeriod != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingPeriod of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingInfo->billingPeriod);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingPeriod of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    free(_cisSubscriptionBillingInfo->billingPeriod);
  }
  if (_cisSubscriptionBillingInfo->billingDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingInfo->billingDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    free(_cisSubscriptionBillingInfo->billingDate);
  }
  if (_cisSubscriptionBillingInfo->amount != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor amount of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingInfo->amount);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor amount of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    free(_cisSubscriptionBillingInfo->amount);
  }
  if (_cisSubscriptionBillingInfo->status != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor status of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    freeXsStringType(_cisSubscriptionBillingInfo->status);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor status of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    free(_cisSubscriptionBillingInfo->status);
  }
  if (_cisSubscriptionBillingInfo->customFields != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor customFields of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionBillingInfo->customFields);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor customFields of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo...\n");
#endif
    free(_cisSubscriptionBillingInfo->customFields);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest_M

/**
 * Reads a CisSubscriptionCancelSubscriptionRequest element from XML. The element to be read is "subscriptionCancelSubscriptionRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionCancelSubscriptionRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionCancelSubscriptionRequestElement(reader);
}

/**
 * Writes a CisSubscriptionCancelSubscriptionRequest to XML under element name "subscriptionCancelSubscriptionRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest) {
  return xmlTextWriterWriteNs0SubscriptionCancelSubscriptionRequestElementNS(writer, _cisSubscriptionCancelSubscriptionRequest, 1);
}

/**
 * Frees a CisSubscriptionCancelSubscriptionRequest.
 *
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest) {
  freeNs0CisSubscriptionCancelSubscriptionRequestType(_cisSubscriptionCancelSubscriptionRequest);
  free(_cisSubscriptionCancelSubscriptionRequest);
}

/**
 * Reads a CisSubscriptionCancelSubscriptionRequest element from XML. The element to be read is "subscriptionCancelSubscriptionRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionCancelSubscriptionRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *xmlTextReaderReadNs0SubscriptionCancelSubscriptionRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionCancelSubscriptionRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionCancelSubscriptionRequest.\n");
#endif
    _cisSubscriptionCancelSubscriptionRequest = xmlTextReaderReadNs0CisSubscriptionCancelSubscriptionRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionCancelSubscriptionRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionCancelSubscriptionRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionCancelSubscriptionRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionCancelSubscriptionRequest;
}

/**
 * Writes a CisSubscriptionCancelSubscriptionRequest to XML under element name "subscriptionCancelSubscriptionRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionCancelSubscriptionRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest) {
  return xmlTextWriterWriteNs0SubscriptionCancelSubscriptionRequestElementNS(writer, _cisSubscriptionCancelSubscriptionRequest, 0);
}

/**
 * Writes a CisSubscriptionCancelSubscriptionRequest to XML under element name "subscriptionCancelSubscriptionRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionCancelSubscriptionRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionCancelSubscriptionRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionCancelSubscriptionRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionCancelSubscriptionRequest for root element {}subscriptionCancelSubscriptionRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionCancelSubscriptionRequestType(writer, _cisSubscriptionCancelSubscriptionRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionCancelSubscriptionRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionCancelSubscriptionRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionCancelSubscriptionRequest.
 *
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest whose children are to be free.
 */
static void freeNs0SubscriptionCancelSubscriptionRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest) {
  freeNs0CisSubscriptionCancelSubscriptionRequestType(_cisSubscriptionCancelSubscriptionRequest);
}

/**
 * Reads a CisSubscriptionCancelSubscriptionRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionCancelSubscriptionRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *xmlTextReaderReadNs0CisSubscriptionCancelSubscriptionRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionCancelSubscriptionRequestType(_cisSubscriptionCancelSubscriptionRequest);
        free(_cisSubscriptionCancelSubscriptionRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCancelSubscriptionRequestType(_cisSubscriptionCancelSubscriptionRequest);
          free(_cisSubscriptionCancelSubscriptionRequest);
          return NULL;
        }

        _cisSubscriptionCancelSubscriptionRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantSubscriptionId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCancelSubscriptionRequestType(_cisSubscriptionCancelSubscriptionRequest);
          free(_cisSubscriptionCancelSubscriptionRequest);
          return NULL;
        }

        _cisSubscriptionCancelSubscriptionRequest->merchantSubscriptionId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "cancelationMode", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}cancelationMode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}cancelationMode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCancelSubscriptionRequestType(_cisSubscriptionCancelSubscriptionRequest);
          free(_cisSubscriptionCancelSubscriptionRequest);
          return NULL;
        }

        _cisSubscriptionCancelSubscriptionRequest->cancelationMode = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "force", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}force of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}force of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCancelSubscriptionRequestType(_cisSubscriptionCancelSubscriptionRequest);
          free(_cisSubscriptionCancelSubscriptionRequest);
          return NULL;
        }

        _cisSubscriptionCancelSubscriptionRequest->force = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionCancelSubscriptionRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionCancelSubscriptionRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionCancelSubscriptionRequest;
}

/**
 * Writes a CisSubscriptionCancelSubscriptionRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionCancelSubscriptionRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionCancelSubscriptionRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionCancelSubscriptionRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionCancelSubscriptionRequest->merchantSubscriptionId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantSubscriptionId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantSubscriptionId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionCancelSubscriptionRequest->merchantSubscriptionId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionCancelSubscriptionRequest->cancelationMode != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "cancelationMode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}cancelationMode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}cancelationMode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionCancelSubscriptionRequest->cancelationMode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}cancelationMode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}cancelationMode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "force", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}force. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}force...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_cisSubscriptionCancelSubscriptionRequest->force));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}force. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}force. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionCancelSubscriptionRequest.
 *
 * @param _cisSubscriptionCancelSubscriptionRequest The CisSubscriptionCancelSubscriptionRequest to free.
 */
static void freeNs0CisSubscriptionCancelSubscriptionRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest *_cisSubscriptionCancelSubscriptionRequest) {
  int i;
  if (_cisSubscriptionCancelSubscriptionRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionCancelSubscriptionRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest...\n");
#endif
    free(_cisSubscriptionCancelSubscriptionRequest->parameters);
  }
  if (_cisSubscriptionCancelSubscriptionRequest->merchantSubscriptionId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionCancelSubscriptionRequest->merchantSubscriptionId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest...\n");
#endif
    free(_cisSubscriptionCancelSubscriptionRequest->merchantSubscriptionId);
  }
  if (_cisSubscriptionCancelSubscriptionRequest->cancelationMode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor cancelationMode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionCancelSubscriptionRequest->cancelationMode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor cancelationMode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest...\n");
#endif
    free(_cisSubscriptionCancelSubscriptionRequest->cancelationMode);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCancelSubscriptionRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest_M

/**
 * Reads a CisSubscriptionChangeStateRequest element from XML. The element to be read is "subscriptionChangeStateRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionChangeStateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionChangeStateRequestElement(reader);
}

/**
 * Writes a CisSubscriptionChangeStateRequest to XML under element name "subscriptionChangeStateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest) {
  return xmlTextWriterWriteNs0SubscriptionChangeStateRequestElementNS(writer, _cisSubscriptionChangeStateRequest, 1);
}

/**
 * Frees a CisSubscriptionChangeStateRequest.
 *
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest) {
  freeNs0CisSubscriptionChangeStateRequestType(_cisSubscriptionChangeStateRequest);
  free(_cisSubscriptionChangeStateRequest);
}

/**
 * Reads a CisSubscriptionChangeStateRequest element from XML. The element to be read is "subscriptionChangeStateRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionChangeStateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *xmlTextReaderReadNs0SubscriptionChangeStateRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionChangeStateRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionChangeStateRequest.\n");
#endif
    _cisSubscriptionChangeStateRequest = xmlTextReaderReadNs0CisSubscriptionChangeStateRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionChangeStateRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionChangeStateRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionChangeStateRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionChangeStateRequest;
}

/**
 * Writes a CisSubscriptionChangeStateRequest to XML under element name "subscriptionChangeStateRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionChangeStateRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest) {
  return xmlTextWriterWriteNs0SubscriptionChangeStateRequestElementNS(writer, _cisSubscriptionChangeStateRequest, 0);
}

/**
 * Writes a CisSubscriptionChangeStateRequest to XML under element name "subscriptionChangeStateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionChangeStateRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionChangeStateRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionChangeStateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionChangeStateRequest for root element {}subscriptionChangeStateRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionChangeStateRequestType(writer, _cisSubscriptionChangeStateRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionChangeStateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionChangeStateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionChangeStateRequest.
 *
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest whose children are to be free.
 */
static void freeNs0SubscriptionChangeStateRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest) {
  freeNs0CisSubscriptionChangeStateRequestType(_cisSubscriptionChangeStateRequest);
}

/**
 * Reads a CisSubscriptionChangeStateRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionChangeStateRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *xmlTextReaderReadNs0CisSubscriptionChangeStateRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionChangeStateRequestType(_cisSubscriptionChangeStateRequest);
        free(_cisSubscriptionChangeStateRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionChangeStateRequestType(_cisSubscriptionChangeStateRequest);
          free(_cisSubscriptionChangeStateRequest);
          return NULL;
        }

        _cisSubscriptionChangeStateRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "effectiveFrom", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}effectiveFrom of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}effectiveFrom of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionChangeStateRequestType(_cisSubscriptionChangeStateRequest);
          free(_cisSubscriptionChangeStateRequest);
          return NULL;
        }

        _cisSubscriptionChangeStateRequest->effectiveFrom = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantSubscriptionId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionChangeStateRequestType(_cisSubscriptionChangeStateRequest);
          free(_cisSubscriptionChangeStateRequest);
          return NULL;
        }

        _cisSubscriptionChangeStateRequest->merchantSubscriptionId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "newState", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}newState of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}newState of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionChangeStateRequestType(_cisSubscriptionChangeStateRequest);
          free(_cisSubscriptionChangeStateRequest);
          return NULL;
        }

        _cisSubscriptionChangeStateRequest->newState = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionChangeStateRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionChangeStateRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionChangeStateRequest;
}

/**
 * Writes a CisSubscriptionChangeStateRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionChangeStateRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionChangeStateRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionChangeStateRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionChangeStateRequest->effectiveFrom != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "effectiveFrom", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}effectiveFrom. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}effectiveFrom...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionChangeStateRequest->effectiveFrom));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}effectiveFrom. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}effectiveFrom. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionChangeStateRequest->merchantSubscriptionId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantSubscriptionId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantSubscriptionId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionChangeStateRequest->merchantSubscriptionId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionChangeStateRequest->newState != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "newState", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}newState. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}newState...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionChangeStateRequest->newState));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}newState. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}newState. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionChangeStateRequest.
 *
 * @param _cisSubscriptionChangeStateRequest The CisSubscriptionChangeStateRequest to free.
 */
static void freeNs0CisSubscriptionChangeStateRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest *_cisSubscriptionChangeStateRequest) {
  int i;
  if (_cisSubscriptionChangeStateRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionChangeStateRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest...\n");
#endif
    free(_cisSubscriptionChangeStateRequest->parameters);
  }
  if (_cisSubscriptionChangeStateRequest->effectiveFrom != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor effectiveFrom of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionChangeStateRequest->effectiveFrom);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor effectiveFrom of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest...\n");
#endif
    free(_cisSubscriptionChangeStateRequest->effectiveFrom);
  }
  if (_cisSubscriptionChangeStateRequest->merchantSubscriptionId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionChangeStateRequest->merchantSubscriptionId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest...\n");
#endif
    free(_cisSubscriptionChangeStateRequest->merchantSubscriptionId);
  }
  if (_cisSubscriptionChangeStateRequest->newState != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor newState of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionChangeStateRequest->newState);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor newState of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest...\n");
#endif
    free(_cisSubscriptionChangeStateRequest->newState);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionChangeStateRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest_M

/**
 * Reads a CisSubscriptionCreateRequest element from XML. The element to be read is "subscriptionCreateRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionCreateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionCreateRequestElement(reader);
}

/**
 * Writes a CisSubscriptionCreateRequest to XML under element name "subscriptionCreateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest) {
  return xmlTextWriterWriteNs0SubscriptionCreateRequestElementNS(writer, _cisSubscriptionCreateRequest, 1);
}

/**
 * Frees a CisSubscriptionCreateRequest.
 *
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest) {
  freeNs0CisSubscriptionCreateRequestType(_cisSubscriptionCreateRequest);
  free(_cisSubscriptionCreateRequest);
}

/**
 * Reads a CisSubscriptionCreateRequest element from XML. The element to be read is "subscriptionCreateRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionCreateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *xmlTextReaderReadNs0SubscriptionCreateRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionCreateRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionCreateRequest.\n");
#endif
    _cisSubscriptionCreateRequest = xmlTextReaderReadNs0CisSubscriptionCreateRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionCreateRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionCreateRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionCreateRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionCreateRequest;
}

/**
 * Writes a CisSubscriptionCreateRequest to XML under element name "subscriptionCreateRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionCreateRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest) {
  return xmlTextWriterWriteNs0SubscriptionCreateRequestElementNS(writer, _cisSubscriptionCreateRequest, 0);
}

/**
 * Writes a CisSubscriptionCreateRequest to XML under element name "subscriptionCreateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionCreateRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionCreateRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionCreateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionCreateRequest for root element {}subscriptionCreateRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionCreateRequestType(writer, _cisSubscriptionCreateRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionCreateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionCreateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionCreateRequest.
 *
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest whose children are to be free.
 */
static void freeNs0SubscriptionCreateRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest) {
  freeNs0CisSubscriptionCreateRequestType(_cisSubscriptionCreateRequest);
}

/**
 * Reads a CisSubscriptionCreateRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionCreateRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *xmlTextReaderReadNs0CisSubscriptionCreateRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionCreateRequestType(_cisSubscriptionCreateRequest);
        free(_cisSubscriptionCreateRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCreateRequestType(_cisSubscriptionCreateRequest);
          free(_cisSubscriptionCreateRequest);
          return NULL;
        }

        _cisSubscriptionCreateRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "orderId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}orderId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}orderId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCreateRequestType(_cisSubscriptionCreateRequest);
          free(_cisSubscriptionCreateRequest);
          return NULL;
        }

        _cisSubscriptionCreateRequest->orderId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "currency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCreateRequestType(_cisSubscriptionCreateRequest);
          free(_cisSubscriptionCreateRequest);
          return NULL;
        }

        _cisSubscriptionCreateRequest->currency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "orderDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}orderDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}orderDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCreateRequestType(_cisSubscriptionCreateRequest);
          free(_cisSubscriptionCreateRequest);
          return NULL;
        }

        _cisSubscriptionCreateRequest->orderDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantAccountId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCreateRequestType(_cisSubscriptionCreateRequest);
          free(_cisSubscriptionCreateRequest);
          return NULL;
        }

        _cisSubscriptionCreateRequest->merchantAccountId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantPaymentMethodId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCreateRequestType(_cisSubscriptionCreateRequest);
          free(_cisSubscriptionCreateRequest);
          return NULL;
        }

        _cisSubscriptionCreateRequest->merchantPaymentMethodId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionItem", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionItem of type {}cisSubscriptionItem.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisSubscriptionItemType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionItem of type {}cisSubscriptionItem.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionCreateRequestType(_cisSubscriptionCreateRequest);
          free(_cisSubscriptionCreateRequest);
          return NULL;
        }

        _cisSubscriptionCreateRequest->subscriptionItem = ((struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionCreateRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionCreateRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionCreateRequest;
}

/**
 * Writes a CisSubscriptionCreateRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionCreateRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionCreateRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionCreateRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionCreateRequest->orderId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "orderId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}orderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}orderId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionCreateRequest->orderId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}orderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}orderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionCreateRequest->currency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "currency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}currency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionCreateRequest->currency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionCreateRequest->orderDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "orderDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}date for element {}orderDate...\n");
#endif
    status = xmlTextWriterWriteXsDateType(writer, (_cisSubscriptionCreateRequest->orderDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}date for element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionCreateRequest->merchantAccountId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantAccountId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionCreateRequest->merchantAccountId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionCreateRequest->merchantPaymentMethodId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantPaymentMethodId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionCreateRequest->merchantPaymentMethodId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionCreateRequest->subscriptionItem != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionItem", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisSubscriptionItem for element {}subscriptionItem...\n");
#endif
    status = xmlTextWriterWriteNs0CisSubscriptionItemType(writer, (_cisSubscriptionCreateRequest->subscriptionItem));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisSubscriptionItem for element {}subscriptionItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionCreateRequest.
 *
 * @param _cisSubscriptionCreateRequest The CisSubscriptionCreateRequest to free.
 */
static void freeNs0CisSubscriptionCreateRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest *_cisSubscriptionCreateRequest) {
  int i;
  if (_cisSubscriptionCreateRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionCreateRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    free(_cisSubscriptionCreateRequest->parameters);
  }
  if (_cisSubscriptionCreateRequest->orderId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor orderId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionCreateRequest->orderId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor orderId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    free(_cisSubscriptionCreateRequest->orderId);
  }
  if (_cisSubscriptionCreateRequest->currency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionCreateRequest->currency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    free(_cisSubscriptionCreateRequest->currency);
  }
  if (_cisSubscriptionCreateRequest->orderDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor orderDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    freeXsDateType(_cisSubscriptionCreateRequest->orderDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor orderDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    free(_cisSubscriptionCreateRequest->orderDate);
  }
  if (_cisSubscriptionCreateRequest->merchantAccountId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionCreateRequest->merchantAccountId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    free(_cisSubscriptionCreateRequest->merchantAccountId);
  }
  if (_cisSubscriptionCreateRequest->merchantPaymentMethodId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionCreateRequest->merchantPaymentMethodId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    free(_cisSubscriptionCreateRequest->merchantPaymentMethodId);
  }
  if (_cisSubscriptionCreateRequest->subscriptionItem != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionItem of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    freeNs0CisSubscriptionItemType(_cisSubscriptionCreateRequest->subscriptionItem);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionItem of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest...\n");
#endif
    free(_cisSubscriptionCreateRequest->subscriptionItem);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionCreateRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData_M

/**
 * Reads a CisSubscriptionData element from XML. The element to be read is "subscriptionData", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionData, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionDataElement(reader);
}

/**
 * Writes a CisSubscriptionData to XML under element name "subscriptionData".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionData The CisSubscriptionData to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData) {
  return xmlTextWriterWriteNs0SubscriptionDataElementNS(writer, _cisSubscriptionData, 1);
}

/**
 * Frees a CisSubscriptionData.
 *
 * @param _cisSubscriptionData The CisSubscriptionData to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData) {
  freeNs0CisSubscriptionDataType(_cisSubscriptionData);
  free(_cisSubscriptionData);
}

/**
 * Reads a CisSubscriptionData element from XML. The element to be read is "subscriptionData", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionData, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *xmlTextReaderReadNs0SubscriptionDataElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionData", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionData.\n");
#endif
    _cisSubscriptionData = xmlTextReaderReadNs0CisSubscriptionDataType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionData == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionData failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionData failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionData;
}

/**
 * Writes a CisSubscriptionData to XML under element name "subscriptionData".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionData The CisSubscriptionData to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionDataElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData) {
  return xmlTextWriterWriteNs0SubscriptionDataElementNS(writer, _cisSubscriptionData, 0);
}

/**
 * Writes a CisSubscriptionData to XML under element name "subscriptionData".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionData The CisSubscriptionData to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionDataElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionData", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionData. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionData for root element {}subscriptionData...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionDataType(writer, _cisSubscriptionData);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionData. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionData. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionData.
 *
 * @param _cisSubscriptionData The CisSubscriptionData whose children are to be free.
 */
static void freeNs0SubscriptionDataElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData) {
  freeNs0CisSubscriptionDataType(_cisSubscriptionData);
}

/**
 * Reads a CisSubscriptionData from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionData, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *xmlTextReaderReadNs0CisSubscriptionDataType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "clientRefId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}clientRefId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}clientRefId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }
        _cisSubscriptionData->clientRefId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }
        _cisSubscriptionData->vendorId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorReasonCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorReasonCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorReasonCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }
        _cisSubscriptionData->vendorReasonCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorStatusCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorStatusCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorStatusCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }
        _cisSubscriptionData->vendorStatusCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }
        _cisSubscriptionData->id = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "href", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}href...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}href of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }
        _cisSubscriptionData->href = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisSubscriptionDataType(_cisSubscriptionData);
      free(_cisSubscriptionData);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionDataType(_cisSubscriptionData);
        free(_cisSubscriptionData);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "decision", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}decision of type {}cisDecision.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisDecisionType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}decision of type {}cisDecision.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->decision = ((enum hybris_cis_mock_subscription_web_ns0_cisDecision*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorResponses", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->vendorResponses = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantAccountId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->merchantAccountId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "currency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->currency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->subscriptionId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionName", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->subscriptionName = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionDescription", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionDescription of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionDescription of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->subscriptionDescription = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionProductId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionProductId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionProductId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->subscriptionProductId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionOrderId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionOrderId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionOrderId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->subscriptionOrderId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionOrderEntryId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionOrderEntryId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionOrderEntryId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->subscriptionOrderEntryId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingSystemId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingSystemId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingSystemId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->billingSystemId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionStartDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionStartDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionStartDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->subscriptionStartDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionEndDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionEndDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionEndDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->subscriptionEndDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionStatus", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionStatus of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionStatus of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->subscriptionStatus = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "cancellationPossible", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}cancellationPossible of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}cancellationPossible of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->cancellationPossible = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingFrequency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingFrequency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingFrequency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->billingFrequency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "contractDuration", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}contractDuration of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}contractDuration of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->contractDuration = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "orderDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}orderDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateTimeType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}orderDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->orderDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "cancelDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}cancelDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateTimeType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}cancelDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->cancelDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "comments", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}comments of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}comments of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->comments = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "paymentMethod", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}paymentMethod of type {}cisPaymentMethod.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisPaymentMethodType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}paymentMethod of type {}cisPaymentMethod.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->paymentMethod = ((struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "autoRenewal", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}autoRenewal of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}autoRenewal of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionDataType(_cisSubscriptionData);
          free(_cisSubscriptionData);
          return NULL;
        }

        _cisSubscriptionData->autoRenewal = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionData.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionData. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionData;
}

/**
 * Writes a CisSubscriptionData to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionData The CisSubscriptionData to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionDataType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisSubscriptionData->clientRefId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "clientRefId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}clientRefId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->clientRefId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionData->vendorId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->vendorId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionData->vendorReasonCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorReasonCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorReasonCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->vendorReasonCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionData->vendorStatusCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorStatusCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorStatusCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->vendorStatusCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionData->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionData->href != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "href", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}href. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}href...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->href));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->decision != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "decision", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisDecision for element {}decision...\n");
#endif
    status = xmlTextWriterWriteNs0CisDecisionType(writer, (_cisSubscriptionData->decision));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisDecision for element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->vendorResponses != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorResponses", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorResponses...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionData->vendorResponses));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->merchantAccountId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantAccountId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->merchantAccountId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->currency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "currency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}currency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->currency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->subscriptionId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->subscriptionId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->subscriptionName != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->subscriptionName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->subscriptionDescription != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionDescription", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionDescription...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->subscriptionDescription));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->subscriptionProductId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionProductId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionProductId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->subscriptionProductId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->subscriptionOrderId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionOrderId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionOrderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionOrderId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->subscriptionOrderId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionOrderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionOrderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->subscriptionOrderEntryId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionOrderEntryId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionOrderEntryId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionOrderEntryId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->subscriptionOrderEntryId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionOrderEntryId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionOrderEntryId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->billingSystemId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingSystemId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingSystemId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}billingSystemId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->billingSystemId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}billingSystemId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingSystemId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->subscriptionStartDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionStartDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionStartDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}date for element {}subscriptionStartDate...\n");
#endif
    status = xmlTextWriterWriteXsDateType(writer, (_cisSubscriptionData->subscriptionStartDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}date for element {}subscriptionStartDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionStartDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->subscriptionEndDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionEndDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionEndDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}date for element {}subscriptionEndDate...\n");
#endif
    status = xmlTextWriterWriteXsDateType(writer, (_cisSubscriptionData->subscriptionEndDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}date for element {}subscriptionEndDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionEndDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->subscriptionStatus != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionStatus", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionStatus. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionStatus...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->subscriptionStatus));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionStatus. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionStatus. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->cancellationPossible != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "cancellationPossible", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}cancellationPossible. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}cancellationPossible...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, (_cisSubscriptionData->cancellationPossible));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}cancellationPossible. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}cancellationPossible. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->billingFrequency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingFrequency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingFrequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}billingFrequency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->billingFrequency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}billingFrequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingFrequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->contractDuration != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "contractDuration", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}contractDuration. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}contractDuration...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->contractDuration));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}contractDuration. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}contractDuration. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->orderDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "orderDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}dateTime for element {}orderDate...\n");
#endif
    status = xmlTextWriterWriteXsDateTimeType(writer, (_cisSubscriptionData->orderDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}dateTime for element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->cancelDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "cancelDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}cancelDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}dateTime for element {}cancelDate...\n");
#endif
    status = xmlTextWriterWriteXsDateTimeType(writer, (_cisSubscriptionData->cancelDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}dateTime for element {}cancelDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}cancelDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->comments != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "comments", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}comments. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}comments...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionData->comments));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}comments. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}comments. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->paymentMethod != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "paymentMethod", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisPaymentMethod for element {}paymentMethod...\n");
#endif
    status = xmlTextWriterWriteNs0CisPaymentMethodType(writer, (_cisSubscriptionData->paymentMethod));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisPaymentMethod for element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionData->autoRenewal != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "autoRenewal", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}autoRenewal...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, (_cisSubscriptionData->autoRenewal));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionData.
 *
 * @param _cisSubscriptionData The CisSubscriptionData to free.
 */
static void freeNs0CisSubscriptionDataType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData *_cisSubscriptionData) {
  int i;
  if (_cisSubscriptionData->clientRefId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->clientRefId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->clientRefId);
  }
  if (_cisSubscriptionData->vendorId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->vendorId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->vendorId);
  }
  if (_cisSubscriptionData->vendorReasonCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->vendorReasonCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->vendorReasonCode);
  }
  if (_cisSubscriptionData->vendorStatusCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->vendorStatusCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->vendorStatusCode);
  }
  if (_cisSubscriptionData->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->id);
  }
  if (_cisSubscriptionData->href != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor href of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->href);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor href of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->href);
  }
  if (_cisSubscriptionData->decision != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor decision of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeNs0CisDecisionType(_cisSubscriptionData->decision);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor decision of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->decision);
  }
  if (_cisSubscriptionData->vendorResponses != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionData->vendorResponses);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->vendorResponses);
  }
  if (_cisSubscriptionData->merchantAccountId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->merchantAccountId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->merchantAccountId);
  }
  if (_cisSubscriptionData->currency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->currency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->currency);
  }
  if (_cisSubscriptionData->subscriptionId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->subscriptionId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->subscriptionId);
  }
  if (_cisSubscriptionData->subscriptionName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionName of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->subscriptionName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionName of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->subscriptionName);
  }
  if (_cisSubscriptionData->subscriptionDescription != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionDescription of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->subscriptionDescription);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionDescription of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->subscriptionDescription);
  }
  if (_cisSubscriptionData->subscriptionProductId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionProductId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->subscriptionProductId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionProductId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->subscriptionProductId);
  }
  if (_cisSubscriptionData->subscriptionOrderId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionOrderId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->subscriptionOrderId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionOrderId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->subscriptionOrderId);
  }
  if (_cisSubscriptionData->subscriptionOrderEntryId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionOrderEntryId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->subscriptionOrderEntryId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionOrderEntryId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->subscriptionOrderEntryId);
  }
  if (_cisSubscriptionData->billingSystemId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingSystemId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->billingSystemId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingSystemId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->billingSystemId);
  }
  if (_cisSubscriptionData->subscriptionStartDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionStartDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsDateType(_cisSubscriptionData->subscriptionStartDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionStartDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->subscriptionStartDate);
  }
  if (_cisSubscriptionData->subscriptionEndDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionEndDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsDateType(_cisSubscriptionData->subscriptionEndDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionEndDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->subscriptionEndDate);
  }
  if (_cisSubscriptionData->subscriptionStatus != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionStatus of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->subscriptionStatus);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionStatus of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->subscriptionStatus);
  }
  if (_cisSubscriptionData->cancellationPossible != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor cancellationPossible of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsBooleanType(_cisSubscriptionData->cancellationPossible);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor cancellationPossible of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->cancellationPossible);
  }
  if (_cisSubscriptionData->billingFrequency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingFrequency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->billingFrequency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingFrequency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->billingFrequency);
  }
  if (_cisSubscriptionData->contractDuration != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor contractDuration of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->contractDuration);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor contractDuration of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->contractDuration);
  }
  if (_cisSubscriptionData->orderDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor orderDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsDateTimeType(_cisSubscriptionData->orderDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor orderDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->orderDate);
  }
  if (_cisSubscriptionData->cancelDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor cancelDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsDateTimeType(_cisSubscriptionData->cancelDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor cancelDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->cancelDate);
  }
  if (_cisSubscriptionData->comments != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor comments of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsStringType(_cisSubscriptionData->comments);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor comments of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->comments);
  }
  if (_cisSubscriptionData->paymentMethod != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor paymentMethod of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeNs0CisPaymentMethodType(_cisSubscriptionData->paymentMethod);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor paymentMethod of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->paymentMethod);
  }
  if (_cisSubscriptionData->autoRenewal != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor autoRenewal of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    freeXsBooleanType(_cisSubscriptionData->autoRenewal);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor autoRenewal of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionData...\n");
#endif
    free(_cisSubscriptionData->autoRenewal);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionData_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem_M

/**
 * Reads a CisSubscriptionItem from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionItem, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem *xmlTextReaderReadNs0CisSubscriptionItemType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem *_cisSubscriptionItem = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionItemType(_cisSubscriptionItem);
          free(_cisSubscriptionItem);
          return NULL;
        }
        _cisSubscriptionItem->id = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisSubscriptionItemType(_cisSubscriptionItem);
      free(_cisSubscriptionItem);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionItemType(_cisSubscriptionItem);
        free(_cisSubscriptionItem);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "code", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}code of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}code of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionItemType(_cisSubscriptionItem);
          free(_cisSubscriptionItem);
          return NULL;
        }

        _cisSubscriptionItem->code = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "name", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionItemType(_cisSubscriptionItem);
          free(_cisSubscriptionItem);
          return NULL;
        }

        _cisSubscriptionItem->name = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionItemType(_cisSubscriptionItem);
          free(_cisSubscriptionItem);
          return NULL;
        }

        _cisSubscriptionItem->vendorParameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionTerm", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionTerm of type {}cisTermsOfService.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisTermsOfServiceType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionTerm of type {}cisTermsOfService.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionItemType(_cisSubscriptionItem);
          free(_cisSubscriptionItem);
          return NULL;
        }

        _cisSubscriptionItem->subscriptionTerm = ((struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionPlan", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionPlan of type {}cisSubscriptionPlan.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisSubscriptionPlanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionPlan of type {}cisSubscriptionPlan.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionItemType(_cisSubscriptionItem);
          free(_cisSubscriptionItem);
          return NULL;
        }

        _cisSubscriptionItem->subscriptionPlan = ((struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionItem.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionItem. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionItem;
}

/**
 * Writes a CisSubscriptionItem to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionItem The CisSubscriptionItem to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionItemType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem *_cisSubscriptionItem) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisSubscriptionItem->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionItem->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionItem->code != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "code", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}code. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}code...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionItem->code));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}code. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}code. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionItem->name != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "name", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}name...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionItem->name));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionItem->vendorParameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionItem->vendorParameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionItem->subscriptionTerm != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionTerm", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionTerm. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisTermsOfService for element {}subscriptionTerm...\n");
#endif
    status = xmlTextWriterWriteNs0CisTermsOfServiceType(writer, (_cisSubscriptionItem->subscriptionTerm));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisTermsOfService for element {}subscriptionTerm. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionTerm. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionItem->subscriptionPlan != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionPlan", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionPlan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisSubscriptionPlan for element {}subscriptionPlan...\n");
#endif
    status = xmlTextWriterWriteNs0CisSubscriptionPlanType(writer, (_cisSubscriptionItem->subscriptionPlan));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisSubscriptionPlan for element {}subscriptionPlan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionPlan. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionItem.
 *
 * @param _cisSubscriptionItem The CisSubscriptionItem to free.
 */
static void freeNs0CisSubscriptionItemType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem *_cisSubscriptionItem) {
  int i;
  if (_cisSubscriptionItem->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    freeXsStringType(_cisSubscriptionItem->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    free(_cisSubscriptionItem->id);
  }
  if (_cisSubscriptionItem->code != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor code of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    freeXsStringType(_cisSubscriptionItem->code);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor code of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    free(_cisSubscriptionItem->code);
  }
  if (_cisSubscriptionItem->name != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor name of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    freeXsStringType(_cisSubscriptionItem->name);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor name of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    free(_cisSubscriptionItem->name);
  }
  if (_cisSubscriptionItem->vendorParameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionItem->vendorParameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    free(_cisSubscriptionItem->vendorParameters);
  }
  if (_cisSubscriptionItem->subscriptionTerm != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionTerm of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    freeNs0CisTermsOfServiceType(_cisSubscriptionItem->subscriptionTerm);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionTerm of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    free(_cisSubscriptionItem->subscriptionTerm);
  }
  if (_cisSubscriptionItem->subscriptionPlan != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionPlan of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    freeNs0CisSubscriptionPlanType(_cisSubscriptionItem->subscriptionPlan);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionPlan of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem...\n");
#endif
    free(_cisSubscriptionItem->subscriptionPlan);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder_M

/**
 * Reads a CisSubscriptionOrder element from XML. The element to be read is "subscriptionorder", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionOrder, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionorderElement(reader);
}

/**
 * Writes a CisSubscriptionOrder to XML under element name "subscriptionorder".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder) {
  return xmlTextWriterWriteNs0SubscriptionorderElementNS(writer, _cisSubscriptionOrder, 1);
}

/**
 * Frees a CisSubscriptionOrder.
 *
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder) {
  freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
  free(_cisSubscriptionOrder);
}

/**
 * Reads a CisSubscriptionOrder element from XML. The element to be read is "subscriptionorder", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionOrder, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *xmlTextReaderReadNs0SubscriptionorderElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionorder", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionorder.\n");
#endif
    _cisSubscriptionOrder = xmlTextReaderReadNs0CisSubscriptionOrderType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionOrder == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionorder failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionorder failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionOrder;
}

/**
 * Writes a CisSubscriptionOrder to XML under element name "subscriptionorder".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionorderElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder) {
  return xmlTextWriterWriteNs0SubscriptionorderElementNS(writer, _cisSubscriptionOrder, 0);
}

/**
 * Writes a CisSubscriptionOrder to XML under element name "subscriptionorder".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionorderElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionorder", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionorder. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionOrder for root element {}subscriptionorder...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionOrderType(writer, _cisSubscriptionOrder);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionorder. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionorder. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionOrder.
 *
 * @param _cisSubscriptionOrder The CisSubscriptionOrder whose children are to be free.
 */
static void freeNs0SubscriptionorderElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder) {
  freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
}

/**
 * Reads a CisSubscriptionOrder from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionOrder, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *xmlTextReaderReadNs0CisSubscriptionOrderType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }
        _cisSubscriptionOrder->id = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
      free(_cisSubscriptionOrder);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
        free(_cisSubscriptionOrder);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "date", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}date of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateTimeType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}date of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }

        _cisSubscriptionOrder->date = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "currency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }

        _cisSubscriptionOrder->currency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "addresses", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

        if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
          printf("Unwrapping wrapper element {}addresses...\n");
#endif
          //start wrapper element "{}addresses"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
          while (xmlTextReaderDepth(reader) > (depth + 1)) {
            if (status < 1) {
              //panic: XML read error.
#if DEBUG_ENUNCIATE
              printf("Failure to advance to next child element.\n");
#endif
              freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
              free(_cisSubscriptionOrder);
              return NULL;
            }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "address", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}address of type {}cisAddress.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisAddressType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}address of type {}cisAddress.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }

        _cisSubscriptionOrder->addresses = realloc(_cisSubscriptionOrder->addresses, (_cisSubscriptionOrder->_sizeof_addresses + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisAddress));
        memcpy(&(_cisSubscriptionOrder->addresses[_cisSubscriptionOrder->_sizeof_addresses++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisAddress));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
          } // end "while in wrapper element" loop
        } //end "if empty element" clause

        if (status < 1) {
          //panic: XML read error.
#if DEBUG_ENUNCIATE
          printf("Failed to advance to end wrapper element {}addresses.\n");
#endif
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }
        else {
          //end wrapper element "{}addresses"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
        }
      } // end "if wrapper element" clause
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "lineItems", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

        if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
          printf("Unwrapping wrapper element {}lineItems...\n");
#endif
          //start wrapper element "{}lineItems"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
          while (xmlTextReaderDepth(reader) > (depth + 1)) {
            if (status < 1) {
              //panic: XML read error.
#if DEBUG_ENUNCIATE
              printf("Failure to advance to next child element.\n");
#endif
              freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
              free(_cisSubscriptionOrder);
              return NULL;
            }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "lineItem", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}lineItem of type {}cisLineItem.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisLineItemType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}lineItem of type {}cisLineItem.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }

        _cisSubscriptionOrder->lineItems = realloc(_cisSubscriptionOrder->lineItems, (_cisSubscriptionOrder->_sizeof_lineItems + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisLineItem));
        memcpy(&(_cisSubscriptionOrder->lineItems[_cisSubscriptionOrder->_sizeof_lineItems++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisLineItem));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
          } // end "while in wrapper element" loop
        } //end "if empty element" clause

        if (status < 1) {
          //panic: XML read error.
#if DEBUG_ENUNCIATE
          printf("Failed to advance to end wrapper element {}lineItems.\n");
#endif
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }
        else {
          //end wrapper element "{}lineItems"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
        }
      } // end "if wrapper element" clause
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }

        _cisSubscriptionOrder->vendorParameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantAccountId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }

        _cisSubscriptionOrder->merchantAccountId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "items", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

        if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
          printf("Unwrapping wrapper element {}items...\n");
#endif
          //start wrapper element "{}items"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
          while (xmlTextReaderDepth(reader) > (depth + 1)) {
            if (status < 1) {
              //panic: XML read error.
#if DEBUG_ENUNCIATE
              printf("Failure to advance to next child element.\n");
#endif
              freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
              free(_cisSubscriptionOrder);
              return NULL;
            }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "item", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}item of type {}cisSubscriptionItem.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisSubscriptionItemType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}item of type {}cisSubscriptionItem.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }

        _cisSubscriptionOrder->items = realloc(_cisSubscriptionOrder->items, (_cisSubscriptionOrder->_sizeof_items + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem));
        memcpy(&(_cisSubscriptionOrder->items[_cisSubscriptionOrder->_sizeof_items++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
          } // end "while in wrapper element" loop
        } //end "if empty element" clause

        if (status < 1) {
          //panic: XML read error.
#if DEBUG_ENUNCIATE
          printf("Failed to advance to end wrapper element {}items.\n");
#endif
          freeNs0CisSubscriptionOrderType(_cisSubscriptionOrder);
          free(_cisSubscriptionOrder);
          return NULL;
        }
        else {
          //end wrapper element "{}items"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
        }
      } // end "if wrapper element" clause
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionOrder.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionOrder. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionOrder;
}

/**
 * Writes a CisSubscriptionOrder to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionOrderType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisSubscriptionOrder->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionOrder->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionOrder->date != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "date", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}date. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}dateTime for element {}date...\n");
#endif
    status = xmlTextWriterWriteXsDateTimeType(writer, (_cisSubscriptionOrder->date));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}dateTime for element {}date. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}date. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionOrder->currency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "currency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}currency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionOrder->currency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionOrder->addresses != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "addresses", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}addresses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisSubscriptionOrder->_sizeof_addresses; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "address", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}address. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisAddress for element {}address...\n");
#endif
    status = xmlTextWriterWriteNs0CisAddressType(writer, &(_cisSubscriptionOrder->addresses[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisAddress for element {}address. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}address. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionOrder->addresses != NULL) {
    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}addresses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionOrder->lineItems != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "lineItems", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}lineItems. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisSubscriptionOrder->_sizeof_lineItems; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "lineItem", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}lineItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisLineItem for element {}lineItem...\n");
#endif
    status = xmlTextWriterWriteNs0CisLineItemType(writer, &(_cisSubscriptionOrder->lineItems[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisLineItem for element {}lineItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}lineItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionOrder->lineItems != NULL) {
    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}lineItems. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionOrder->vendorParameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionOrder->vendorParameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionOrder->merchantAccountId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantAccountId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionOrder->merchantAccountId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionOrder->items != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "items", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}items. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisSubscriptionOrder->_sizeof_items; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "item", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}item. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisSubscriptionItem for element {}item...\n");
#endif
    status = xmlTextWriterWriteNs0CisSubscriptionItemType(writer, &(_cisSubscriptionOrder->items[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisSubscriptionItem for element {}item. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}item. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionOrder->items != NULL) {
    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}items. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionOrder.
 *
 * @param _cisSubscriptionOrder The CisSubscriptionOrder to free.
 */
static void freeNs0CisSubscriptionOrderType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder *_cisSubscriptionOrder) {
  int i;
  if (_cisSubscriptionOrder->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    freeXsStringType(_cisSubscriptionOrder->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    free(_cisSubscriptionOrder->id);
  }
  if (_cisSubscriptionOrder->date != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor date of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    freeXsDateTimeType(_cisSubscriptionOrder->date);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor date of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    free(_cisSubscriptionOrder->date);
  }
  if (_cisSubscriptionOrder->currency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    freeXsStringType(_cisSubscriptionOrder->currency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    free(_cisSubscriptionOrder->currency);
  }
  if (_cisSubscriptionOrder->addresses != NULL) {
    for (i = 0; i < _cisSubscriptionOrder->_sizeof_addresses; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor addresses[%i] of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n", i);
#endif
      freeNs0CisAddressType(&(_cisSubscriptionOrder->addresses[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor addresses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    free(_cisSubscriptionOrder->addresses);
  }
  if (_cisSubscriptionOrder->lineItems != NULL) {
    for (i = 0; i < _cisSubscriptionOrder->_sizeof_lineItems; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor lineItems[%i] of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n", i);
#endif
      freeNs0CisLineItemType(&(_cisSubscriptionOrder->lineItems[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor lineItems of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    free(_cisSubscriptionOrder->lineItems);
  }
  if (_cisSubscriptionOrder->vendorParameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionOrder->vendorParameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    free(_cisSubscriptionOrder->vendorParameters);
  }
  if (_cisSubscriptionOrder->merchantAccountId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    freeXsStringType(_cisSubscriptionOrder->merchantAccountId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    free(_cisSubscriptionOrder->merchantAccountId);
  }
  if (_cisSubscriptionOrder->items != NULL) {
    for (i = 0; i < _cisSubscriptionOrder->_sizeof_items; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor items[%i] of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n", i);
#endif
      freeNs0CisSubscriptionItemType(&(_cisSubscriptionOrder->items[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor items of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder...\n");
#endif
    free(_cisSubscriptionOrder->items);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest_M

/**
 * Reads a CisSubscriptionOrderPostRequest element from XML. The element to be read is "subscriptionOrderPostRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionOrderPostRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionOrderPostRequestElement(reader);
}

/**
 * Writes a CisSubscriptionOrderPostRequest to XML under element name "subscriptionOrderPostRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest) {
  return xmlTextWriterWriteNs0SubscriptionOrderPostRequestElementNS(writer, _cisSubscriptionOrderPostRequest, 1);
}

/**
 * Frees a CisSubscriptionOrderPostRequest.
 *
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest) {
  freeNs0CisSubscriptionOrderPostRequestType(_cisSubscriptionOrderPostRequest);
  free(_cisSubscriptionOrderPostRequest);
}

/**
 * Reads a CisSubscriptionOrderPostRequest element from XML. The element to be read is "subscriptionOrderPostRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionOrderPostRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *xmlTextReaderReadNs0SubscriptionOrderPostRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionOrderPostRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionOrderPostRequest.\n");
#endif
    _cisSubscriptionOrderPostRequest = xmlTextReaderReadNs0CisSubscriptionOrderPostRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionOrderPostRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionOrderPostRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionOrderPostRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionOrderPostRequest;
}

/**
 * Writes a CisSubscriptionOrderPostRequest to XML under element name "subscriptionOrderPostRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionOrderPostRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest) {
  return xmlTextWriterWriteNs0SubscriptionOrderPostRequestElementNS(writer, _cisSubscriptionOrderPostRequest, 0);
}

/**
 * Writes a CisSubscriptionOrderPostRequest to XML under element name "subscriptionOrderPostRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionOrderPostRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionOrderPostRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionOrderPostRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionOrderPostRequest for root element {}subscriptionOrderPostRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionOrderPostRequestType(writer, _cisSubscriptionOrderPostRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionOrderPostRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionOrderPostRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionOrderPostRequest.
 *
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest whose children are to be free.
 */
static void freeNs0SubscriptionOrderPostRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest) {
  freeNs0CisSubscriptionOrderPostRequestType(_cisSubscriptionOrderPostRequest);
}

/**
 * Reads a CisSubscriptionOrderPostRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionOrderPostRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *xmlTextReaderReadNs0CisSubscriptionOrderPostRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionOrderPostRequestType(_cisSubscriptionOrderPostRequest);
        free(_cisSubscriptionOrderPostRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderPostRequestType(_cisSubscriptionOrderPostRequest);
          free(_cisSubscriptionOrderPostRequest);
          return NULL;
        }

        _cisSubscriptionOrderPostRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantAccountId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderPostRequestType(_cisSubscriptionOrderPostRequest);
          free(_cisSubscriptionOrderPostRequest);
          return NULL;
        }

        _cisSubscriptionOrderPostRequest->merchantAccountId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantPaymentMethodId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderPostRequestType(_cisSubscriptionOrderPostRequest);
          free(_cisSubscriptionOrderPostRequest);
          return NULL;
        }

        _cisSubscriptionOrderPostRequest->merchantPaymentMethodId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionOrder", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionOrder of type {}cisSubscriptionOrder.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisSubscriptionOrderType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionOrder of type {}cisSubscriptionOrder.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderPostRequestType(_cisSubscriptionOrderPostRequest);
          free(_cisSubscriptionOrderPostRequest);
          return NULL;
        }

        _cisSubscriptionOrderPostRequest->subscriptionOrder = ((struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrder*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "currency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionOrderPostRequestType(_cisSubscriptionOrderPostRequest);
          free(_cisSubscriptionOrderPostRequest);
          return NULL;
        }

        _cisSubscriptionOrderPostRequest->currency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionOrderPostRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionOrderPostRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionOrderPostRequest;
}

/**
 * Writes a CisSubscriptionOrderPostRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionOrderPostRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionOrderPostRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionOrderPostRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionOrderPostRequest->merchantAccountId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantAccountId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionOrderPostRequest->merchantAccountId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionOrderPostRequest->merchantPaymentMethodId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantPaymentMethodId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionOrderPostRequest->merchantPaymentMethodId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionOrderPostRequest->subscriptionOrder != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionOrder", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionOrder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisSubscriptionOrder for element {}subscriptionOrder...\n");
#endif
    status = xmlTextWriterWriteNs0CisSubscriptionOrderType(writer, (_cisSubscriptionOrderPostRequest->subscriptionOrder));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisSubscriptionOrder for element {}subscriptionOrder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionOrder. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionOrderPostRequest->currency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "currency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}currency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionOrderPostRequest->currency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionOrderPostRequest.
 *
 * @param _cisSubscriptionOrderPostRequest The CisSubscriptionOrderPostRequest to free.
 */
static void freeNs0CisSubscriptionOrderPostRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest *_cisSubscriptionOrderPostRequest) {
  int i;
  if (_cisSubscriptionOrderPostRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionOrderPostRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest...\n");
#endif
    free(_cisSubscriptionOrderPostRequest->parameters);
  }
  if (_cisSubscriptionOrderPostRequest->merchantAccountId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionOrderPostRequest->merchantAccountId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest...\n");
#endif
    free(_cisSubscriptionOrderPostRequest->merchantAccountId);
  }
  if (_cisSubscriptionOrderPostRequest->merchantPaymentMethodId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionOrderPostRequest->merchantPaymentMethodId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest...\n");
#endif
    free(_cisSubscriptionOrderPostRequest->merchantPaymentMethodId);
  }
  if (_cisSubscriptionOrderPostRequest->subscriptionOrder != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionOrder of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest...\n");
#endif
    freeNs0CisSubscriptionOrderType(_cisSubscriptionOrderPostRequest->subscriptionOrder);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionOrder of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest...\n");
#endif
    free(_cisSubscriptionOrderPostRequest->subscriptionOrder);
  }
  if (_cisSubscriptionOrderPostRequest->currency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionOrderPostRequest->currency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest...\n");
#endif
    free(_cisSubscriptionOrderPostRequest->currency);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionOrderPostRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest_M

/**
 * Reads a CisSubscriptionPayNowRequest element from XML. The element to be read is "subscriptionProcessPayNowRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionPayNowRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionProcessPayNowRequestElement(reader);
}

/**
 * Writes a CisSubscriptionPayNowRequest to XML under element name "subscriptionProcessPayNowRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest) {
  return xmlTextWriterWriteNs0SubscriptionProcessPayNowRequestElementNS(writer, _cisSubscriptionPayNowRequest, 1);
}

/**
 * Frees a CisSubscriptionPayNowRequest.
 *
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest) {
  freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
  free(_cisSubscriptionPayNowRequest);
}

/**
 * Reads a CisSubscriptionPayNowRequest element from XML. The element to be read is "subscriptionProcessPayNowRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionPayNowRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *xmlTextReaderReadNs0SubscriptionProcessPayNowRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionProcessPayNowRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionProcessPayNowRequest.\n");
#endif
    _cisSubscriptionPayNowRequest = xmlTextReaderReadNs0CisSubscriptionPayNowRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionPayNowRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionProcessPayNowRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionProcessPayNowRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionPayNowRequest;
}

/**
 * Writes a CisSubscriptionPayNowRequest to XML under element name "subscriptionProcessPayNowRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionProcessPayNowRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest) {
  return xmlTextWriterWriteNs0SubscriptionProcessPayNowRequestElementNS(writer, _cisSubscriptionPayNowRequest, 0);
}

/**
 * Writes a CisSubscriptionPayNowRequest to XML under element name "subscriptionProcessPayNowRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionProcessPayNowRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionProcessPayNowRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionProcessPayNowRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionPayNowRequest for root element {}subscriptionProcessPayNowRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionPayNowRequestType(writer, _cisSubscriptionPayNowRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionProcessPayNowRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionProcessPayNowRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionPayNowRequest.
 *
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest whose children are to be free.
 */
static void freeNs0SubscriptionProcessPayNowRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest) {
  freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
}

/**
 * Reads a CisSubscriptionPayNowRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionPayNowRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *xmlTextReaderReadNs0CisSubscriptionPayNowRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
        free(_cisSubscriptionPayNowRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
          free(_cisSubscriptionPayNowRequest);
          return NULL;
        }

        _cisSubscriptionPayNowRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "amount", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}amount of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDecimalType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}amount of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
          free(_cisSubscriptionPayNowRequest);
          return NULL;
        }

        _cisSubscriptionPayNowRequest->amount = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "currency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
          free(_cisSubscriptionPayNowRequest);
          return NULL;
        }

        _cisSubscriptionPayNowRequest->currency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "profileId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}profileId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}profileId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
          free(_cisSubscriptionPayNowRequest);
          return NULL;
        }

        _cisSubscriptionPayNowRequest->profileId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "paymentMethodId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}paymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}paymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
          free(_cisSubscriptionPayNowRequest);
          return NULL;
        }

        _cisSubscriptionPayNowRequest->paymentMethodId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantTransactionId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantTransactionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantTransactionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
          free(_cisSubscriptionPayNowRequest);
          return NULL;
        }

        _cisSubscriptionPayNowRequest->merchantTransactionId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantTransactionDescription", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantTransactionDescription of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantTransactionDescription of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
          free(_cisSubscriptionPayNowRequest);
          return NULL;
        }

        _cisSubscriptionPayNowRequest->merchantTransactionDescription = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "lineItems", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

        if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
          printf("Unwrapping wrapper element {}lineItems...\n");
#endif
          //start wrapper element "{}lineItems"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
          while (xmlTextReaderDepth(reader) > (depth + 1)) {
            if (status < 1) {
              //panic: XML read error.
#if DEBUG_ENUNCIATE
              printf("Failure to advance to next child element.\n");
#endif
              freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
              free(_cisSubscriptionPayNowRequest);
              return NULL;
            }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "lineItem", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}lineItem of type {}cisLineItem.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisLineItemType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}lineItem of type {}cisLineItem.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
          free(_cisSubscriptionPayNowRequest);
          return NULL;
        }

        _cisSubscriptionPayNowRequest->lineItems = realloc(_cisSubscriptionPayNowRequest->lineItems, (_cisSubscriptionPayNowRequest->_sizeof_lineItems + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisLineItem));
        memcpy(&(_cisSubscriptionPayNowRequest->lineItems[_cisSubscriptionPayNowRequest->_sizeof_lineItems++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisLineItem));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
          } // end "while in wrapper element" loop
        } //end "if empty element" clause

        if (status < 1) {
          //panic: XML read error.
#if DEBUG_ENUNCIATE
          printf("Failed to advance to end wrapper element {}lineItems.\n");
#endif
          freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
          free(_cisSubscriptionPayNowRequest);
          return NULL;
        }
        else {
          //end wrapper element "{}lineItems"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
        }
      } // end "if wrapper element" clause
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "transactionMode", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}transactionMode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}transactionMode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPayNowRequestType(_cisSubscriptionPayNowRequest);
          free(_cisSubscriptionPayNowRequest);
          return NULL;
        }

        _cisSubscriptionPayNowRequest->transactionMode = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionPayNowRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionPayNowRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionPayNowRequest;
}

/**
 * Writes a CisSubscriptionPayNowRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionPayNowRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionPayNowRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionPayNowRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionPayNowRequest->amount != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "amount", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}decimal for element {}amount...\n");
#endif
    status = xmlTextWriterWriteXsDecimalType(writer, (_cisSubscriptionPayNowRequest->amount));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}decimal for element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionPayNowRequest->currency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "currency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}currency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionPayNowRequest->currency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionPayNowRequest->profileId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "profileId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}profileId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}profileId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionPayNowRequest->profileId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}profileId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}profileId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionPayNowRequest->paymentMethodId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "paymentMethodId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}paymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}paymentMethodId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionPayNowRequest->paymentMethodId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}paymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}paymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionPayNowRequest->merchantTransactionId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantTransactionId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantTransactionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantTransactionId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionPayNowRequest->merchantTransactionId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantTransactionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantTransactionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionPayNowRequest->merchantTransactionDescription != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantTransactionDescription", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantTransactionDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantTransactionDescription...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionPayNowRequest->merchantTransactionDescription));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantTransactionDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantTransactionDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionPayNowRequest->lineItems != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "lineItems", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}lineItems. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisSubscriptionPayNowRequest->_sizeof_lineItems; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "lineItem", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}lineItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisLineItem for element {}lineItem...\n");
#endif
    status = xmlTextWriterWriteNs0CisLineItemType(writer, &(_cisSubscriptionPayNowRequest->lineItems[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisLineItem for element {}lineItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}lineItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionPayNowRequest->lineItems != NULL) {
    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}lineItems. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionPayNowRequest->transactionMode != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "transactionMode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}transactionMode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}transactionMode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionPayNowRequest->transactionMode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}transactionMode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}transactionMode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionPayNowRequest.
 *
 * @param _cisSubscriptionPayNowRequest The CisSubscriptionPayNowRequest to free.
 */
static void freeNs0CisSubscriptionPayNowRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest *_cisSubscriptionPayNowRequest) {
  int i;
  if (_cisSubscriptionPayNowRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionPayNowRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    free(_cisSubscriptionPayNowRequest->parameters);
  }
  if (_cisSubscriptionPayNowRequest->amount != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor amount of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    freeXsDecimalType(_cisSubscriptionPayNowRequest->amount);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor amount of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    free(_cisSubscriptionPayNowRequest->amount);
  }
  if (_cisSubscriptionPayNowRequest->currency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionPayNowRequest->currency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    free(_cisSubscriptionPayNowRequest->currency);
  }
  if (_cisSubscriptionPayNowRequest->profileId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor profileId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionPayNowRequest->profileId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor profileId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    free(_cisSubscriptionPayNowRequest->profileId);
  }
  if (_cisSubscriptionPayNowRequest->paymentMethodId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor paymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionPayNowRequest->paymentMethodId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor paymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    free(_cisSubscriptionPayNowRequest->paymentMethodId);
  }
  if (_cisSubscriptionPayNowRequest->merchantTransactionId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantTransactionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionPayNowRequest->merchantTransactionId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantTransactionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    free(_cisSubscriptionPayNowRequest->merchantTransactionId);
  }
  if (_cisSubscriptionPayNowRequest->merchantTransactionDescription != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantTransactionDescription of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionPayNowRequest->merchantTransactionDescription);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantTransactionDescription of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    free(_cisSubscriptionPayNowRequest->merchantTransactionDescription);
  }
  if (_cisSubscriptionPayNowRequest->lineItems != NULL) {
    for (i = 0; i < _cisSubscriptionPayNowRequest->_sizeof_lineItems; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor lineItems[%i] of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n", i);
#endif
      freeNs0CisLineItemType(&(_cisSubscriptionPayNowRequest->lineItems[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor lineItems of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    free(_cisSubscriptionPayNowRequest->lineItems);
  }
  if (_cisSubscriptionPayNowRequest->transactionMode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor transactionMode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionPayNowRequest->transactionMode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor transactionMode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest...\n");
#endif
    free(_cisSubscriptionPayNowRequest->transactionMode);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPayNowRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan_M

/**
 * Reads a CisSubscriptionPlan from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionPlan, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan *xmlTextReaderReadNs0CisSubscriptionPlanType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan *_cisSubscriptionPlan = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
          free(_cisSubscriptionPlan);
          return NULL;
        }
        _cisSubscriptionPlan->id = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
      free(_cisSubscriptionPlan);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
        free(_cisSubscriptionPlan);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
          free(_cisSubscriptionPlan);
          return NULL;
        }

        _cisSubscriptionPlan->vendorParameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "usageCharges", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

        if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
          printf("Unwrapping wrapper element {}usageCharges...\n");
#endif
          //start wrapper element "{}usageCharges"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
          while (xmlTextReaderDepth(reader) > (depth + 1)) {
            if (status < 1) {
              //panic: XML read error.
#if DEBUG_ENUNCIATE
              printf("Failure to advance to next child element.\n");
#endif
              freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
              free(_cisSubscriptionPlan);
              return NULL;
            }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "usageCharge", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}usageCharge of type {}cisUsageCharge.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisUsageChargeType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}usageCharge of type {}cisUsageCharge.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
          free(_cisSubscriptionPlan);
          return NULL;
        }

        _cisSubscriptionPlan->usageCharges = realloc(_cisSubscriptionPlan->usageCharges, (_cisSubscriptionPlan->_sizeof_usageCharges + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge));
        memcpy(&(_cisSubscriptionPlan->usageCharges[_cisSubscriptionPlan->_sizeof_usageCharges++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
          } // end "while in wrapper element" loop
        } //end "if empty element" clause

        if (status < 1) {
          //panic: XML read error.
#if DEBUG_ENUNCIATE
          printf("Failed to advance to end wrapper element {}usageCharges.\n");
#endif
          freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
          free(_cisSubscriptionPlan);
          return NULL;
        }
        else {
          //end wrapper element "{}usageCharges"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
        }
      } // end "if wrapper element" clause
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "charges", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

        if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
          printf("Unwrapping wrapper element {}charges...\n");
#endif
          //start wrapper element "{}charges"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
          while (xmlTextReaderDepth(reader) > (depth + 1)) {
            if (status < 1) {
              //panic: XML read error.
#if DEBUG_ENUNCIATE
              printf("Failure to advance to next child element.\n");
#endif
              freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
              free(_cisSubscriptionPlan);
              return NULL;
            }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "charge", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}charge of type {}cisChargeEntry.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisChargeEntryType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}charge of type {}cisChargeEntry.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
          free(_cisSubscriptionPlan);
          return NULL;
        }

        _cisSubscriptionPlan->charges = realloc(_cisSubscriptionPlan->charges, (_cisSubscriptionPlan->_sizeof_charges + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry));
        memcpy(&(_cisSubscriptionPlan->charges[_cisSubscriptionPlan->_sizeof_charges++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisChargeEntry));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
          } // end "while in wrapper element" loop
        } //end "if empty element" clause

        if (status < 1) {
          //panic: XML read error.
#if DEBUG_ENUNCIATE
          printf("Failed to advance to end wrapper element {}charges.\n");
#endif
          freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
          free(_cisSubscriptionPlan);
          return NULL;
        }
        else {
          //end wrapper element "{}charges"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
        }
      } // end "if wrapper element" clause
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "name", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionPlanType(_cisSubscriptionPlan);
          free(_cisSubscriptionPlan);
          return NULL;
        }

        _cisSubscriptionPlan->name = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionPlan.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionPlan. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionPlan;
}

/**
 * Writes a CisSubscriptionPlan to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionPlan The CisSubscriptionPlan to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionPlanType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan *_cisSubscriptionPlan) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisSubscriptionPlan->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionPlan->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionPlan->vendorParameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionPlan->vendorParameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionPlan->usageCharges != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "usageCharges", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}usageCharges. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisSubscriptionPlan->_sizeof_usageCharges; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "usageCharge", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}usageCharge. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisUsageCharge for element {}usageCharge...\n");
#endif
    status = xmlTextWriterWriteNs0CisUsageChargeType(writer, &(_cisSubscriptionPlan->usageCharges[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisUsageCharge for element {}usageCharge. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}usageCharge. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionPlan->usageCharges != NULL) {
    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}usageCharges. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionPlan->charges != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "charges", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}charges. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisSubscriptionPlan->_sizeof_charges; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "charge", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}charge. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisChargeEntry for element {}charge...\n");
#endif
    status = xmlTextWriterWriteNs0CisChargeEntryType(writer, &(_cisSubscriptionPlan->charges[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisChargeEntry for element {}charge. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}charge. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionPlan->charges != NULL) {
    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}charges. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionPlan->name != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "name", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}name...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionPlan->name));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionPlan.
 *
 * @param _cisSubscriptionPlan The CisSubscriptionPlan to free.
 */
static void freeNs0CisSubscriptionPlanType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan *_cisSubscriptionPlan) {
  int i;
  if (_cisSubscriptionPlan->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan...\n");
#endif
    freeXsStringType(_cisSubscriptionPlan->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan...\n");
#endif
    free(_cisSubscriptionPlan->id);
  }
  if (_cisSubscriptionPlan->vendorParameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionPlan->vendorParameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan...\n");
#endif
    free(_cisSubscriptionPlan->vendorParameters);
  }
  if (_cisSubscriptionPlan->usageCharges != NULL) {
    for (i = 0; i < _cisSubscriptionPlan->_sizeof_usageCharges; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor usageCharges[%i] of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan...\n", i);
#endif
      freeNs0CisUsageChargeType(&(_cisSubscriptionPlan->usageCharges[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor usageCharges of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan...\n");
#endif
    free(_cisSubscriptionPlan->usageCharges);
  }
  if (_cisSubscriptionPlan->charges != NULL) {
    for (i = 0; i < _cisSubscriptionPlan->_sizeof_charges; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor charges[%i] of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan...\n", i);
#endif
      freeNs0CisChargeEntryType(&(_cisSubscriptionPlan->charges[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor charges of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan...\n");
#endif
    free(_cisSubscriptionPlan->charges);
  }
  if (_cisSubscriptionPlan->name != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor name of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan...\n");
#endif
    freeXsStringType(_cisSubscriptionPlan->name);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor name of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan...\n");
#endif
    free(_cisSubscriptionPlan->name);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionPlan_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest_M

/**
 * Reads a CisSubscriptionProfileRequest element from XML. The element to be read is "subscriptionProfileRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionProfileRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionProfileRequestElement(reader);
}

/**
 * Writes a CisSubscriptionProfileRequest to XML under element name "subscriptionProfileRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest) {
  return xmlTextWriterWriteNs0SubscriptionProfileRequestElementNS(writer, _cisSubscriptionProfileRequest, 1);
}

/**
 * Frees a CisSubscriptionProfileRequest.
 *
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest) {
  freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
  free(_cisSubscriptionProfileRequest);
}

/**
 * Reads a CisSubscriptionProfileRequest element from XML. The element to be read is "subscriptionProfileRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionProfileRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *xmlTextReaderReadNs0SubscriptionProfileRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionProfileRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionProfileRequest.\n");
#endif
    _cisSubscriptionProfileRequest = xmlTextReaderReadNs0CisSubscriptionProfileRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionProfileRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionProfileRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionProfileRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionProfileRequest;
}

/**
 * Writes a CisSubscriptionProfileRequest to XML under element name "subscriptionProfileRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionProfileRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest) {
  return xmlTextWriterWriteNs0SubscriptionProfileRequestElementNS(writer, _cisSubscriptionProfileRequest, 0);
}

/**
 * Writes a CisSubscriptionProfileRequest to XML under element name "subscriptionProfileRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionProfileRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionProfileRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionProfileRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionProfileRequest for root element {}subscriptionProfileRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionProfileRequestType(writer, _cisSubscriptionProfileRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionProfileRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionProfileRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionProfileRequest.
 *
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest whose children are to be free.
 */
static void freeNs0SubscriptionProfileRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest) {
  freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
}

/**
 * Reads a CisSubscriptionProfileRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionProfileRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *xmlTextReaderReadNs0CisSubscriptionProfileRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
        free(_cisSubscriptionProfileRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
          free(_cisSubscriptionProfileRequest);
          return NULL;
        }

        _cisSubscriptionProfileRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "profileId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}profileId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}profileId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
          free(_cisSubscriptionProfileRequest);
          return NULL;
        }

        _cisSubscriptionProfileRequest->profileId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "customerName", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}customerName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}customerName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
          free(_cisSubscriptionProfileRequest);
          return NULL;
        }

        _cisSubscriptionProfileRequest->customerName = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "company", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}company of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}company of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
          free(_cisSubscriptionProfileRequest);
          return NULL;
        }

        _cisSubscriptionProfileRequest->company = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "currency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
          free(_cisSubscriptionProfileRequest);
          return NULL;
        }

        _cisSubscriptionProfileRequest->currency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "emailPreference", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}emailPreference of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}emailPreference of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
          free(_cisSubscriptionProfileRequest);
          return NULL;
        }

        _cisSubscriptionProfileRequest->emailPreference = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "languagePreference", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}languagePreference of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}languagePreference of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
          free(_cisSubscriptionProfileRequest);
          return NULL;
        }

        _cisSubscriptionProfileRequest->languagePreference = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "emailAddress", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}emailAddress of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}emailAddress of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
          free(_cisSubscriptionProfileRequest);
          return NULL;
        }

        _cisSubscriptionProfileRequest->emailAddress = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "shippingAddress", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}shippingAddress of type {}cisAddress.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisAddressType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}shippingAddress of type {}cisAddress.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileRequestType(_cisSubscriptionProfileRequest);
          free(_cisSubscriptionProfileRequest);
          return NULL;
        }

        _cisSubscriptionProfileRequest->shippingAddress = ((struct hybris_cis_mock_subscription_web_ns0_cisAddress*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionProfileRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionProfileRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionProfileRequest;
}

/**
 * Writes a CisSubscriptionProfileRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionProfileRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionProfileRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionProfileRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileRequest->profileId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "profileId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}profileId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}profileId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileRequest->profileId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}profileId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}profileId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileRequest->customerName != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "customerName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}customerName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}customerName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileRequest->customerName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}customerName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}customerName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileRequest->company != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "company", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}company. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}company...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileRequest->company));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}company. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}company. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileRequest->currency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "currency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}currency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileRequest->currency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileRequest->emailPreference != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "emailPreference", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}emailPreference. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}emailPreference...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileRequest->emailPreference));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}emailPreference. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}emailPreference. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileRequest->languagePreference != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "languagePreference", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}languagePreference. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}languagePreference...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileRequest->languagePreference));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}languagePreference. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}languagePreference. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileRequest->emailAddress != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "emailAddress", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}emailAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}emailAddress...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileRequest->emailAddress));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}emailAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}emailAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileRequest->shippingAddress != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "shippingAddress", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}shippingAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisAddress for element {}shippingAddress...\n");
#endif
    status = xmlTextWriterWriteNs0CisAddressType(writer, (_cisSubscriptionProfileRequest->shippingAddress));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisAddress for element {}shippingAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}shippingAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionProfileRequest.
 *
 * @param _cisSubscriptionProfileRequest The CisSubscriptionProfileRequest to free.
 */
static void freeNs0CisSubscriptionProfileRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest *_cisSubscriptionProfileRequest) {
  int i;
  if (_cisSubscriptionProfileRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionProfileRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    free(_cisSubscriptionProfileRequest->parameters);
  }
  if (_cisSubscriptionProfileRequest->profileId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor profileId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileRequest->profileId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor profileId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    free(_cisSubscriptionProfileRequest->profileId);
  }
  if (_cisSubscriptionProfileRequest->customerName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor customerName of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileRequest->customerName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor customerName of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    free(_cisSubscriptionProfileRequest->customerName);
  }
  if (_cisSubscriptionProfileRequest->company != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor company of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileRequest->company);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor company of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    free(_cisSubscriptionProfileRequest->company);
  }
  if (_cisSubscriptionProfileRequest->currency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileRequest->currency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    free(_cisSubscriptionProfileRequest->currency);
  }
  if (_cisSubscriptionProfileRequest->emailPreference != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor emailPreference of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileRequest->emailPreference);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor emailPreference of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    free(_cisSubscriptionProfileRequest->emailPreference);
  }
  if (_cisSubscriptionProfileRequest->languagePreference != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor languagePreference of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileRequest->languagePreference);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor languagePreference of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    free(_cisSubscriptionProfileRequest->languagePreference);
  }
  if (_cisSubscriptionProfileRequest->emailAddress != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor emailAddress of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileRequest->emailAddress);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor emailAddress of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    free(_cisSubscriptionProfileRequest->emailAddress);
  }
  if (_cisSubscriptionProfileRequest->shippingAddress != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor shippingAddress of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    freeNs0CisAddressType(_cisSubscriptionProfileRequest->shippingAddress);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor shippingAddress of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest...\n");
#endif
    free(_cisSubscriptionProfileRequest->shippingAddress);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult_M

/**
 * Reads a CisSubscriptionProfileResult element from XML. The element to be read is "subscriptionProfileResult", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionProfileResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionProfileResultElement(reader);
}

/**
 * Writes a CisSubscriptionProfileResult to XML under element name "subscriptionProfileResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult) {
  return xmlTextWriterWriteNs0SubscriptionProfileResultElementNS(writer, _cisSubscriptionProfileResult, 1);
}

/**
 * Frees a CisSubscriptionProfileResult.
 *
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult) {
  freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
  free(_cisSubscriptionProfileResult);
}

/**
 * Reads a CisSubscriptionProfileResult element from XML. The element to be read is "subscriptionProfileResult", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionProfileResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *xmlTextReaderReadNs0SubscriptionProfileResultElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionProfileResult", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionProfileResult.\n");
#endif
    _cisSubscriptionProfileResult = xmlTextReaderReadNs0CisSubscriptionProfileResultType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionProfileResult == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionProfileResult failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionProfileResult failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionProfileResult;
}

/**
 * Writes a CisSubscriptionProfileResult to XML under element name "subscriptionProfileResult".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionProfileResultElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult) {
  return xmlTextWriterWriteNs0SubscriptionProfileResultElementNS(writer, _cisSubscriptionProfileResult, 0);
}

/**
 * Writes a CisSubscriptionProfileResult to XML under element name "subscriptionProfileResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionProfileResultElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionProfileResult", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionProfileResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionProfileResult for root element {}subscriptionProfileResult...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionProfileResultType(writer, _cisSubscriptionProfileResult);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionProfileResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionProfileResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionProfileResult.
 *
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult whose children are to be free.
 */
static void freeNs0SubscriptionProfileResultElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult) {
  freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
}

/**
 * Reads a CisSubscriptionProfileResult from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionProfileResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *xmlTextReaderReadNs0CisSubscriptionProfileResultType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "clientRefId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}clientRefId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}clientRefId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }
        _cisSubscriptionProfileResult->clientRefId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }
        _cisSubscriptionProfileResult->vendorId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorReasonCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorReasonCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorReasonCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }
        _cisSubscriptionProfileResult->vendorReasonCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorStatusCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorStatusCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorStatusCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }
        _cisSubscriptionProfileResult->vendorStatusCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }
        _cisSubscriptionProfileResult->id = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "href", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}href...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}href of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }
        _cisSubscriptionProfileResult->href = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
      free(_cisSubscriptionProfileResult);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
        free(_cisSubscriptionProfileResult);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "decision", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}decision of type {}cisDecision.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisDecisionType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}decision of type {}cisDecision.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->decision = ((enum hybris_cis_mock_subscription_web_ns0_cisDecision*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorResponses", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->vendorResponses = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "amount", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}amount of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDecimalType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}amount of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->amount = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "sessionTransactionToken", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}sessionTransactionToken of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}sessionTransactionToken of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->sessionTransactionToken = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantProductId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantProductId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantProductId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->merchantProductId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "profileId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}profileId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}profileId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->profileId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "currency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->currency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "validationResult", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}validationResult of type {}cisSubscriptionTransactionResult.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisSubscriptionTransactionResultType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}validationResult of type {}cisSubscriptionTransactionResult.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->validationResult = ((struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "paymentMethods", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

        if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
          printf("Unwrapping wrapper element {}paymentMethods...\n");
#endif
          //start wrapper element "{}paymentMethods"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
          while (xmlTextReaderDepth(reader) > (depth + 1)) {
            if (status < 1) {
              //panic: XML read error.
#if DEBUG_ENUNCIATE
              printf("Failure to advance to next child element.\n");
#endif
              freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
              free(_cisSubscriptionProfileResult);
              return NULL;
            }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "paymentMethod", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}paymentMethod of type {}cisPaymentMethod.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisPaymentMethodType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}paymentMethod of type {}cisPaymentMethod.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->paymentMethods = realloc(_cisSubscriptionProfileResult->paymentMethods, (_cisSubscriptionProfileResult->_sizeof_paymentMethods + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod));
        memcpy(&(_cisSubscriptionProfileResult->paymentMethods[_cisSubscriptionProfileResult->_sizeof_paymentMethods++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
          } // end "while in wrapper element" loop
        } //end "if empty element" clause

        if (status < 1) {
          //panic: XML read error.
#if DEBUG_ENUNCIATE
          printf("Failed to advance to end wrapper element {}paymentMethods.\n");
#endif
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }
        else {
          //end wrapper element "{}paymentMethods"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
        }
      } // end "if wrapper element" clause
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptions", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

        if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
          printf("Unwrapping wrapper element {}subscriptions...\n");
#endif
          //start wrapper element "{}subscriptions"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
          while (xmlTextReaderDepth(reader) > (depth + 1)) {
            if (status < 1) {
              //panic: XML read error.
#if DEBUG_ENUNCIATE
              printf("Failure to advance to next child element.\n");
#endif
              freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
              free(_cisSubscriptionProfileResult);
              return NULL;
            }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptions", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptions of type {}cisSubscriptionData.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisSubscriptionDataType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptions of type {}cisSubscriptionData.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->subscriptions = realloc(_cisSubscriptionProfileResult->subscriptions, (_cisSubscriptionProfileResult->_sizeof_subscriptions + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData));
        memcpy(&(_cisSubscriptionProfileResult->subscriptions[_cisSubscriptionProfileResult->_sizeof_subscriptions++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionData));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
          } // end "while in wrapper element" loop
        } //end "if empty element" clause

        if (status < 1) {
          //panic: XML read error.
#if DEBUG_ENUNCIATE
          printf("Failed to advance to end wrapper element {}subscriptions.\n");
#endif
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }
        else {
          //end wrapper element "{}subscriptions"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
        }
      } // end "if wrapper element" clause
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "customerAddress", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}customerAddress of type {}cisAddress.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisAddressType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}customerAddress of type {}cisAddress.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->customerAddress = ((struct hybris_cis_mock_subscription_web_ns0_cisAddress*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "comments", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}comments of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}comments of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionProfileResultType(_cisSubscriptionProfileResult);
          free(_cisSubscriptionProfileResult);
          return NULL;
        }

        _cisSubscriptionProfileResult->comments = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionProfileResult.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionProfileResult. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionProfileResult;
}

/**
 * Writes a CisSubscriptionProfileResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionProfileResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisSubscriptionProfileResult->clientRefId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "clientRefId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}clientRefId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->clientRefId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionProfileResult->vendorId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->vendorId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionProfileResult->vendorReasonCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorReasonCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorReasonCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->vendorReasonCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionProfileResult->vendorStatusCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorStatusCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorStatusCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->vendorStatusCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionProfileResult->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionProfileResult->href != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "href", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}href. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}href...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->href));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileResult->decision != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "decision", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisDecision for element {}decision...\n");
#endif
    status = xmlTextWriterWriteNs0CisDecisionType(writer, (_cisSubscriptionProfileResult->decision));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisDecision for element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileResult->vendorResponses != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorResponses", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorResponses...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionProfileResult->vendorResponses));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileResult->amount != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "amount", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}decimal for element {}amount...\n");
#endif
    status = xmlTextWriterWriteXsDecimalType(writer, (_cisSubscriptionProfileResult->amount));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}decimal for element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileResult->sessionTransactionToken != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "sessionTransactionToken", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}sessionTransactionToken. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}sessionTransactionToken...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->sessionTransactionToken));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}sessionTransactionToken. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}sessionTransactionToken. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileResult->merchantProductId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantProductId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantProductId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->merchantProductId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileResult->profileId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "profileId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}profileId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}profileId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->profileId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}profileId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}profileId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileResult->currency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "currency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}currency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->currency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileResult->validationResult != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "validationResult", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}validationResult. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisSubscriptionTransactionResult for element {}validationResult...\n");
#endif
    status = xmlTextWriterWriteNs0CisSubscriptionTransactionResultType(writer, (_cisSubscriptionProfileResult->validationResult));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisSubscriptionTransactionResult for element {}validationResult. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}validationResult. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionProfileResult->paymentMethods != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "paymentMethods", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}paymentMethods. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisSubscriptionProfileResult->_sizeof_paymentMethods; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "paymentMethod", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisPaymentMethod for element {}paymentMethod...\n");
#endif
    status = xmlTextWriterWriteNs0CisPaymentMethodType(writer, &(_cisSubscriptionProfileResult->paymentMethods[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisPaymentMethod for element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionProfileResult->paymentMethods != NULL) {
    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}paymentMethods. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionProfileResult->subscriptions != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptions", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptions. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisSubscriptionProfileResult->_sizeof_subscriptions; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptions", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptions. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisSubscriptionData for element {}subscriptions...\n");
#endif
    status = xmlTextWriterWriteNs0CisSubscriptionDataType(writer, &(_cisSubscriptionProfileResult->subscriptions[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisSubscriptionData for element {}subscriptions. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptions. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionProfileResult->subscriptions != NULL) {
    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptions. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileResult->customerAddress != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "customerAddress", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}customerAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisAddress for element {}customerAddress...\n");
#endif
    status = xmlTextWriterWriteNs0CisAddressType(writer, (_cisSubscriptionProfileResult->customerAddress));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisAddress for element {}customerAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}customerAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionProfileResult->comments != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "comments", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}comments. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}comments...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionProfileResult->comments));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}comments. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}comments. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionProfileResult.
 *
 * @param _cisSubscriptionProfileResult The CisSubscriptionProfileResult to free.
 */
static void freeNs0CisSubscriptionProfileResultType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult *_cisSubscriptionProfileResult) {
  int i;
  if (_cisSubscriptionProfileResult->clientRefId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->clientRefId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->clientRefId);
  }
  if (_cisSubscriptionProfileResult->vendorId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->vendorId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->vendorId);
  }
  if (_cisSubscriptionProfileResult->vendorReasonCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->vendorReasonCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->vendorReasonCode);
  }
  if (_cisSubscriptionProfileResult->vendorStatusCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->vendorStatusCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->vendorStatusCode);
  }
  if (_cisSubscriptionProfileResult->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->id);
  }
  if (_cisSubscriptionProfileResult->href != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor href of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->href);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor href of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->href);
  }
  if (_cisSubscriptionProfileResult->decision != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor decision of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeNs0CisDecisionType(_cisSubscriptionProfileResult->decision);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor decision of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->decision);
  }
  if (_cisSubscriptionProfileResult->vendorResponses != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionProfileResult->vendorResponses);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->vendorResponses);
  }
  if (_cisSubscriptionProfileResult->amount != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor amount of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsDecimalType(_cisSubscriptionProfileResult->amount);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor amount of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->amount);
  }
  if (_cisSubscriptionProfileResult->sessionTransactionToken != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor sessionTransactionToken of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->sessionTransactionToken);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor sessionTransactionToken of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->sessionTransactionToken);
  }
  if (_cisSubscriptionProfileResult->merchantProductId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantProductId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->merchantProductId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantProductId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->merchantProductId);
  }
  if (_cisSubscriptionProfileResult->profileId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor profileId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->profileId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor profileId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->profileId);
  }
  if (_cisSubscriptionProfileResult->currency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->currency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->currency);
  }
  if (_cisSubscriptionProfileResult->validationResult != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor validationResult of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionProfileResult->validationResult);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor validationResult of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->validationResult);
  }
  if (_cisSubscriptionProfileResult->paymentMethods != NULL) {
    for (i = 0; i < _cisSubscriptionProfileResult->_sizeof_paymentMethods; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor paymentMethods[%i] of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n", i);
#endif
      freeNs0CisPaymentMethodType(&(_cisSubscriptionProfileResult->paymentMethods[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor paymentMethods of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->paymentMethods);
  }
  if (_cisSubscriptionProfileResult->subscriptions != NULL) {
    for (i = 0; i < _cisSubscriptionProfileResult->_sizeof_subscriptions; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor subscriptions[%i] of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n", i);
#endif
      freeNs0CisSubscriptionDataType(&(_cisSubscriptionProfileResult->subscriptions[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptions of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->subscriptions);
  }
  if (_cisSubscriptionProfileResult->customerAddress != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor customerAddress of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeNs0CisAddressType(_cisSubscriptionProfileResult->customerAddress);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor customerAddress of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->customerAddress);
  }
  if (_cisSubscriptionProfileResult->comments != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor comments of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    freeXsStringType(_cisSubscriptionProfileResult->comments);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor comments of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult...\n");
#endif
    free(_cisSubscriptionProfileResult->comments);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionProfileResult_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest_M

/**
 * Reads a CisSubscriptionReplacePaymentMethodRequest element from XML. The element to be read is "subscriptionReplacePaymentMethodRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionReplacePaymentMethodRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionReplacePaymentMethodRequestElement(reader);
}

/**
 * Writes a CisSubscriptionReplacePaymentMethodRequest to XML under element name "subscriptionReplacePaymentMethodRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest) {
  return xmlTextWriterWriteNs0SubscriptionReplacePaymentMethodRequestElementNS(writer, _cisSubscriptionReplacePaymentMethodRequest, 1);
}

/**
 * Frees a CisSubscriptionReplacePaymentMethodRequest.
 *
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest) {
  freeNs0CisSubscriptionReplacePaymentMethodRequestType(_cisSubscriptionReplacePaymentMethodRequest);
  free(_cisSubscriptionReplacePaymentMethodRequest);
}

/**
 * Reads a CisSubscriptionReplacePaymentMethodRequest element from XML. The element to be read is "subscriptionReplacePaymentMethodRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionReplacePaymentMethodRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *xmlTextReaderReadNs0SubscriptionReplacePaymentMethodRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionReplacePaymentMethodRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionReplacePaymentMethodRequest.\n");
#endif
    _cisSubscriptionReplacePaymentMethodRequest = xmlTextReaderReadNs0CisSubscriptionReplacePaymentMethodRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionReplacePaymentMethodRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionReplacePaymentMethodRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionReplacePaymentMethodRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionReplacePaymentMethodRequest;
}

/**
 * Writes a CisSubscriptionReplacePaymentMethodRequest to XML under element name "subscriptionReplacePaymentMethodRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionReplacePaymentMethodRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest) {
  return xmlTextWriterWriteNs0SubscriptionReplacePaymentMethodRequestElementNS(writer, _cisSubscriptionReplacePaymentMethodRequest, 0);
}

/**
 * Writes a CisSubscriptionReplacePaymentMethodRequest to XML under element name "subscriptionReplacePaymentMethodRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionReplacePaymentMethodRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionReplacePaymentMethodRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionReplacePaymentMethodRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionReplacePaymentMethodRequest for root element {}subscriptionReplacePaymentMethodRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionReplacePaymentMethodRequestType(writer, _cisSubscriptionReplacePaymentMethodRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionReplacePaymentMethodRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionReplacePaymentMethodRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionReplacePaymentMethodRequest.
 *
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest whose children are to be free.
 */
static void freeNs0SubscriptionReplacePaymentMethodRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest) {
  freeNs0CisSubscriptionReplacePaymentMethodRequestType(_cisSubscriptionReplacePaymentMethodRequest);
}

/**
 * Reads a CisSubscriptionReplacePaymentMethodRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionReplacePaymentMethodRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *xmlTextReaderReadNs0CisSubscriptionReplacePaymentMethodRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionReplacePaymentMethodRequestType(_cisSubscriptionReplacePaymentMethodRequest);
        free(_cisSubscriptionReplacePaymentMethodRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionReplacePaymentMethodRequestType(_cisSubscriptionReplacePaymentMethodRequest);
          free(_cisSubscriptionReplacePaymentMethodRequest);
          return NULL;
        }

        _cisSubscriptionReplacePaymentMethodRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantSubscriptionId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionReplacePaymentMethodRequestType(_cisSubscriptionReplacePaymentMethodRequest);
          free(_cisSubscriptionReplacePaymentMethodRequest);
          return NULL;
        }

        _cisSubscriptionReplacePaymentMethodRequest->merchantSubscriptionId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantPaymentMethodId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionReplacePaymentMethodRequestType(_cisSubscriptionReplacePaymentMethodRequest);
          free(_cisSubscriptionReplacePaymentMethodRequest);
          return NULL;
        }

        _cisSubscriptionReplacePaymentMethodRequest->merchantPaymentMethodId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionReplacePaymentMethodRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionReplacePaymentMethodRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionReplacePaymentMethodRequest;
}

/**
 * Writes a CisSubscriptionReplacePaymentMethodRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionReplacePaymentMethodRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionReplacePaymentMethodRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionReplacePaymentMethodRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionReplacePaymentMethodRequest->merchantSubscriptionId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantSubscriptionId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantSubscriptionId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionReplacePaymentMethodRequest->merchantSubscriptionId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionReplacePaymentMethodRequest->merchantPaymentMethodId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantPaymentMethodId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionReplacePaymentMethodRequest->merchantPaymentMethodId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionReplacePaymentMethodRequest.
 *
 * @param _cisSubscriptionReplacePaymentMethodRequest The CisSubscriptionReplacePaymentMethodRequest to free.
 */
static void freeNs0CisSubscriptionReplacePaymentMethodRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest *_cisSubscriptionReplacePaymentMethodRequest) {
  int i;
  if (_cisSubscriptionReplacePaymentMethodRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionReplacePaymentMethodRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest...\n");
#endif
    free(_cisSubscriptionReplacePaymentMethodRequest->parameters);
  }
  if (_cisSubscriptionReplacePaymentMethodRequest->merchantSubscriptionId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionReplacePaymentMethodRequest->merchantSubscriptionId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest...\n");
#endif
    free(_cisSubscriptionReplacePaymentMethodRequest->merchantSubscriptionId);
  }
  if (_cisSubscriptionReplacePaymentMethodRequest->merchantPaymentMethodId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionReplacePaymentMethodRequest->merchantPaymentMethodId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest...\n");
#endif
    free(_cisSubscriptionReplacePaymentMethodRequest->merchantPaymentMethodId);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionReplacePaymentMethodRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest_M

/**
 * Reads a CisSubscriptionRequest element from XML. The element to be read is "subscriptionRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionRequestElement(reader);
}

/**
 * Writes a CisSubscriptionRequest to XML under element name "subscriptionRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest) {
  return xmlTextWriterWriteNs0SubscriptionRequestElementNS(writer, _cisSubscriptionRequest, 1);
}

/**
 * Frees a CisSubscriptionRequest.
 *
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest) {
  freeNs0CisSubscriptionRequestType(_cisSubscriptionRequest);
  free(_cisSubscriptionRequest);
}

/**
 * Reads a CisSubscriptionRequest element from XML. The element to be read is "subscriptionRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *xmlTextReaderReadNs0SubscriptionRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionRequest.\n");
#endif
    _cisSubscriptionRequest = xmlTextReaderReadNs0CisSubscriptionRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionRequest;
}

/**
 * Writes a CisSubscriptionRequest to XML under element name "subscriptionRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest) {
  return xmlTextWriterWriteNs0SubscriptionRequestElementNS(writer, _cisSubscriptionRequest, 0);
}

/**
 * Writes a CisSubscriptionRequest to XML under element name "subscriptionRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionRequest for root element {}subscriptionRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionRequestType(writer, _cisSubscriptionRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionRequest.
 *
 * @param _cisSubscriptionRequest The CisSubscriptionRequest whose children are to be free.
 */
static void freeNs0SubscriptionRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest) {
  freeNs0CisSubscriptionRequestType(_cisSubscriptionRequest);
}

/**
 * Reads a CisSubscriptionRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *xmlTextReaderReadNs0CisSubscriptionRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionRequestType(_cisSubscriptionRequest);
        free(_cisSubscriptionRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionRequestType(_cisSubscriptionRequest);
          free(_cisSubscriptionRequest);
          return NULL;
        }

        _cisSubscriptionRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionRequest;
}

/**
 * Writes a CisSubscriptionRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionRequest.
 *
 * @param _cisSubscriptionRequest The CisSubscriptionRequest to free.
 */
static void freeNs0CisSubscriptionRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest *_cisSubscriptionRequest) {
  int i;
  if (_cisSubscriptionRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest...\n");
#endif
    free(_cisSubscriptionRequest->parameters);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest_M

/**
 * Reads a CisSubscriptionSessionFinalizeRequest element from XML. The element to be read is "subscriptionSessionFinalization", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionSessionFinalizeRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionSessionFinalizationElement(reader);
}

/**
 * Writes a CisSubscriptionSessionFinalizeRequest to XML under element name "subscriptionSessionFinalization".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest) {
  return xmlTextWriterWriteNs0SubscriptionSessionFinalizationElementNS(writer, _cisSubscriptionSessionFinalizeRequest, 1);
}

/**
 * Frees a CisSubscriptionSessionFinalizeRequest.
 *
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest) {
  freeNs0CisSubscriptionSessionFinalizeRequestType(_cisSubscriptionSessionFinalizeRequest);
  free(_cisSubscriptionSessionFinalizeRequest);
}

/**
 * Reads a CisSubscriptionSessionFinalizeRequest element from XML. The element to be read is "subscriptionSessionFinalization", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionSessionFinalizeRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *xmlTextReaderReadNs0SubscriptionSessionFinalizationElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionSessionFinalization", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionSessionFinalization.\n");
#endif
    _cisSubscriptionSessionFinalizeRequest = xmlTextReaderReadNs0CisSubscriptionSessionFinalizeRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionSessionFinalizeRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionSessionFinalization failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionSessionFinalization failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionSessionFinalizeRequest;
}

/**
 * Writes a CisSubscriptionSessionFinalizeRequest to XML under element name "subscriptionSessionFinalization".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionSessionFinalizationElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest) {
  return xmlTextWriterWriteNs0SubscriptionSessionFinalizationElementNS(writer, _cisSubscriptionSessionFinalizeRequest, 0);
}

/**
 * Writes a CisSubscriptionSessionFinalizeRequest to XML under element name "subscriptionSessionFinalization".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionSessionFinalizationElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionSessionFinalization", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionSessionFinalization. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionSessionFinalizeRequest for root element {}subscriptionSessionFinalization...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionSessionFinalizeRequestType(writer, _cisSubscriptionSessionFinalizeRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionSessionFinalization. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionSessionFinalization. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionSessionFinalizeRequest.
 *
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest whose children are to be free.
 */
static void freeNs0SubscriptionSessionFinalizationElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest) {
  freeNs0CisSubscriptionSessionFinalizeRequestType(_cisSubscriptionSessionFinalizeRequest);
}

/**
 * Reads a CisSubscriptionSessionFinalizeRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionSessionFinalizeRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *xmlTextReaderReadNs0CisSubscriptionSessionFinalizeRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionSessionFinalizeRequestType(_cisSubscriptionSessionFinalizeRequest);
        free(_cisSubscriptionSessionFinalizeRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionSessionFinalizeRequestType(_cisSubscriptionSessionFinalizeRequest);
          free(_cisSubscriptionSessionFinalizeRequest);
          return NULL;
        }

        _cisSubscriptionSessionFinalizeRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "authorizationRequestId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}authorizationRequestId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}authorizationRequestId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionSessionFinalizeRequestType(_cisSubscriptionSessionFinalizeRequest);
          free(_cisSubscriptionSessionFinalizeRequest);
          return NULL;
        }

        _cisSubscriptionSessionFinalizeRequest->authorizationRequestId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "authorizationRequestToken", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}authorizationRequestToken of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}authorizationRequestToken of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionSessionFinalizeRequestType(_cisSubscriptionSessionFinalizeRequest);
          free(_cisSubscriptionSessionFinalizeRequest);
          return NULL;
        }

        _cisSubscriptionSessionFinalizeRequest->authorizationRequestToken = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionSessionFinalizeRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionSessionFinalizeRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionSessionFinalizeRequest;
}

/**
 * Writes a CisSubscriptionSessionFinalizeRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionSessionFinalizeRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionSessionFinalizeRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionSessionFinalizeRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionSessionFinalizeRequest->authorizationRequestId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "authorizationRequestId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}authorizationRequestId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}authorizationRequestId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionSessionFinalizeRequest->authorizationRequestId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}authorizationRequestId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}authorizationRequestId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionSessionFinalizeRequest->authorizationRequestToken != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "authorizationRequestToken", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}authorizationRequestToken. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}authorizationRequestToken...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionSessionFinalizeRequest->authorizationRequestToken));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}authorizationRequestToken. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}authorizationRequestToken. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionSessionFinalizeRequest.
 *
 * @param _cisSubscriptionSessionFinalizeRequest The CisSubscriptionSessionFinalizeRequest to free.
 */
static void freeNs0CisSubscriptionSessionFinalizeRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest *_cisSubscriptionSessionFinalizeRequest) {
  int i;
  if (_cisSubscriptionSessionFinalizeRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionSessionFinalizeRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest...\n");
#endif
    free(_cisSubscriptionSessionFinalizeRequest->parameters);
  }
  if (_cisSubscriptionSessionFinalizeRequest->authorizationRequestId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor authorizationRequestId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionSessionFinalizeRequest->authorizationRequestId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor authorizationRequestId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest...\n");
#endif
    free(_cisSubscriptionSessionFinalizeRequest->authorizationRequestId);
  }
  if (_cisSubscriptionSessionFinalizeRequest->authorizationRequestToken != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor authorizationRequestToken of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionSessionFinalizeRequest->authorizationRequestToken);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor authorizationRequestToken of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest...\n");
#endif
    free(_cisSubscriptionSessionFinalizeRequest->authorizationRequestToken);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionFinalizeRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest_M

/**
 * Reads a CisSubscriptionSessionInitRequest element from XML. The element to be read is "subscriptionSessionInitRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionSessionInitRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionSessionInitRequestElement(reader);
}

/**
 * Writes a CisSubscriptionSessionInitRequest to XML under element name "subscriptionSessionInitRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest) {
  return xmlTextWriterWriteNs0SubscriptionSessionInitRequestElementNS(writer, _cisSubscriptionSessionInitRequest, 1);
}

/**
 * Frees a CisSubscriptionSessionInitRequest.
 *
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest) {
  freeNs0CisSubscriptionSessionInitRequestType(_cisSubscriptionSessionInitRequest);
  free(_cisSubscriptionSessionInitRequest);
}

/**
 * Reads a CisSubscriptionSessionInitRequest element from XML. The element to be read is "subscriptionSessionInitRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionSessionInitRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *xmlTextReaderReadNs0SubscriptionSessionInitRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionSessionInitRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionSessionInitRequest.\n");
#endif
    _cisSubscriptionSessionInitRequest = xmlTextReaderReadNs0CisSubscriptionSessionInitRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionSessionInitRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionSessionInitRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionSessionInitRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionSessionInitRequest;
}

/**
 * Writes a CisSubscriptionSessionInitRequest to XML under element name "subscriptionSessionInitRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionSessionInitRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest) {
  return xmlTextWriterWriteNs0SubscriptionSessionInitRequestElementNS(writer, _cisSubscriptionSessionInitRequest, 0);
}

/**
 * Writes a CisSubscriptionSessionInitRequest to XML under element name "subscriptionSessionInitRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionSessionInitRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionSessionInitRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionSessionInitRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionSessionInitRequest for root element {}subscriptionSessionInitRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionSessionInitRequestType(writer, _cisSubscriptionSessionInitRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionSessionInitRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionSessionInitRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionSessionInitRequest.
 *
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest whose children are to be free.
 */
static void freeNs0SubscriptionSessionInitRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest) {
  freeNs0CisSubscriptionSessionInitRequestType(_cisSubscriptionSessionInitRequest);
}

/**
 * Reads a CisSubscriptionSessionInitRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionSessionInitRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *xmlTextReaderReadNs0CisSubscriptionSessionInitRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionSessionInitRequestType(_cisSubscriptionSessionInitRequest);
        free(_cisSubscriptionSessionInitRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionSessionInitRequestType(_cisSubscriptionSessionInitRequest);
          free(_cisSubscriptionSessionInitRequest);
          return NULL;
        }

        _cisSubscriptionSessionInitRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "returnUrl", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}returnUrl of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}returnUrl of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionSessionInitRequestType(_cisSubscriptionSessionInitRequest);
          free(_cisSubscriptionSessionInitRequest);
          return NULL;
        }

        _cisSubscriptionSessionInitRequest->returnUrl = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "cancelReturnUrl", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}cancelReturnUrl of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}cancelReturnUrl of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionSessionInitRequestType(_cisSubscriptionSessionInitRequest);
          free(_cisSubscriptionSessionInitRequest);
          return NULL;
        }

        _cisSubscriptionSessionInitRequest->cancelReturnUrl = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "ipAddress", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}ipAddress of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}ipAddress of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionSessionInitRequestType(_cisSubscriptionSessionInitRequest);
          free(_cisSubscriptionSessionInitRequest);
          return NULL;
        }

        _cisSubscriptionSessionInitRequest->ipAddress = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantAccountId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionSessionInitRequestType(_cisSubscriptionSessionInitRequest);
          free(_cisSubscriptionSessionInitRequest);
          return NULL;
        }

        _cisSubscriptionSessionInitRequest->merchantAccountId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionSessionInitRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionSessionInitRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionSessionInitRequest;
}

/**
 * Writes a CisSubscriptionSessionInitRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionSessionInitRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionSessionInitRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionSessionInitRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionSessionInitRequest->returnUrl != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "returnUrl", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}returnUrl. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}returnUrl...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionSessionInitRequest->returnUrl));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}returnUrl. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}returnUrl. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionSessionInitRequest->cancelReturnUrl != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "cancelReturnUrl", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}cancelReturnUrl. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}cancelReturnUrl...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionSessionInitRequest->cancelReturnUrl));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}cancelReturnUrl. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}cancelReturnUrl. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionSessionInitRequest->ipAddress != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "ipAddress", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}ipAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}ipAddress...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionSessionInitRequest->ipAddress));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}ipAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}ipAddress. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionSessionInitRequest->merchantAccountId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantAccountId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionSessionInitRequest->merchantAccountId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionSessionInitRequest.
 *
 * @param _cisSubscriptionSessionInitRequest The CisSubscriptionSessionInitRequest to free.
 */
static void freeNs0CisSubscriptionSessionInitRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest *_cisSubscriptionSessionInitRequest) {
  int i;
  if (_cisSubscriptionSessionInitRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionSessionInitRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest...\n");
#endif
    free(_cisSubscriptionSessionInitRequest->parameters);
  }
  if (_cisSubscriptionSessionInitRequest->returnUrl != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor returnUrl of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionSessionInitRequest->returnUrl);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor returnUrl of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest...\n");
#endif
    free(_cisSubscriptionSessionInitRequest->returnUrl);
  }
  if (_cisSubscriptionSessionInitRequest->cancelReturnUrl != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor cancelReturnUrl of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionSessionInitRequest->cancelReturnUrl);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor cancelReturnUrl of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest...\n");
#endif
    free(_cisSubscriptionSessionInitRequest->cancelReturnUrl);
  }
  if (_cisSubscriptionSessionInitRequest->ipAddress != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor ipAddress of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionSessionInitRequest->ipAddress);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor ipAddress of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest...\n");
#endif
    free(_cisSubscriptionSessionInitRequest->ipAddress);
  }
  if (_cisSubscriptionSessionInitRequest->merchantAccountId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionSessionInitRequest->merchantAccountId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest...\n");
#endif
    free(_cisSubscriptionSessionInitRequest->merchantAccountId);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionSessionInitRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult_M

/**
 * Reads a CisSubscriptionTransactionResult element from XML. The element to be read is "subscriptionTransactionResult", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionTransactionResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionTransactionResultElement(reader);
}

/**
 * Writes a CisSubscriptionTransactionResult to XML under element name "subscriptionTransactionResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult) {
  return xmlTextWriterWriteNs0SubscriptionTransactionResultElementNS(writer, _cisSubscriptionTransactionResult, 1);
}

/**
 * Frees a CisSubscriptionTransactionResult.
 *
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult) {
  freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
  free(_cisSubscriptionTransactionResult);
}

/**
 * Reads a CisSubscriptionTransactionResult element from XML. The element to be read is "subscriptionTransactionResult", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionTransactionResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *xmlTextReaderReadNs0SubscriptionTransactionResultElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionTransactionResult", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionTransactionResult.\n");
#endif
    _cisSubscriptionTransactionResult = xmlTextReaderReadNs0CisSubscriptionTransactionResultType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionTransactionResult == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionTransactionResult failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionTransactionResult failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionTransactionResult;
}

/**
 * Writes a CisSubscriptionTransactionResult to XML under element name "subscriptionTransactionResult".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionTransactionResultElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult) {
  return xmlTextWriterWriteNs0SubscriptionTransactionResultElementNS(writer, _cisSubscriptionTransactionResult, 0);
}

/**
 * Writes a CisSubscriptionTransactionResult to XML under element name "subscriptionTransactionResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionTransactionResultElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionTransactionResult", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionTransactionResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionTransactionResult for root element {}subscriptionTransactionResult...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionTransactionResultType(writer, _cisSubscriptionTransactionResult);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionTransactionResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionTransactionResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionTransactionResult.
 *
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult whose children are to be free.
 */
static void freeNs0SubscriptionTransactionResultElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult) {
  freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
}

/**
 * Reads a CisSubscriptionTransactionResult from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionTransactionResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *xmlTextReaderReadNs0CisSubscriptionTransactionResultType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "clientRefId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}clientRefId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}clientRefId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }
        _cisSubscriptionTransactionResult->clientRefId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }
        _cisSubscriptionTransactionResult->vendorId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorReasonCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorReasonCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorReasonCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }
        _cisSubscriptionTransactionResult->vendorReasonCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorStatusCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorStatusCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorStatusCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }
        _cisSubscriptionTransactionResult->vendorStatusCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }
        _cisSubscriptionTransactionResult->id = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "href", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}href...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}href of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }
        _cisSubscriptionTransactionResult->href = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
      free(_cisSubscriptionTransactionResult);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
        free(_cisSubscriptionTransactionResult);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "decision", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}decision of type {}cisDecision.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisDecisionType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}decision of type {}cisDecision.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }

        _cisSubscriptionTransactionResult->decision = ((enum hybris_cis_mock_subscription_web_ns0_cisDecision*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorResponses", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }

        _cisSubscriptionTransactionResult->vendorResponses = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "amount", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}amount of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDecimalType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}amount of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }

        _cisSubscriptionTransactionResult->amount = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "sessionTransactionToken", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}sessionTransactionToken of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}sessionTransactionToken of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }

        _cisSubscriptionTransactionResult->sessionTransactionToken = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantProductId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantProductId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantProductId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionTransactionResultType(_cisSubscriptionTransactionResult);
          free(_cisSubscriptionTransactionResult);
          return NULL;
        }

        _cisSubscriptionTransactionResult->merchantProductId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionTransactionResult.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionTransactionResult. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionTransactionResult;
}

/**
 * Writes a CisSubscriptionTransactionResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionTransactionResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisSubscriptionTransactionResult->clientRefId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "clientRefId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}clientRefId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionTransactionResult->clientRefId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionTransactionResult->vendorId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionTransactionResult->vendorId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionTransactionResult->vendorReasonCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorReasonCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorReasonCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionTransactionResult->vendorReasonCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionTransactionResult->vendorStatusCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorStatusCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorStatusCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionTransactionResult->vendorStatusCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionTransactionResult->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionTransactionResult->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionTransactionResult->href != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "href", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}href. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}href...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionTransactionResult->href));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionTransactionResult->decision != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "decision", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisDecision for element {}decision...\n");
#endif
    status = xmlTextWriterWriteNs0CisDecisionType(writer, (_cisSubscriptionTransactionResult->decision));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisDecision for element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionTransactionResult->vendorResponses != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorResponses", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorResponses...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionTransactionResult->vendorResponses));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionTransactionResult->amount != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "amount", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}decimal for element {}amount...\n");
#endif
    status = xmlTextWriterWriteXsDecimalType(writer, (_cisSubscriptionTransactionResult->amount));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}decimal for element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}amount. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionTransactionResult->sessionTransactionToken != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "sessionTransactionToken", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}sessionTransactionToken. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}sessionTransactionToken...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionTransactionResult->sessionTransactionToken));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}sessionTransactionToken. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}sessionTransactionToken. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionTransactionResult->merchantProductId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantProductId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantProductId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionTransactionResult->merchantProductId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionTransactionResult.
 *
 * @param _cisSubscriptionTransactionResult The CisSubscriptionTransactionResult to free.
 */
static void freeNs0CisSubscriptionTransactionResultType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult *_cisSubscriptionTransactionResult) {
  int i;
  if (_cisSubscriptionTransactionResult->clientRefId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeXsStringType(_cisSubscriptionTransactionResult->clientRefId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->clientRefId);
  }
  if (_cisSubscriptionTransactionResult->vendorId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeXsStringType(_cisSubscriptionTransactionResult->vendorId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->vendorId);
  }
  if (_cisSubscriptionTransactionResult->vendorReasonCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeXsStringType(_cisSubscriptionTransactionResult->vendorReasonCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->vendorReasonCode);
  }
  if (_cisSubscriptionTransactionResult->vendorStatusCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeXsStringType(_cisSubscriptionTransactionResult->vendorStatusCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->vendorStatusCode);
  }
  if (_cisSubscriptionTransactionResult->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeXsStringType(_cisSubscriptionTransactionResult->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->id);
  }
  if (_cisSubscriptionTransactionResult->href != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor href of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeXsStringType(_cisSubscriptionTransactionResult->href);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor href of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->href);
  }
  if (_cisSubscriptionTransactionResult->decision != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor decision of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeNs0CisDecisionType(_cisSubscriptionTransactionResult->decision);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor decision of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->decision);
  }
  if (_cisSubscriptionTransactionResult->vendorResponses != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionTransactionResult->vendorResponses);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->vendorResponses);
  }
  if (_cisSubscriptionTransactionResult->amount != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor amount of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeXsDecimalType(_cisSubscriptionTransactionResult->amount);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor amount of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->amount);
  }
  if (_cisSubscriptionTransactionResult->sessionTransactionToken != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor sessionTransactionToken of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeXsStringType(_cisSubscriptionTransactionResult->sessionTransactionToken);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor sessionTransactionToken of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->sessionTransactionToken);
  }
  if (_cisSubscriptionTransactionResult->merchantProductId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantProductId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    freeXsStringType(_cisSubscriptionTransactionResult->merchantProductId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantProductId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult...\n");
#endif
    free(_cisSubscriptionTransactionResult->merchantProductId);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionTransactionResult_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest_M

/**
 * Reads a CisSubscriptionUpdateRequest element from XML. The element to be read is "subscriptionUpdateRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpdateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionUpdateRequestElement(reader);
}

/**
 * Writes a CisSubscriptionUpdateRequest to XML under element name "subscriptionUpdateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest) {
  return xmlTextWriterWriteNs0SubscriptionUpdateRequestElementNS(writer, _cisSubscriptionUpdateRequest, 1);
}

/**
 * Frees a CisSubscriptionUpdateRequest.
 *
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest) {
  freeNs0CisSubscriptionUpdateRequestType(_cisSubscriptionUpdateRequest);
  free(_cisSubscriptionUpdateRequest);
}

/**
 * Reads a CisSubscriptionUpdateRequest element from XML. The element to be read is "subscriptionUpdateRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpdateRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *xmlTextReaderReadNs0SubscriptionUpdateRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionUpdateRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionUpdateRequest.\n");
#endif
    _cisSubscriptionUpdateRequest = xmlTextReaderReadNs0CisSubscriptionUpdateRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionUpdateRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionUpdateRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionUpdateRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionUpdateRequest;
}

/**
 * Writes a CisSubscriptionUpdateRequest to XML under element name "subscriptionUpdateRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionUpdateRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest) {
  return xmlTextWriterWriteNs0SubscriptionUpdateRequestElementNS(writer, _cisSubscriptionUpdateRequest, 0);
}

/**
 * Writes a CisSubscriptionUpdateRequest to XML under element name "subscriptionUpdateRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionUpdateRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionUpdateRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionUpdateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionUpdateRequest for root element {}subscriptionUpdateRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionUpdateRequestType(writer, _cisSubscriptionUpdateRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionUpdateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionUpdateRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionUpdateRequest.
 *
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest whose children are to be free.
 */
static void freeNs0SubscriptionUpdateRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest) {
  freeNs0CisSubscriptionUpdateRequestType(_cisSubscriptionUpdateRequest);
}

/**
 * Reads a CisSubscriptionUpdateRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionUpdateRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *xmlTextReaderReadNs0CisSubscriptionUpdateRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionUpdateRequestType(_cisSubscriptionUpdateRequest);
        free(_cisSubscriptionUpdateRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpdateRequestType(_cisSubscriptionUpdateRequest);
          free(_cisSubscriptionUpdateRequest);
          return NULL;
        }

        _cisSubscriptionUpdateRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "effectiveFrom", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}effectiveFrom of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}effectiveFrom of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpdateRequestType(_cisSubscriptionUpdateRequest);
          free(_cisSubscriptionUpdateRequest);
          return NULL;
        }

        _cisSubscriptionUpdateRequest->effectiveFrom = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantSubscriptionId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpdateRequestType(_cisSubscriptionUpdateRequest);
          free(_cisSubscriptionUpdateRequest);
          return NULL;
        }

        _cisSubscriptionUpdateRequest->merchantSubscriptionId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantPaymentMethodId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpdateRequestType(_cisSubscriptionUpdateRequest);
          free(_cisSubscriptionUpdateRequest);
          return NULL;
        }

        _cisSubscriptionUpdateRequest->merchantPaymentMethodId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "autoRenewal", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}autoRenewal of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}autoRenewal of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpdateRequestType(_cisSubscriptionUpdateRequest);
          free(_cisSubscriptionUpdateRequest);
          return NULL;
        }

        _cisSubscriptionUpdateRequest->autoRenewal = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "contractDurationExtension", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}contractDurationExtension of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}contractDurationExtension of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpdateRequestType(_cisSubscriptionUpdateRequest);
          free(_cisSubscriptionUpdateRequest);
          return NULL;
        }

        _cisSubscriptionUpdateRequest->contractDurationExtension = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionUpdateRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionUpdateRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionUpdateRequest;
}

/**
 * Writes a CisSubscriptionUpdateRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionUpdateRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionUpdateRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionUpdateRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpdateRequest->effectiveFrom != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "effectiveFrom", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}effectiveFrom. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}effectiveFrom...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpdateRequest->effectiveFrom));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}effectiveFrom. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}effectiveFrom. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpdateRequest->merchantSubscriptionId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantSubscriptionId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantSubscriptionId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpdateRequest->merchantSubscriptionId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpdateRequest->merchantPaymentMethodId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantPaymentMethodId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpdateRequest->merchantPaymentMethodId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpdateRequest->autoRenewal != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "autoRenewal", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}autoRenewal...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, (_cisSubscriptionUpdateRequest->autoRenewal));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpdateRequest->contractDurationExtension != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "contractDurationExtension", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}contractDurationExtension. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}contractDurationExtension...\n");
#endif
    status = xmlTextWriterWriteXsIntType(writer, (_cisSubscriptionUpdateRequest->contractDurationExtension));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}contractDurationExtension. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}contractDurationExtension. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionUpdateRequest.
 *
 * @param _cisSubscriptionUpdateRequest The CisSubscriptionUpdateRequest to free.
 */
static void freeNs0CisSubscriptionUpdateRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest *_cisSubscriptionUpdateRequest) {
  int i;
  if (_cisSubscriptionUpdateRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionUpdateRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    free(_cisSubscriptionUpdateRequest->parameters);
  }
  if (_cisSubscriptionUpdateRequest->effectiveFrom != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor effectiveFrom of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionUpdateRequest->effectiveFrom);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor effectiveFrom of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    free(_cisSubscriptionUpdateRequest->effectiveFrom);
  }
  if (_cisSubscriptionUpdateRequest->merchantSubscriptionId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionUpdateRequest->merchantSubscriptionId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    free(_cisSubscriptionUpdateRequest->merchantSubscriptionId);
  }
  if (_cisSubscriptionUpdateRequest->merchantPaymentMethodId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionUpdateRequest->merchantPaymentMethodId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    free(_cisSubscriptionUpdateRequest->merchantPaymentMethodId);
  }
  if (_cisSubscriptionUpdateRequest->autoRenewal != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor autoRenewal of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    freeXsBooleanType(_cisSubscriptionUpdateRequest->autoRenewal);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor autoRenewal of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    free(_cisSubscriptionUpdateRequest->autoRenewal);
  }
  if (_cisSubscriptionUpdateRequest->contractDurationExtension != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor contractDurationExtension of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    freeXsIntType(_cisSubscriptionUpdateRequest->contractDurationExtension);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor contractDurationExtension of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest...\n");
#endif
    free(_cisSubscriptionUpdateRequest->contractDurationExtension);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpdateRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest_M

/**
 * Reads a CisSubscriptionUpgradeRequest element from XML. The element to be read is "subscriptionUpgradeRequest", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpgradeRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionUpgradeRequestElement(reader);
}

/**
 * Writes a CisSubscriptionUpgradeRequest to XML under element name "subscriptionUpgradeRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest) {
  return xmlTextWriterWriteNs0SubscriptionUpgradeRequestElementNS(writer, _cisSubscriptionUpgradeRequest, 1);
}

/**
 * Frees a CisSubscriptionUpgradeRequest.
 *
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest) {
  freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
  free(_cisSubscriptionUpgradeRequest);
}

/**
 * Reads a CisSubscriptionUpgradeRequest element from XML. The element to be read is "subscriptionUpgradeRequest", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpgradeRequest, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *xmlTextReaderReadNs0SubscriptionUpgradeRequestElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionUpgradeRequest", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionUpgradeRequest.\n");
#endif
    _cisSubscriptionUpgradeRequest = xmlTextReaderReadNs0CisSubscriptionUpgradeRequestType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionUpgradeRequest == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionUpgradeRequest failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionUpgradeRequest failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionUpgradeRequest;
}

/**
 * Writes a CisSubscriptionUpgradeRequest to XML under element name "subscriptionUpgradeRequest".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionUpgradeRequestElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest) {
  return xmlTextWriterWriteNs0SubscriptionUpgradeRequestElementNS(writer, _cisSubscriptionUpgradeRequest, 0);
}

/**
 * Writes a CisSubscriptionUpgradeRequest to XML under element name "subscriptionUpgradeRequest".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionUpgradeRequestElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionUpgradeRequest", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionUpgradeRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionUpgradeRequest for root element {}subscriptionUpgradeRequest...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionUpgradeRequestType(writer, _cisSubscriptionUpgradeRequest);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionUpgradeRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionUpgradeRequest. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionUpgradeRequest.
 *
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest whose children are to be free.
 */
static void freeNs0SubscriptionUpgradeRequestElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest) {
  freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
}

/**
 * Reads a CisSubscriptionUpgradeRequest from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionUpgradeRequest, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *xmlTextReaderReadNs0CisSubscriptionUpgradeRequestType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
        free(_cisSubscriptionUpgradeRequest);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->parameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "orderId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}orderId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}orderId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->orderId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "currency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->currency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "orderDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}orderDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}orderDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->orderDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantAccountId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->merchantAccountId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantPaymentMethodId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantPaymentMethodId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->merchantPaymentMethodId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionItem", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionItem of type {}cisSubscriptionItem.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisSubscriptionItemType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionItem of type {}cisSubscriptionItem.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->subscriptionItem = ((struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionItem*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "sourceSubscriptionId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}sourceSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}sourceSubscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->merchantSourceSubscriptionId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "settlement", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}settlement of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}settlement of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->settlement = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "effectiveFrom", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}effectiveFrom of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}effectiveFrom of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->effectiveFrom = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "preview", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}preview of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}preview of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeRequestType(_cisSubscriptionUpgradeRequest);
          free(_cisSubscriptionUpgradeRequest);
          return NULL;
        }

        _cisSubscriptionUpgradeRequest->preview = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionUpgradeRequest.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionUpgradeRequest. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionUpgradeRequest;
}

/**
 * Writes a CisSubscriptionUpgradeRequest to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionUpgradeRequestType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisSubscriptionUpgradeRequest->parameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionUpgradeRequest->parameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeRequest->orderId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "orderId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}orderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}orderId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeRequest->orderId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}orderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}orderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeRequest->currency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "currency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}currency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeRequest->currency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeRequest->orderDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "orderDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}date for element {}orderDate...\n");
#endif
    status = xmlTextWriterWriteXsDateType(writer, (_cisSubscriptionUpgradeRequest->orderDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}date for element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeRequest->merchantAccountId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantAccountId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeRequest->merchantAccountId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeRequest->merchantPaymentMethodId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantPaymentMethodId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeRequest->merchantPaymentMethodId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantPaymentMethodId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeRequest->subscriptionItem != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionItem", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisSubscriptionItem for element {}subscriptionItem...\n");
#endif
    status = xmlTextWriterWriteNs0CisSubscriptionItemType(writer, (_cisSubscriptionUpgradeRequest->subscriptionItem));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisSubscriptionItem for element {}subscriptionItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionItem. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeRequest->merchantSourceSubscriptionId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "sourceSubscriptionId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}sourceSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}sourceSubscriptionId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeRequest->merchantSourceSubscriptionId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}sourceSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}sourceSubscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeRequest->settlement != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "settlement", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}settlement. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}settlement...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeRequest->settlement));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}settlement. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}settlement. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeRequest->effectiveFrom != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "effectiveFrom", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}effectiveFrom. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}effectiveFrom...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeRequest->effectiveFrom));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}effectiveFrom. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}effectiveFrom. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "preview", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}preview. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}preview...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, &(_cisSubscriptionUpgradeRequest->preview));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}preview. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}preview. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionUpgradeRequest.
 *
 * @param _cisSubscriptionUpgradeRequest The CisSubscriptionUpgradeRequest to free.
 */
static void freeNs0CisSubscriptionUpgradeRequestType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest *_cisSubscriptionUpgradeRequest) {
  int i;
  if (_cisSubscriptionUpgradeRequest->parameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionUpgradeRequest->parameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor parameters of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    free(_cisSubscriptionUpgradeRequest->parameters);
  }
  if (_cisSubscriptionUpgradeRequest->orderId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor orderId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeRequest->orderId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor orderId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    free(_cisSubscriptionUpgradeRequest->orderId);
  }
  if (_cisSubscriptionUpgradeRequest->currency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeRequest->currency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    free(_cisSubscriptionUpgradeRequest->currency);
  }
  if (_cisSubscriptionUpgradeRequest->orderDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor orderDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    freeXsDateType(_cisSubscriptionUpgradeRequest->orderDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor orderDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    free(_cisSubscriptionUpgradeRequest->orderDate);
  }
  if (_cisSubscriptionUpgradeRequest->merchantAccountId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeRequest->merchantAccountId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    free(_cisSubscriptionUpgradeRequest->merchantAccountId);
  }
  if (_cisSubscriptionUpgradeRequest->merchantPaymentMethodId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeRequest->merchantPaymentMethodId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantPaymentMethodId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    free(_cisSubscriptionUpgradeRequest->merchantPaymentMethodId);
  }
  if (_cisSubscriptionUpgradeRequest->subscriptionItem != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionItem of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    freeNs0CisSubscriptionItemType(_cisSubscriptionUpgradeRequest->subscriptionItem);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionItem of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    free(_cisSubscriptionUpgradeRequest->subscriptionItem);
  }
  if (_cisSubscriptionUpgradeRequest->merchantSourceSubscriptionId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantSourceSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeRequest->merchantSourceSubscriptionId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantSourceSubscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    free(_cisSubscriptionUpgradeRequest->merchantSourceSubscriptionId);
  }
  if (_cisSubscriptionUpgradeRequest->settlement != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor settlement of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeRequest->settlement);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor settlement of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    free(_cisSubscriptionUpgradeRequest->settlement);
  }
  if (_cisSubscriptionUpgradeRequest->effectiveFrom != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor effectiveFrom of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeRequest->effectiveFrom);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor effectiveFrom of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest...\n");
#endif
    free(_cisSubscriptionUpgradeRequest->effectiveFrom);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeRequest_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult_M

/**
 * Reads a CisSubscriptionUpgradeResult element from XML. The element to be read is "subscriptionUpgradeResult", and
 * it is assumed that the reader is pointing to the XML document (not the element).
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpgradeResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *xml_read_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult(xmlTextReaderPtr reader) {
  int status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
  return xmlTextReaderReadNs0SubscriptionUpgradeResultElement(reader);
}

/**
 * Writes a CisSubscriptionUpgradeResult to XML under element name "subscriptionUpgradeResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to write.
 * @return 1 if successful, 0 otherwise.
 */
int xml_write_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult) {
  return xmlTextWriterWriteNs0SubscriptionUpgradeResultElementNS(writer, _cisSubscriptionUpgradeResult, 1);
}

/**
 * Frees a CisSubscriptionUpgradeResult.
 *
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to free.
 */
void free_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult) {
  freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
  free(_cisSubscriptionUpgradeResult);
}

/**
 * Reads a CisSubscriptionUpgradeResult element from XML. The element to be read is "subscriptionUpgradeResult", and
 * it is assumed that the reader is pointing to that element.
 *
 * @param reader The XML reader.
 * @return The CisSubscriptionUpgradeResult, or NULL in case of error.
 */
struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *xmlTextReaderReadNs0SubscriptionUpgradeResultElement(xmlTextReaderPtr reader) {
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult = NULL;

  if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
    && xmlStrcmp(BAD_CAST "subscriptionUpgradeResult", xmlTextReaderConstLocalName(reader)) == 0
    && xmlTextReaderConstNamespaceUri(reader) == NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Attempting to read root element {}subscriptionUpgradeResult.\n");
#endif
    _cisSubscriptionUpgradeResult = xmlTextReaderReadNs0CisSubscriptionUpgradeResultType(reader);
  }
#if DEBUG_ENUNCIATE
  if (_cisSubscriptionUpgradeResult == NULL) {
    if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
      printf("attempt to read {}subscriptionUpgradeResult failed. current element: {}%s\n",  xmlTextReaderConstLocalName(reader));
    }
    else {
      printf("attempt to read {}subscriptionUpgradeResult failed. current element: {%s}%s\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
    }
  }
#endif

  return _cisSubscriptionUpgradeResult;
}

/**
 * Writes a CisSubscriptionUpgradeResult to XML under element name "subscriptionUpgradeResult".
 * Does NOT write the namespace prefixes.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to write.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionUpgradeResultElement(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult) {
  return xmlTextWriterWriteNs0SubscriptionUpgradeResultElementNS(writer, _cisSubscriptionUpgradeResult, 0);
}

/**
 * Writes a CisSubscriptionUpgradeResult to XML under element name "subscriptionUpgradeResult".
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to write.
 * @param writeNamespaces Whether to write the namespace prefixes.
 * @return 1 if successful, 0 otherwise.
 */
static int xmlTextWriterWriteNs0SubscriptionUpgradeResultElementNS(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult, int writeNamespaces) {
  int totalBytes = 0;
  int status;

  status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionUpgradeResult", NULL);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write start element {}subscriptionUpgradeResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

#if DEBUG_ENUNCIATE > 1
  printf("writing type {}cisSubscriptionUpgradeResult for root element {}subscriptionUpgradeResult...\n");
#endif
  status = xmlTextWriterWriteNs0CisSubscriptionUpgradeResultType(writer, _cisSubscriptionUpgradeResult);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to write type for start element {}subscriptionUpgradeResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  status = xmlTextWriterEndElement(writer);
  if (status < 0) {
#if DEBUG_ENUNCIATE
    printf("unable to end element {}subscriptionUpgradeResult. status: %i\n", status);
#endif
    return status;
  }
  totalBytes += status;

  return totalBytes;
}

/**
 * Frees the children of a CisSubscriptionUpgradeResult.
 *
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult whose children are to be free.
 */
static void freeNs0SubscriptionUpgradeResultElement(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult) {
  freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
}

/**
 * Reads a CisSubscriptionUpgradeResult from XML. The reader is assumed to be at the start element.
 *
 * @return the CisSubscriptionUpgradeResult, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *xmlTextReaderReadNs0CisSubscriptionUpgradeResultType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "clientRefId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}clientRefId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}clientRefId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }
        _cisSubscriptionUpgradeResult->clientRefId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorId", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorId...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }
        _cisSubscriptionUpgradeResult->vendorId = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorReasonCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorReasonCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorReasonCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }
        _cisSubscriptionUpgradeResult->vendorReasonCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "vendorStatusCode", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}vendorStatusCode...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}vendorStatusCode of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }
        _cisSubscriptionUpgradeResult->vendorStatusCode = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }
        _cisSubscriptionUpgradeResult->id = ((xmlChar*)_child_accessor);
        continue;
      }
      if ((xmlStrcmp(BAD_CAST "href", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}href...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}href of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }
        _cisSubscriptionUpgradeResult->href = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
      free(_cisSubscriptionUpgradeResult);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
        free(_cisSubscriptionUpgradeResult);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "decision", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}decision of type {}cisDecision.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisDecisionType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}decision of type {}cisDecision.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->decision = ((enum hybris_cis_mock_subscription_web_ns0_cisDecision*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorResponses", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorResponses of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->vendorResponses = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "merchantAccountId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}merchantAccountId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->merchantAccountId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "currency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}currency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->currency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->subscriptionId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionName", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->subscriptionName = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionDescription", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionDescription of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionDescription of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->subscriptionDescription = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionProductId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionProductId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionProductId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->subscriptionProductId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionOrderId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionOrderId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionOrderId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->subscriptionOrderId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionOrderEntryId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionOrderEntryId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionOrderEntryId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->subscriptionOrderEntryId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingSystemId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingSystemId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingSystemId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->billingSystemId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionStartDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionStartDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionStartDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->subscriptionStartDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionEndDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionEndDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionEndDate of type {http://www.w3.org/2001/XMLSchema}date.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->subscriptionEndDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "subscriptionStatus", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}subscriptionStatus of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}subscriptionStatus of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->subscriptionStatus = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "cancellationPossible", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}cancellationPossible of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}cancellationPossible of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->cancellationPossible = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingFrequency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingFrequency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingFrequency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->billingFrequency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "contractDuration", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}contractDuration of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}contractDuration of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->contractDuration = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "orderDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}orderDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateTimeType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}orderDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->orderDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "cancelDate", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}cancelDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDateTimeType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}cancelDate of type {http://www.w3.org/2001/XMLSchema}dateTime.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->cancelDate = ((struct tm*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "comments", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}comments of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}comments of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->comments = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "paymentMethod", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}paymentMethod of type {}cisPaymentMethod.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisPaymentMethodType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}paymentMethod of type {}cisPaymentMethod.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->paymentMethod = ((struct hybris_cis_mock_subscription_web_ns0_cisPaymentMethod*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "autoRenewal", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}autoRenewal of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}autoRenewal of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->autoRenewal = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "futureBillings", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

        if (xmlTextReaderIsEmptyElement(reader) == 0) {
#if DEBUG_ENUNCIATE > 1
          printf("Unwrapping wrapper element {}futureBillings...\n");
#endif
          //start wrapper element "{}futureBillings"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
          while (xmlTextReaderDepth(reader) > (depth + 1)) {
            if (status < 1) {
              //panic: XML read error.
#if DEBUG_ENUNCIATE
              printf("Failure to advance to next child element.\n");
#endif
              freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
              free(_cisSubscriptionUpgradeResult);
              return NULL;
            }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "futureBillings", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}futureBillings of type {}cisSubscriptionBillingInfo.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisSubscriptionBillingInfoType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}futureBillings of type {}cisSubscriptionBillingInfo.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }

        _cisSubscriptionUpgradeResult->futureBillings = realloc(_cisSubscriptionUpgradeResult->futureBillings, (_cisSubscriptionUpgradeResult->_sizeof_futureBillings + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo));
        memcpy(&(_cisSubscriptionUpgradeResult->futureBillings[_cisSubscriptionUpgradeResult->_sizeof_futureBillings++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionBillingInfo));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
          } // end "while in wrapper element" loop
        } //end "if empty element" clause

        if (status < 1) {
          //panic: XML read error.
#if DEBUG_ENUNCIATE
          printf("Failed to advance to end wrapper element {}futureBillings.\n");
#endif
          freeNs0CisSubscriptionUpgradeResultType(_cisSubscriptionUpgradeResult);
          free(_cisSubscriptionUpgradeResult);
          return NULL;
        }
        else {
          //end wrapper element "{}futureBillings"
          status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
        }
      } // end "if wrapper element" clause
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisSubscriptionUpgradeResult.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisSubscriptionUpgradeResult. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisSubscriptionUpgradeResult;
}

/**
 * Writes a CisSubscriptionUpgradeResult to XML.
 *
 * @param writer The XML writer.
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisSubscriptionUpgradeResultType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisSubscriptionUpgradeResult->clientRefId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "clientRefId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}clientRefId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->clientRefId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}clientRefId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionUpgradeResult->vendorId != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->vendorId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorId. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionUpgradeResult->vendorReasonCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorReasonCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorReasonCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->vendorReasonCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorReasonCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionUpgradeResult->vendorStatusCode != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "vendorStatusCode", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}vendorStatusCode. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->vendorStatusCode));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}vendorStatusCode. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionUpgradeResult->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionUpgradeResult->href != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "href", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}href. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}href...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->href));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}href. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->decision != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "decision", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisDecision for element {}decision...\n");
#endif
    status = xmlTextWriterWriteNs0CisDecisionType(writer, (_cisSubscriptionUpgradeResult->decision));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisDecision for element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}decision. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->vendorResponses != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorResponses", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorResponses...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisSubscriptionUpgradeResult->vendorResponses));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorResponses. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->merchantAccountId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "merchantAccountId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->merchantAccountId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}merchantAccountId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->currency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "currency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}currency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->currency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}currency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->subscriptionId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->subscriptionId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->subscriptionName != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->subscriptionName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->subscriptionDescription != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionDescription", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionDescription...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->subscriptionDescription));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionDescription. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->subscriptionProductId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionProductId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionProductId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->subscriptionProductId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionProductId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->subscriptionOrderId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionOrderId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionOrderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionOrderId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->subscriptionOrderId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionOrderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionOrderId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->subscriptionOrderEntryId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionOrderEntryId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionOrderEntryId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionOrderEntryId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->subscriptionOrderEntryId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionOrderEntryId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionOrderEntryId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->billingSystemId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingSystemId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingSystemId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}billingSystemId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->billingSystemId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}billingSystemId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingSystemId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->subscriptionStartDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionStartDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionStartDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}date for element {}subscriptionStartDate...\n");
#endif
    status = xmlTextWriterWriteXsDateType(writer, (_cisSubscriptionUpgradeResult->subscriptionStartDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}date for element {}subscriptionStartDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionStartDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->subscriptionEndDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionEndDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionEndDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}date for element {}subscriptionEndDate...\n");
#endif
    status = xmlTextWriterWriteXsDateType(writer, (_cisSubscriptionUpgradeResult->subscriptionEndDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}date for element {}subscriptionEndDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionEndDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->subscriptionStatus != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "subscriptionStatus", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}subscriptionStatus. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionStatus...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->subscriptionStatus));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}subscriptionStatus. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}subscriptionStatus. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->cancellationPossible != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "cancellationPossible", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}cancellationPossible. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}cancellationPossible...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, (_cisSubscriptionUpgradeResult->cancellationPossible));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}cancellationPossible. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}cancellationPossible. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->billingFrequency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingFrequency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingFrequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}billingFrequency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->billingFrequency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}billingFrequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingFrequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->contractDuration != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "contractDuration", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}contractDuration. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}contractDuration...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->contractDuration));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}contractDuration. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}contractDuration. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->orderDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "orderDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}dateTime for element {}orderDate...\n");
#endif
    status = xmlTextWriterWriteXsDateTimeType(writer, (_cisSubscriptionUpgradeResult->orderDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}dateTime for element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}orderDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->cancelDate != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "cancelDate", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}cancelDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}dateTime for element {}cancelDate...\n");
#endif
    status = xmlTextWriterWriteXsDateTimeType(writer, (_cisSubscriptionUpgradeResult->cancelDate));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}dateTime for element {}cancelDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}cancelDate. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->comments != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "comments", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}comments. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}comments...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisSubscriptionUpgradeResult->comments));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}comments. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}comments. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->paymentMethod != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "paymentMethod", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisPaymentMethod for element {}paymentMethod...\n");
#endif
    status = xmlTextWriterWriteNs0CisPaymentMethodType(writer, (_cisSubscriptionUpgradeResult->paymentMethod));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisPaymentMethod for element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}paymentMethod. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisSubscriptionUpgradeResult->autoRenewal != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "autoRenewal", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}autoRenewal...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, (_cisSubscriptionUpgradeResult->autoRenewal));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionUpgradeResult->futureBillings != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "futureBillings", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}futureBillings. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisSubscriptionUpgradeResult->_sizeof_futureBillings; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "futureBillings", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}futureBillings. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisSubscriptionBillingInfo for element {}futureBillings...\n");
#endif
    status = xmlTextWriterWriteNs0CisSubscriptionBillingInfoType(writer, &(_cisSubscriptionUpgradeResult->futureBillings[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisSubscriptionBillingInfo for element {}futureBillings. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}futureBillings. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  if (_cisSubscriptionUpgradeResult->futureBillings != NULL) {
    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}futureBillings. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisSubscriptionUpgradeResult.
 *
 * @param _cisSubscriptionUpgradeResult The CisSubscriptionUpgradeResult to free.
 */
static void freeNs0CisSubscriptionUpgradeResultType(struct hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult *_cisSubscriptionUpgradeResult) {
  int i;
  if (_cisSubscriptionUpgradeResult->clientRefId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->clientRefId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor clientRefId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->clientRefId);
  }
  if (_cisSubscriptionUpgradeResult->vendorId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->vendorId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->vendorId);
  }
  if (_cisSubscriptionUpgradeResult->vendorReasonCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->vendorReasonCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorReasonCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->vendorReasonCode);
  }
  if (_cisSubscriptionUpgradeResult->vendorStatusCode != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->vendorStatusCode);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorStatusCode of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->vendorStatusCode);
  }
  if (_cisSubscriptionUpgradeResult->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->id);
  }
  if (_cisSubscriptionUpgradeResult->href != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor href of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->href);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor href of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->href);
  }
  if (_cisSubscriptionUpgradeResult->decision != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor decision of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeNs0CisDecisionType(_cisSubscriptionUpgradeResult->decision);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor decision of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->decision);
  }
  if (_cisSubscriptionUpgradeResult->vendorResponses != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeNs0AnnotationHashMapType(_cisSubscriptionUpgradeResult->vendorResponses);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorResponses of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->vendorResponses);
  }
  if (_cisSubscriptionUpgradeResult->merchantAccountId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->merchantAccountId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor merchantAccountId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->merchantAccountId);
  }
  if (_cisSubscriptionUpgradeResult->currency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->currency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor currency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->currency);
  }
  if (_cisSubscriptionUpgradeResult->subscriptionId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->subscriptionId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->subscriptionId);
  }
  if (_cisSubscriptionUpgradeResult->subscriptionName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionName of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->subscriptionName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionName of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->subscriptionName);
  }
  if (_cisSubscriptionUpgradeResult->subscriptionDescription != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionDescription of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->subscriptionDescription);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionDescription of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->subscriptionDescription);
  }
  if (_cisSubscriptionUpgradeResult->subscriptionProductId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionProductId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->subscriptionProductId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionProductId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->subscriptionProductId);
  }
  if (_cisSubscriptionUpgradeResult->subscriptionOrderId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionOrderId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->subscriptionOrderId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionOrderId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->subscriptionOrderId);
  }
  if (_cisSubscriptionUpgradeResult->subscriptionOrderEntryId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionOrderEntryId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->subscriptionOrderEntryId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionOrderEntryId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->subscriptionOrderEntryId);
  }
  if (_cisSubscriptionUpgradeResult->billingSystemId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingSystemId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->billingSystemId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingSystemId of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->billingSystemId);
  }
  if (_cisSubscriptionUpgradeResult->subscriptionStartDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionStartDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsDateType(_cisSubscriptionUpgradeResult->subscriptionStartDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionStartDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->subscriptionStartDate);
  }
  if (_cisSubscriptionUpgradeResult->subscriptionEndDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionEndDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsDateType(_cisSubscriptionUpgradeResult->subscriptionEndDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionEndDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->subscriptionEndDate);
  }
  if (_cisSubscriptionUpgradeResult->subscriptionStatus != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor subscriptionStatus of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->subscriptionStatus);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor subscriptionStatus of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->subscriptionStatus);
  }
  if (_cisSubscriptionUpgradeResult->cancellationPossible != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor cancellationPossible of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsBooleanType(_cisSubscriptionUpgradeResult->cancellationPossible);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor cancellationPossible of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->cancellationPossible);
  }
  if (_cisSubscriptionUpgradeResult->billingFrequency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingFrequency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->billingFrequency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingFrequency of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->billingFrequency);
  }
  if (_cisSubscriptionUpgradeResult->contractDuration != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor contractDuration of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->contractDuration);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor contractDuration of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->contractDuration);
  }
  if (_cisSubscriptionUpgradeResult->orderDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor orderDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsDateTimeType(_cisSubscriptionUpgradeResult->orderDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor orderDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->orderDate);
  }
  if (_cisSubscriptionUpgradeResult->cancelDate != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor cancelDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsDateTimeType(_cisSubscriptionUpgradeResult->cancelDate);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor cancelDate of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->cancelDate);
  }
  if (_cisSubscriptionUpgradeResult->comments != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor comments of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsStringType(_cisSubscriptionUpgradeResult->comments);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor comments of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->comments);
  }
  if (_cisSubscriptionUpgradeResult->paymentMethod != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor paymentMethod of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeNs0CisPaymentMethodType(_cisSubscriptionUpgradeResult->paymentMethod);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor paymentMethod of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->paymentMethod);
  }
  if (_cisSubscriptionUpgradeResult->autoRenewal != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor autoRenewal of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    freeXsBooleanType(_cisSubscriptionUpgradeResult->autoRenewal);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor autoRenewal of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->autoRenewal);
  }
  if (_cisSubscriptionUpgradeResult->futureBillings != NULL) {
    for (i = 0; i < _cisSubscriptionUpgradeResult->_sizeof_futureBillings; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor futureBillings[%i] of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n", i);
#endif
      freeNs0CisSubscriptionBillingInfoType(&(_cisSubscriptionUpgradeResult->futureBillings[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor futureBillings of type hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult...\n");
#endif
    free(_cisSubscriptionUpgradeResult->futureBillings);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisSubscriptionUpgradeResult_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisTermsOfService_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisTermsOfService_M

/**
 * Reads a CisTermsOfService from XML. The reader is assumed to be at the start element.
 *
 * @return the CisTermsOfService, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService *xmlTextReaderReadNs0CisTermsOfServiceType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService *_cisTermsOfService = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService));

  if (xmlTextReaderHasAttributes(reader)) {
    while (xmlTextReaderMoveToNextAttribute(reader)) {
      if ((xmlStrcmp(BAD_CAST "id", xmlTextReaderConstLocalName(reader)) == 0) && (xmlTextReaderConstNamespaceUri(reader) == NULL)) {
#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read type {http://www.w3.org/2001/XMLSchema}string from attribute {}id...\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
          //panic: unable to return the attribute value for some reason.
#if DEBUG_ENUNCIATE
          printf("Failed to read attribute {}id of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }
        _cisTermsOfService->id = ((xmlChar*)_child_accessor);
        continue;
      }
    }

    status = xmlTextReaderMoveToElement(reader);
    if (status < 1) {
      //panic: unable to return to the element node.
#if DEBUG_ENUNCIATE
      printf("Unable to return to element node from attributes.\n");
#endif
      freeNs0CisTermsOfServiceType(_cisTermsOfService);
      free(_cisTermsOfService);
      return NULL;
    }
  }


  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisTermsOfServiceType(_cisTermsOfService);
        free(_cisTermsOfService);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingCycleDay", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingCycleDay of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingCycleDay of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }

        _cisTermsOfService->billingCycleDay = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingPlanName", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingPlanName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingPlanName of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }

        _cisTermsOfService->billingPlanName = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "name", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }

        _cisTermsOfService->name = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingPlanId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingPlanId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingPlanId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }

        _cisTermsOfService->billingPlanId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "billingFrequency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}billingFrequency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}billingFrequency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }

        _cisTermsOfService->billingFrequency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "frequency", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}frequency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}frequency of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }

        _cisTermsOfService->frequency = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "number", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}number of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}number of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }

        _cisTermsOfService->number = *((int*)_child_accessor);
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "vendorParameters", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0AnnotationHashMapType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}vendorParameters of type {}annotationHashMap.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }

        _cisTermsOfService->vendorParameters = ((struct hybris_cis_mock_subscription_web_ns0_annotationHashMap*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "cancellable", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}cancellable of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}cancellable of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }

        _cisTermsOfService->cancellable = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "autoRenewal", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}autoRenewal of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
        _child_accessor = xmlTextReaderReadXsBooleanType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}autoRenewal of type {http://www.w3.org/2001/XMLSchema}boolean.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisTermsOfServiceType(_cisTermsOfService);
          free(_cisTermsOfService);
          return NULL;
        }

        _cisTermsOfService->autoRenewal = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisTermsOfService.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisTermsOfService. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisTermsOfService;
}

/**
 * Writes a CisTermsOfService to XML.
 *
 * @param writer The XML writer.
 * @param _cisTermsOfService The CisTermsOfService to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisTermsOfServiceType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService *_cisTermsOfService) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;

  if (_cisTermsOfService->id != NULL) {
    status = xmlTextWriterStartAttributeNS(writer, NULL, BAD_CAST "id", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start attribute {}id. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for attribute {}id...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisTermsOfService->id));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndAttribute(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end attribute {}id. status: %i", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingCycleDay", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingCycleDay. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}billingCycleDay...\n");
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_cisTermsOfService->billingCycleDay));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}billingCycleDay. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingCycleDay. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisTermsOfService->billingPlanName != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingPlanName", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingPlanName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}billingPlanName...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisTermsOfService->billingPlanName));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}billingPlanName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingPlanName. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisTermsOfService->name != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "name", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}name...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisTermsOfService->name));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisTermsOfService->billingPlanId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingPlanId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingPlanId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}billingPlanId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisTermsOfService->billingPlanId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}billingPlanId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingPlanId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisTermsOfService->billingFrequency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "billingFrequency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}billingFrequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}billingFrequency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisTermsOfService->billingFrequency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}billingFrequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}billingFrequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisTermsOfService->frequency != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "frequency", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}frequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}frequency...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisTermsOfService->frequency));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}frequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}frequency. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (1) { //always write the primitive element.
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "number", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}number. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}number...\n");
#endif
    status = xmlTextWriterWriteXsIntType(writer, &(_cisTermsOfService->number));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}number. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}number. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisTermsOfService->vendorParameters != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "vendorParameters", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}annotationHashMap for element {}vendorParameters...\n");
#endif
    status = xmlTextWriterWriteNs0AnnotationHashMapType(writer, (_cisTermsOfService->vendorParameters));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}annotationHashMap for element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}vendorParameters. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisTermsOfService->cancellable != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "cancellable", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}cancellable. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}cancellable...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, (_cisTermsOfService->cancellable));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}cancellable. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}cancellable. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisTermsOfService->autoRenewal != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "autoRenewal", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}boolean for element {}autoRenewal...\n");
#endif
    status = xmlTextWriterWriteXsBooleanType(writer, (_cisTermsOfService->autoRenewal));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}boolean for element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}autoRenewal. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisTermsOfService.
 *
 * @param _cisTermsOfService The CisTermsOfService to free.
 */
static void freeNs0CisTermsOfServiceType(struct hybris_cis_mock_subscription_web_ns0_cisTermsOfService *_cisTermsOfService) {
  int i;
  if (_cisTermsOfService->id != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor id of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    freeXsStringType(_cisTermsOfService->id);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor id of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    free(_cisTermsOfService->id);
  }
  if (_cisTermsOfService->billingPlanName != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingPlanName of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    freeXsStringType(_cisTermsOfService->billingPlanName);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingPlanName of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    free(_cisTermsOfService->billingPlanName);
  }
  if (_cisTermsOfService->name != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor name of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    freeXsStringType(_cisTermsOfService->name);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor name of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    free(_cisTermsOfService->name);
  }
  if (_cisTermsOfService->billingPlanId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingPlanId of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    freeXsStringType(_cisTermsOfService->billingPlanId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingPlanId of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    free(_cisTermsOfService->billingPlanId);
  }
  if (_cisTermsOfService->billingFrequency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor billingFrequency of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    freeXsStringType(_cisTermsOfService->billingFrequency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor billingFrequency of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    free(_cisTermsOfService->billingFrequency);
  }
  if (_cisTermsOfService->frequency != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor frequency of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    freeXsStringType(_cisTermsOfService->frequency);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor frequency of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    free(_cisTermsOfService->frequency);
  }
  if (_cisTermsOfService->vendorParameters != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    freeNs0AnnotationHashMapType(_cisTermsOfService->vendorParameters);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor vendorParameters of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    free(_cisTermsOfService->vendorParameters);
  }
  if (_cisTermsOfService->cancellable != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor cancellable of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    freeXsBooleanType(_cisTermsOfService->cancellable);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor cancellable of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    free(_cisTermsOfService->cancellable);
  }
  if (_cisTermsOfService->autoRenewal != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor autoRenewal of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    freeXsBooleanType(_cisTermsOfService->autoRenewal);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor autoRenewal of type hybris_cis_mock_subscription_web_ns0_cisTermsOfService...\n");
#endif
    free(_cisTermsOfService->autoRenewal);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisTermsOfService_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisUsageCharge_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisUsageCharge_M

/**
 * Reads a CisUsageCharge from XML. The reader is assumed to be at the start element.
 *
 * @return the CisUsageCharge, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge *xmlTextReaderReadNs0CisUsageChargeType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge *_cisUsageCharge = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisUsageChargeType(_cisUsageCharge);
        free(_cisUsageCharge);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "name", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}name of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisUsageChargeType(_cisUsageCharge);
          free(_cisUsageCharge);
          return NULL;
        }

        _cisUsageCharge->name = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "type", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}type of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}type of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisUsageChargeType(_cisUsageCharge);
          free(_cisUsageCharge);
          return NULL;
        }

        _cisUsageCharge->type = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "unitId", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}unitId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
        _child_accessor = xmlTextReaderReadXsStringType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}unitId of type {http://www.w3.org/2001/XMLSchema}string.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisUsageChargeType(_cisUsageCharge);
          free(_cisUsageCharge);
          return NULL;
        }

        _cisUsageCharge->unitId = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "tier", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}tier of type {}cisUsageChargeTier.\n");
#endif
        _child_accessor = xmlTextReaderReadNs0CisUsageChargeTierType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}tier of type {}cisUsageChargeTier.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisUsageChargeType(_cisUsageCharge);
          free(_cisUsageCharge);
          return NULL;
        }

        _cisUsageCharge->tiers = realloc(_cisUsageCharge->tiers, (_cisUsageCharge->_sizeof_tiers + 1) * sizeof(struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier));
        memcpy(&(_cisUsageCharge->tiers[_cisUsageCharge->_sizeof_tiers++]), _child_accessor, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier));
        free(_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisUsageCharge.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisUsageCharge. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisUsageCharge;
}

/**
 * Writes a CisUsageCharge to XML.
 *
 * @param writer The XML writer.
 * @param _cisUsageCharge The CisUsageCharge to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisUsageChargeType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge *_cisUsageCharge) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisUsageCharge->name != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "name", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}name...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisUsageCharge->name));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}name. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisUsageCharge->type != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "type", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}type. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}type...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisUsageCharge->type));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}type. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}type. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisUsageCharge->unitId != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "unitId", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}unitId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}string for element {}unitId...\n");
#endif
    status = xmlTextWriterWriteXsStringType(writer, (_cisUsageCharge->unitId));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}string for element {}unitId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}unitId. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  for (i = 0; i < _cisUsageCharge->_sizeof_tiers; i++) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "tier", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}tier. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {}cisUsageChargeTier for element {}tier...\n");
#endif
    status = xmlTextWriterWriteNs0CisUsageChargeTierType(writer, &(_cisUsageCharge->tiers[i]));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {}cisUsageChargeTier for element {}tier. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}tier. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisUsageCharge.
 *
 * @param _cisUsageCharge The CisUsageCharge to free.
 */
static void freeNs0CisUsageChargeType(struct hybris_cis_mock_subscription_web_ns0_cisUsageCharge *_cisUsageCharge) {
  int i;
  if (_cisUsageCharge->name != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor name of type hybris_cis_mock_subscription_web_ns0_cisUsageCharge...\n");
#endif
    freeXsStringType(_cisUsageCharge->name);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor name of type hybris_cis_mock_subscription_web_ns0_cisUsageCharge...\n");
#endif
    free(_cisUsageCharge->name);
  }
  if (_cisUsageCharge->type != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor type of type hybris_cis_mock_subscription_web_ns0_cisUsageCharge...\n");
#endif
    freeXsStringType(_cisUsageCharge->type);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor type of type hybris_cis_mock_subscription_web_ns0_cisUsageCharge...\n");
#endif
    free(_cisUsageCharge->type);
  }
  if (_cisUsageCharge->unitId != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor unitId of type hybris_cis_mock_subscription_web_ns0_cisUsageCharge...\n");
#endif
    freeXsStringType(_cisUsageCharge->unitId);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor unitId of type hybris_cis_mock_subscription_web_ns0_cisUsageCharge...\n");
#endif
    free(_cisUsageCharge->unitId);
  }
  if (_cisUsageCharge->tiers != NULL) {
    for (i = 0; i < _cisUsageCharge->_sizeof_tiers; i++) {
#if DEBUG_ENUNCIATE > 1
      printf("Freeing accessor tiers[%i] of type hybris_cis_mock_subscription_web_ns0_cisUsageCharge...\n", i);
#endif
      freeNs0CisUsageChargeTierType(&(_cisUsageCharge->tiers[i]));
    }
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor tiers of type hybris_cis_mock_subscription_web_ns0_cisUsageCharge...\n");
#endif
    free(_cisUsageCharge->tiers);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisUsageCharge_M */
#ifndef DEF_hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier_M
#define DEF_hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier_M

/**
 * Reads a CisUsageChargeTier from XML. The reader is assumed to be at the start element.
 *
 * @return the CisUsageChargeTier, or NULL in case of error.
 */
static struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier *xmlTextReaderReadNs0CisUsageChargeTierType(xmlTextReaderPtr reader) {
  int status, depth;
  void *_child_accessor;
  struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier *_cisUsageChargeTier = calloc(1, sizeof(struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier));



  if (xmlTextReaderIsEmptyElement(reader) == 0) {
    depth = xmlTextReaderDepth(reader);//track the depth.
    status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);

    while (xmlTextReaderDepth(reader) > depth) {
      if (status < 1) {
        //panic: XML read error.
#if DEBUG_ENUNCIATE
        printf("Failure to advance to next child element.\n");
#endif
        freeNs0CisUsageChargeTierType(_cisUsageChargeTier);
        free(_cisUsageChargeTier);
        return NULL;
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "numberOfUnits", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}numberOfUnits of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
        _child_accessor = xmlTextReaderReadXsIntType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}numberOfUnits of type {http://www.w3.org/2001/XMLSchema}int.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisUsageChargeTierType(_cisUsageChargeTier);
          free(_cisUsageChargeTier);
          return NULL;
        }

        _cisUsageChargeTier->numberOfUnits = ((int*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else if (xmlTextReaderNodeType(reader) == XML_READER_TYPE_ELEMENT
        && xmlStrcmp(BAD_CAST "chargePrice", xmlTextReaderConstLocalName(reader)) == 0
        && xmlTextReaderConstNamespaceUri(reader) == NULL) {

#if DEBUG_ENUNCIATE > 1
        printf("Attempting to read choice {}chargePrice of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
        _child_accessor = xmlTextReaderReadXsDecimalType(reader);
        if (_child_accessor == NULL) {
#if DEBUG_ENUNCIATE
          printf("Failed to read choice {}chargePrice of type {http://www.w3.org/2001/XMLSchema}decimal.\n");
#endif
          //panic: unable to read the child element for some reason.
          freeNs0CisUsageChargeTierType(_cisUsageChargeTier);
          free(_cisUsageChargeTier);
          return NULL;
        }

        _cisUsageChargeTier->chargePrice = ((xmlChar*)_child_accessor);
        status = xmlTextReaderAdvanceToNextStartOrEndElement(reader);
      }
      else {
#if DEBUG_ENUNCIATE > 1
        if (xmlTextReaderConstNamespaceUri(reader) == NULL) {
          printf("unknown child element {}%s for type {}cisUsageChargeTier.  Skipping...\n",  xmlTextReaderConstLocalName(reader));
        }
        else {
          printf("unknown child element {%s}%s for type {}cisUsageChargeTier. Skipping...\n", xmlTextReaderConstNamespaceUri(reader), xmlTextReaderConstLocalName(reader));
        }
#endif
        status = xmlTextReaderSkipElement(reader);
      }
    }
  }

  return _cisUsageChargeTier;
}

/**
 * Writes a CisUsageChargeTier to XML.
 *
 * @param writer The XML writer.
 * @param _cisUsageChargeTier The CisUsageChargeTier to write.
 * @return The total bytes written, or -1 on error;
 */
static int xmlTextWriterWriteNs0CisUsageChargeTierType(xmlTextWriterPtr writer, struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier *_cisUsageChargeTier) {
  int status, totalBytes = 0, i;
  xmlChar *binaryData;
  if (_cisUsageChargeTier->numberOfUnits != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "numberOfUnits", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}numberOfUnits. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}int for element {}numberOfUnits...\n");
#endif
    status = xmlTextWriterWriteXsIntType(writer, (_cisUsageChargeTier->numberOfUnits));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}int for element {}numberOfUnits. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}numberOfUnits. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }
  if (_cisUsageChargeTier->chargePrice != NULL) {
    status = xmlTextWriterStartElementNS(writer, NULL, BAD_CAST "chargePrice", NULL);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write start element {}chargePrice. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
#if DEBUG_ENUNCIATE > 1
    printf("writing type {http://www.w3.org/2001/XMLSchema}decimal for element {}chargePrice...\n");
#endif
    status = xmlTextWriterWriteXsDecimalType(writer, (_cisUsageChargeTier->chargePrice));
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write type {http://www.w3.org/2001/XMLSchema}decimal for element {}chargePrice. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;

    status = xmlTextWriterEndElement(writer);
    if (status < 0) {
#if DEBUG_ENUNCIATE
      printf("Failed to write end element {}chargePrice. status: %i\n", status);
#endif
      return status;
    }
    totalBytes += status;
  }

  return totalBytes;
}

/**
 * Frees the elements of a CisUsageChargeTier.
 *
 * @param _cisUsageChargeTier The CisUsageChargeTier to free.
 */
static void freeNs0CisUsageChargeTierType(struct hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier *_cisUsageChargeTier) {
  int i;
  if (_cisUsageChargeTier->numberOfUnits != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor numberOfUnits of type hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier...\n");
#endif
    freeXsIntType(_cisUsageChargeTier->numberOfUnits);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor numberOfUnits of type hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier...\n");
#endif
    free(_cisUsageChargeTier->numberOfUnits);
  }
  if (_cisUsageChargeTier->chargePrice != NULL) {
#if DEBUG_ENUNCIATE > 1
    printf("Freeing type of accessor chargePrice of type hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier...\n");
#endif
    freeXsDecimalType(_cisUsageChargeTier->chargePrice);
#if DEBUG_ENUNCIATE > 1
    printf("Freeing accessor chargePrice of type hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier...\n");
#endif
    free(_cisUsageChargeTier->chargePrice);
  }
}
#endif /* DEF_hybris_cis_mock_subscription_web_ns0_cisUsageChargeTier_M */
